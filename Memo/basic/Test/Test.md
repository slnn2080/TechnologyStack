### 测试概念

> 功能测试 (手工测试):
- 针对程序的功能来进行验证(手动) 保证软件的功能正常的实现

- 在测试的过程中 我们不仅要验证正向功能测试(正向也是我们首先要覆盖的) 还要考虑其他的场景
- 1. 正常的功能是否完成
- 2. 当出现错误的时候应该怎么样


> 自动化测试
- 使用代码或者工具代替人工验证项目功能


> 接口测试
- 针对模块与模块或系统与系统之间数据请求地址进行测试


> 性能测试
- 模拟多人使用软件 查找服务器缺陷
- 性能测试是关注我们的程序能多少人使用

----------------

### 常见的测试分类

> 按测试阶段划分
- 按照 软件开发 从无到有 分的阶段

- 1. 单元测试 (白盒测试)
- 针对程序 *源代码* 进行测试 开发边写代码边进行单元测试 按照程序一个一个功能来作为单元进行测试

- 单元测试一般都是开发在做
<!-- 
  我们写了20行代码 然后我们将程序运行起来 20行代码执行是不是按照我们的意愿 能不能覆盖

  比如条件成立要执行 第五行代码 条件不成立应该执行 第七行代码 我们要验证代码是否按照我们的逻辑去执行

  比如阶段性的测自己写的代码发现bug很容易 不是说整个项目都写完了2万行代码再测试找bug就很难了

  当测试发现bug之后提交给开发 开发处理bug 开发的修复率会很低和很慢 这个时候就会要求下一个模块进行的时候必须做单测
 -->

---

- 2. 集成测试 (接口测试)
- 针对 模块 之间访问地址进行测试
- 单元测试是按照功能块来分别测试 集成测试就是将几个功能组合起来来进行测试
- 也就是说针对功能与功能之间的互相调用来进行测试
<!-- 
  软件里面任何功能都有业务关系 比如订单和库存 库存和订单都是单独的模块 比如下订单要检测库存里面有没有数量 

  集成测试现在说的就是接口测试 这个部分是最简单的
 -->

---

- 3. 系统测试
- 对整个系统全面进行测试包括 功能 *兼容* 文档 等测试
- 就是针对集成测试进行测试(针对几个功能集合一起测试性能)

---

- 4. 验收测试
- 主要分内测 公测 使用不同人群来挖掘项目缺陷
- 性能测试(系统测试)完毕后 验收测试主要是针对指定的项目类型
<!-- 
  比如游戏当中的 公测 和 内测 公测和内测就是验收
  内测: 阿尔法测试  α 
  公测: 贝塔测试    β

  这些字母代表要测试的顺序
 -->

---


> 按代码可见度划分
- 1. 黑盒测试 (系统测试)
- 看不见源代码 主要针对程序 *功能* 进行测试

- 2. 灰盒测试 (集成测试)
- 看见部分代码 主要针对程序 *接口* 进行测试

- 3. 白盒测试 (单元测试)
- 看见全部代码 主要针对程序 *源代码* 进行测试


> 自动化测试归属什么测试?
- 理论上说黑盒测试, 实际中属于功能测试 因为自动化测试*只针对程序的功能*

> 总结:
- 1. 系统测试 和 黑盒测试 重点核心是 功能测试
- 2. 集成测试 和 灰盒测试 又称 接口测试
- 3. 单元测试 和 白盒测试 是对 代码 进行测试
- 4. 自动化测试 归属于 功能测试
- 5. 性能测试 安全测试 归属于 专项测试

---


> 测试策略
- 指的是做某个测试之前采用的一种方法
- 我们这里介绍一个 *冒烟测试*

<!-- 
  举例:
    本月20号 开发要交付给测试4个模块 给测试3天时间 要把这几个模块测试完毕 

    4个模块要投入6个人 测试验证的时候发现 主功能都跑不通 登录都登录不进去 依赖登录以后要验证的点都需要等着开发修复

    开发修复 修复了2天 3天后项目经理说要交付完成 
    找开发 开发会说找测试 测试还没测完呢
    找测试 测试会说找开发 开发修复还没修复完呢

  这样就会耽误工期 开发不写bug 测试能耽误工期么
 -->

> 冒烟测试:
- 大规模执行测试之前 针对程序的主功能进行验证 保证程序具备可测性

- 上述的情况下最好的解决方案就是冒烟测试
- *冒烟就是跑模块的主功能*确保可以进入到正常的测试环节

<!-- 
  交付上来的4个模块我们要先试用一下 如果没具备可测性(主功能都跑不通) 那开发晚上加班自己搞定
 -->

> 面试题:
- 提测标准是什么?  -- 冒烟测试通过
- 测试之前要怎么做?  -- 进行冒烟测试

----------------

### 质量模型 & 测试模型
- 测试怎么测？ 比如一个功能(需求)我们应该考虑哪些方面？

> 质量模型: 
- 提供测试设计不同角度视野 和 *验证方向*
- 衡量一个软件一个硬件的质量如何 应该从哪几个方面考虑 就从哪几个方面进行测试就可以了

<!-- 
  软件质量模型: 
    - 1. 功能性     - 重点
      - 验证软件的功能是否满足需求(根据需求文档里面会有要求的功能)
      - 功能的数量是对的 而且都实现了

    - 2. 性能效率     - 重点
      - 验证软件的性能是否满足需求
      - 比如要求软件能满足20000人的需求

    - 3. 兼容性     - 重点
      - 验证软件与主流硬件和软件兼容
      - 比如我们开发的app跟抖音冲突

    - 4. 易用性     - 重点
      - 便于使用 体验感

    - 5. 可靠性
      - 性能和功能应用可靠

    - 6. 信息安全性     - 重点
      - 信息在传输或者存储过程的安全程度

    - 7. 可维护性
      - 便于维护

    - 8. 可移植性
      - 具备迁移和便捷性
 -->


- 通过 上面的知识点 最起码我们应该知道 对方给我们任何需求 我们可以从上述的几点来考虑

---


> 测试模型 (开发模型)
- 在现在的企业中 开发和测试 处于什么样的环节
- 不同角色对项目开发的一种模式或者说流程 不同的角色在项目中应该做什么样的事情 每一种角色应该匹配哪个环节

> W模型
- 简称 双V 即以开发主导的一个 V 和 以测试主导的一个 V 构成

- 开发V:

    用户需求                交付

      需求分析            实施

        概要设计        集成

          详细设计    单元测试

                编码
<!-- 
  用户需求: 
    产品来处理

  需求分析: 
    跟开发一起分析

  概要设计: 
    开发要进行概要设计 应该有哪些功能和哪些模块

  详细设计: 
    每个功能里面具体应该怎么去写 应该有哪些内容 生成文档 对着文档进行编码实现
 -->


- 测试V:

      验收测试设计

        系统测试设计            验收测试

          集成测试设计        系统测试

            单元测试设计    集成测试

                    单元测试

- 根据需求文档提取需求 根据需求设计测试点 根据测试点写用例覆盖测试点


> 结论:
- 测试 和 开发 每一个环节都一一对应 也就是说 测试从产品的需求文档一旦确定以后测试就要从最开发介入 测试伴随着整个产品的开发周期

- 测试对象不仅是程序还有需求 设计文档
- 测试介入较早 及早发现问题 降低修复成本


> 问题:
- 实施起来比较复杂 难度大 对于需求阶段和设计阶段的测试设计要求较高
- 需求不熟悉对单功能就没有办法覆盖

----------------

### 测试流程 (需求分析)
- 进入企业后该怎么进行测试

> 1. 需求分析
- 确保各部门需求理解一致
- 各部分站在自己的角度上 对需求进行查漏补缺
<!-- 
  产品调研 调研后会确定需求文档 公司通过 进行立项 才会有项目组
  立项后 肯定是有完整的需求了

  项目中的角色一般会有 开发 测试 产品

  产品会给大家先讲需求 项目是干啥的 主要有哪些功能 有什么需求 
  这个环节就是需求分析评审

  可能会有的问题:
   站在测试角度对需求文档进行查漏补缺
 -->


> 2. 计划编写
- 测什么(测试目标和范围) 谁来测(人员安排) 怎么测(测试工具 测试策略) 这3点是测试计划的核心
<!-- 
  各个部分要开始写计划

  开发部门: 写研发的计划
  测试部门: 写测试的计划
 -->

- 整个的测试团队都是围绕这个计划进行的 单个人拿到他负责的需求 会写一个个人的计划(什么时候开始提取测试点 什么时候开始写用例 什么时候进行评审 什么时候进行交付 什么时候执行冒烟)

- 这个计划会跟开发一起用 因为测试计划要和开发进行同步 *这个计划公司会有现成的模版*

- 测试驱动开发


> 3. 测试用例设计
- 验证测试时执行的文档项目是否符合需求的操作文档(按照写好的东西执行就完了 这个也叫做用例)


> 4. 用例执行
- 项目模块开发完成开始执行 用例文档 实施测试
<!-- 
  当我们输入错误的密码 发现也能登录成功 这就是 缺陷
 -->


> 5. 缺陷管理
- 对缺陷进行管理的过程
- 提交 -- 修复 -- 验证 -- 关闭
<!-- 
  缺陷本身是一个闭环 比如测试发现缺陷了需要提交给开发 开发进行修复 修复完成了告知测试 测试说发版本吧 把修复的代码更新一下 更新完之后 测试会再次的验证 验证正确关闭bug

  缺陷管理使用的工具
    excel
    jira
    qq 微信都可以
 -->


> 6. 测试报告
- 实施测试结果文档 
- 测试完之后会写结果文档 比如A模块总共有多少个bug 负责人是谁 bug的分析 bug的总结 bug的描述 发现的问题是怎么解决的

----------------

### 测试用例
- 用为测试项目而设计的*执行文档* 看着我们的执行文档 去进行测试

> 什么是测试用例
- 用例:
- 用户使用的案例的简称 这些案例中我们选哪些测试 那我们可以从质量模型的角度来着手

- 比如我们要测试一款手机 比如:
- 1. 是否能开机:
  - 打开手机按下电源键3秒钟 看是否能开机

- 2. 验证内存:
  - 打开手机设置查看内存是否为64G

- 3. 验证屏幕:
  - 打开手机在白屏北京下检查屏幕是否有黑色点

- 4. 检查运行速度
  - 打开手机下载吃鸡游戏 是否运行流畅


> 测试用例的作用
- 防止漏测 实施测试的标准(操作文档 - 点点点)
- 大厂中一般不会让自己写的用例自己执行

- 一般来说 测试分为 
  执行用例(放入职的会做这个 认识中国字的都能执行)
  设计用例(业务不熟悉的人设计不了)


> 测试用例的编写格式  
- 作用: 防止漏测 和 实施测试的步骤(标准)

> 8大要素:
- 用例编号:
  - 项目 + 模块 + 编号

- 用例标题:
  - 预期结果 + 操作步骤

- 模块/项目:
  - 所属项目或模块

- 前置条件:
  - 要执行此条用例 有哪些前置操作

- 优先级: 
  - 表示用例的重要程度或者影响力p0 ~ p4 (p0最高)

- 测试步骤:
  - 描述操作步骤

- 测试数据:
  - 操作的数据 没有的话可以为空

- 预期结果:
  - 期望达到的结果


> 如何设计用例
- *不同的场景和需求 有不同的用例设计方法* 需要学习用例的设计方法
- 我们学了设计方法 根据需求往方法里面套就可以了

- 设计用例的时候是定要先覆盖业务 然后再覆盖单模块 单功能

----------------

### 目标
> 能够针对穷举场景设计测试点
> 能够针对限定边界规则设计测试点
> 能够对条件依赖关系进行设计测试点
> 能够使用对于项目业务进行设计用例

- 下面一一进行展开说明

----------------

### 等价类划分法 (取其中一个代表其他)
- 等价类划分法是用来解决穷举问题的 使用的方法就是等价类

> 等价类说明
- 在所有测试数据中 具有某种*共同特征(看分类)*的数据集合进行划分

> 等价类分类
- 有效等价类: 满足需求的数据集合
- 无效等价类: 不满足需求的数据集合
<!-- 
  说白了 只要是有效的都是一个特点 有效和无效我们只取一个 我们不用去穷举(一百个情况 要想一百种测试方案 不用)

  比如 注册的昵称为6-8位字符串

  有效: 6 7 8 位都可以注册成功
  无效: 小于6位 大于8位的时候也可以注册成功

  比如我们测试的时候 就可以 来一个4位 来一个7位 进行测试
  因为站在等价类划分 分别进行了 有效 和 无效 的情况测试

  不用再去测别的
 -->


> 等价类步骤
- 使用等价类方法的步骤

- 1. 明确需求
- 2. 确定有效和无效等价类
- 3. 提取数据编写测试用例


> 等价类的适用场景
- 需要大量数据测试输入 但是*没有办法穷举测试*的地方
- 比如:
  - 输入框
  - 下拉列表
  - 单选复选框

- 典型代表: 页面级的输入框类测试 *输入框一定会用 等价类*


> 案例:
- 需求: 验证 QQ账号 的合法性
- 要求: 6 ~ 10位自然数

- 测试人员在写用例的时候 软件是没有的 只有需求文档

- 步骤:
- 下面就是使用等价类 我们编写的测试用例 用来覆盖需求(不是真正的完整的覆盖, 完整的覆盖需要结合下一个知识点)

- 1. 明确需求:
    6 - 10位自然数

- 2. 确定有效和无效等价类
    有效          无效
    8位自然数     4位自然数
                 8位非自然数
<!-- 
  选择8位非自然数的原因: 
  在测试类型符合与否的时候 位数一定要合格 我们在验证一个点的时候 其它点必须符合条件
 -->

- 3. 提取数据编写用例(要用什么数据进行测试)
    有效           无效
    12345678      1234
                  1234567a

> 总结:
- 需求是 6 - 10位自然数
- 怎么确定有效 和 无效?  
- 我们可以根据需求 列出有效和无效的范围 然后在其中选择任何一个即可
- 有效
  - (6 7 8 9 10) 我们取其中的任何一个即可

- 无效
  - x < 6位, x > 10位 在这两个范围内取一个就可以


> 分类:
- 1. 有效等价: 所有有效数据集合 取一个即可
- 2. 无效等价: 所有无效数据集合 取一个即可

---

> 案例2
- 需求: 验证某城市电话号码正确性

- 要求:
- 1. 区号: 空 或者 三位数字
- 2. 前缀码: 非 0 且 非 1 开头的三位数字
- 3. 后缀码: 四位数字

> 需求分析:
- 参数: 区号 + 前缀 + 后缀
- 类型: 数字 或 空
- 长度: 3位, 4位
- 规则: 非0 且 非1


- 1. 明确需求
- 根据需求分析如下
<!-- 
    参数    类型      长度      规则

    区号    数字    空, 3位      -
    前缀    数字    3位         非0 且 非1
    后缀    数字    4位         -
 -->

- 2. 确定有效和无效等价类
<!-- 
    参数                  有效等价        无效等价

    区号                  1.为空 2.3位    1位(要求是3位)
    前缀      长度         3位            2位
    后缀                  4位            3位


    区号                  数字            非数字
    前缀      类型         数字            非数字
    后缀                  数字            非数字


    区号                  -             -
    前缀      规则        非0非1         0开头 或 1开头
    后缀                  -             -
 -->

> 技巧:
- 正向(正确的用例):  尽量覆盖组合
- 逆向(错误的用例):  逆向不可组合 每一条都是一个用例



- 3. 测试数据进行验证
<!-- 
  用例编号
    tel_001

  用例标题
    合格(区号为空+3位数字前缀且非0非1开头+4位数字后缀)

  项目/模块
    无

  前置条件
    无

  优先级
    p0 因为正向就是p0

  测试步骤
    1. 输入区号
    2. 输入前缀
    3. 输入后缀

  测试数据
    1. 区号: 为空
    2. 前缀: 234
    3. 后缀: 4567

  预期结果
    合格

  实际结果

---

  用例编号
    tel_002

  用例标题
    合格(区号3位数字+3位数字前缀且非0非1开头+4位数字后缀)

  项目/模块
    无

  前置条件
    无

  优先级
    p0 因为正向就是p0

  测试步骤
    1. 输入区号
    2. 输入前缀
    3. 输入后缀

  测试数据
    1. 区号: 123
    2. 前缀: 234
    3. 后缀: 4567

  预期结果
    合格

  实际结果

---

  用例编号
    tel_003

  用例标题
    不合格(区号1位数字+3位数字前缀且非0非1开头+4位数字后缀)

  项目/模块
    无

  前置条件
    无

  优先级
    p0 因为正向就是p0

  测试步骤
    1. 输入区号
    2. 输入前缀
    3. 输入后缀

  测试数据
    1. 区号: 1
    2. 前缀: 234
    3. 后缀: 4567

  预期结果
    不合格

  实际结果

---

  用例编号
    tel_004

  用例标题
    不合格(区号为空+2位数字前缀且非0非1开头+4位数字后缀)

  项目/模块
    无

  前置条件
    无

  优先级
    p0 因为正向就是p0

  测试步骤
    1. 输入区号
    2. 输入前缀
    3. 输入后缀

  测试数据
    1. 区号: 为空
    2. 前缀: 23
    3. 后缀: 4567

  预期结果
    不合格

  实际结果

---

  用例编号
    tel_005

  用例标题
    不合格(区号为空+3位数字前缀且非0非1开头+3位数字后缀)

  项目/模块
    无

  前置条件
    无

  优先级
    p0 因为正向就是p0

  测试步骤
    1. 输入区号
    2. 输入前缀
    3. 输入后缀

  测试数据
    1. 区号: 为空
    2. 前缀: 234
    3. 后缀: 456

  预期结果
    不合格

  实际结果

---

  用例编号
    tel_006

  用例标题
    不合格(区号为3非位数字+3位数字前缀且非0非1开头+4位数字后缀)

  项目/模块
    无

  前置条件
    无

  优先级
    p0 因为正向就是p0

  测试步骤
    1. 输入区号
    2. 输入前缀
    3. 输入后缀

  测试数据
    1. 区号: a12
    2. 前缀: 234
    3. 后缀: 4567

  预期结果
    不合格

  实际结果

---

  用例编号
    tel_007

  用例标题
    不合格(区号为空+3位非数字前缀且非0非1开头+4位数字后缀)

  项目/模块
    无

  前置条件
    无

  优先级
    p0 因为正向就是p0

  测试步骤
    1. 输入区号
    2. 输入前缀
    3. 输入后缀

  测试数据
    1. 区号: 为空
    2. 前缀: 23a
    3. 后缀: 4567

  预期结果
    不合格

  实际结果

---

  用例编号
    tel_008

  用例标题
    不合格(区号为空+3位数字前缀且非0非1开头+4位非数字后缀)

  项目/模块
    无

  前置条件
    无

  优先级
    p0 因为正向就是p0

  测试步骤
    1. 输入区号
    2. 输入前缀
    3. 输入后缀

  测试数据
    1. 区号: 为空
    2. 前缀: 234
    3. 后缀: 456a

  预期结果
    不合格

  实际结果

---

  用例编号
    tel_009

  用例标题
    不合格(区号为空+3位数字前缀且0非1开头+4位数字后缀)

  项目/模块
    无

  前置条件
    无

  优先级
    p0 因为正向就是p0

  测试步骤
    1. 输入区号
    2. 输入前缀
    3. 输入后缀

  测试数据
    1. 区号: 为空
    2. 前缀: 023
    3. 后缀: 4567

  预期结果
    不合格

  实际结果

---

  用例编号
    tel_010

  用例标题
    不合格(区号为空+3位数字前缀且非01开头+4位数字后缀)

  项目/模块
    无

  前置条件
    无

  优先级
    p0 因为正向就是p0

  测试步骤
    1. 输入区号
    2. 输入前缀
    3. 输入后缀

  测试数据
    1. 区号: 为空
    2. 前缀: 134
    3. 后缀: 4567

  预期结果
    不合格

  实际结果

 -->

----------------

### 边界值分析法
- 用来解决边界限制

- 需求:
- 判断输入的数据是否小于 -99 或者大于 99, 如果 小于 -99 或 大于 99 给出错误提示

- -99 ~ 99 之间是正常范围 两侧的时候需要给出错误提示

- 后台代码:
```python
if a >= -99 or a <= 99:
    print("输入的参数值必须大于-99同时小于99")

if b >= -99 or b <= 99:
    print("输入的参数值必须大于-99同时小于99")
```

- 上面不应该加上 "=" 所以出错


**提示:**
- 输入的数据包含99或者-99的时候
- 边界条件设置出错: 代码中 将 ">" 写成了 ">=", 将 "<" 写成了 "<="


- 当出现 >= 类似的场景下 我们需要测边界值 边界值需要测哪些呢？

> 边界值分析法:
> 1. 边界范围节点
- 选取 *正好等于*, *刚好大于*, *刚好小于* 边界的值 作为测试数据
  - 上点: 边界上的点(正好等于)
  - 离点: 距离上点最近的点(刚好大于 刚好小于)
  - 内点: 范围内的点(区间范围内的数据)

<!--    
            -99              99
      ----x--o--x----0----x--o--x----

        -100   -98   0    98   100


      o: 就是上点 也就是边界  2个o
      x: 就是离点 离边界最近的点  4个x
      0: 就是内点 范围内的点
 -->


> 总结: 
- 有关边界值 不管几条用例 
  最多7条 因为一共7个点
  最少5条


> 2. 应用设计步骤
- 1. 明确需求
- 2. 确定有效和无效等价类
<!-- 
  疑问:
    上面的图 不是覆盖了有效等价 和 无效等价了么？
    那可以不用再次确定有效和无效等价类了么？

  不能:
    因为边界值只能覆盖位数(长度) 无法覆盖非数字 不是数字的情况是解决不了的
    边界值只能覆盖数字 类型(a b | *)只能由等价类覆盖

  总结:
    等价类和边界值通常都是配合使用的
 -->

- 3. 确定边界范围值
- 4. 提取数据编写测试用例


> 3. 案例
- 需求:
- 通过边界值法验证标题长度的合法性

- 要求:
- 标题长度大于0 小于等于30个字符

- 接下来我们按照步骤来下
- 1. 明确需求:
  - 标题长度大于0 小于等于30个字符
  - str.length > 0 && str.length <= 30


- 2. 确定有效等价和无效等价
  - 有效:
    > 0, <= 30

  - 无效:
    = 0, > 30

- 3. 确定边界范围值:
  - -1 0 1 ---- 29 30 31
  - 有效需要测: 1 29 30 单位: 字符
  - 无效需要测: 0 31 单位: 字符
<!-- 
  (-1不用测 字符咋能输出来个-1)
 -->

- 有效需要测的 和 无效需要测的 一共5个用例

- 4. 编写用例:
<!-- 
  用例编号: title_001
  用例标题: 合格(1个字符)
  项目/模块: 标题
  前置条件: 打开工具
  优先级: p0
  测试步骤: 输入数据 点击验证
  测试数据: a
  预期结果: 合格
  实际结果:

  用例编号: title_002
  用例标题: 合格(29个字符)
  项目/模块: 标题
  前置条件: 打开工具
  优先级: p0
  测试步骤: 输入数据 点击验证
  测试数据: 29个a
  预期结果: 合格
  实际结果:

  用例编号: title_003
  用例标题: 合格(30个字符)
  项目/模块: 标题
  前置条件: 打开工具
  优先级: p0
  测试步骤: 输入数据 点击验证
  测试数据: 30个b
  预期结果: 合格
  实际结果:

  用例编号: title_004
  用例标题: 不合格(0个字符 为空)
  项目/模块: 标题
  前置条件: 打开工具
  优先级: p1
  测试步骤: 输入数据 点击验证
  测试数据: 空
  预期结果: 合格
  实际结果:

  用例编号: title_005
  用例标题: 不合格(31个字符)
  项目/模块: 标题
  前置条件: 打开工具
  优先级: p1
  测试步骤: 输入数据 点击验证
  测试数据: 31个c
  预期结果: 合格
  实际结果:
 -->

---

- 我们再看看上面的案例
- 需求:
- 通过边界值法验证QQ号码的合法性

- 要求:
- 6 ~ 10 位自然数

- 1. 确定边界值:
- 5 6 7 ---8--- 9 10 11

- 2. 确定有效和无效等价类
- 有效:
  6 7 8 9 10

- 无效:
  5 11 非自然数

- 这样有效和无效的测试用例加起来需要 8 条

> 上面的用例优化
- 我们会发现 当我们测试有效用例的时候 会覆盖
  6位自然数 
  7位自然数 
  8位自然数 
  9位自然数 
  10位自然数 

- 这样会比较冗余, 下面我们讲讲怎么针对类似的场景进行优化
- 上面我们说过 凡是涉及到边界的一定是7条用例

- 可以优化成5个点
**优化要求**
- 1. 上点必选 2个
- 2. 内点必选 1个
- 3. 离点要求 开内闭外
(
  考虑开闭区间 
  *开*区间选择*内部离点* 
  *闭*区间选择*外部离点*
)
<!-- 
  - 理解: 带=的一侧带有 ] (包含)
    开区间: 
      10 < a <= 20  -> (10, 20] 

    开区间是 不包含  ()
    闭区间是 包含  []
 -->

- 现在我们测的是 6 - 10 写成开闭区间就是 [6, 10]
- 闭区间的话 我们会选择外部离点 也就是 5 和 11


> 4. 应用场景
- 1. 在等价类的基础上针对边界范围的测试数据输入的地方(重点关注边界)
- 2. 常见词语描述: 大小 尺寸 重量 最大 最小 至多 至少等修饰词语
- 3. 典型代表: 有边界范围的输入框类测试

----------------

### 判定表法
- 解决多条件依赖 

----------------

### 场景法
- 解决业务问题

----------------

### 错误推测法

----------------

### 案例
