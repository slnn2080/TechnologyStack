### 测试概念

> 功能测试 (手工测试):
- 针对程序的功能来进行验证(手动) 保证软件的功能正常的实现

- 在测试的过程中 我们不仅要验证正向功能测试(正向也是我们首先要覆盖的) 还要考虑其他的场景
- 1. 正常的功能是否完成
- 2. 当出现错误的时候应该怎么样


> 自动化测试
- 使用代码或者工具代替人工验证项目功能


> 接口测试
- 针对模块与模块或系统与系统之间数据请求地址进行测试


> 性能测试
- 模拟多人使用软件 查找服务器缺陷
- 性能测试是关注我们的程序能多少人使用

----------------

### 常见的测试分类

> 按测试阶段划分
- 按照 软件开发 从无到有 分的阶段

- 1. 单元测试 (白盒测试)
- 针对程序 *源代码* 进行测试 开发边写代码边进行单元测试 按照程序一个一个功能来作为单元进行测试

- 单元测试一般都是开发在做
<!-- 
  我们写了20行代码 然后我们将程序运行起来 20行代码执行是不是按照我们的意愿 能不能覆盖

  比如条件成立要执行 第五行代码 条件不成立应该执行 第七行代码 我们要验证代码是否按照我们的逻辑去执行

  比如阶段性的测自己写的代码发现bug很容易 不是说整个项目都写完了2万行代码再测试找bug就很难了

  当测试发现bug之后提交给开发 开发处理bug 开发的修复率会很低和很慢 这个时候就会要求下一个模块进行的时候必须做单测
 -->

---

- 2. 集成测试 (接口测试)
- 针对 模块 之间访问地址进行测试
- 单元测试是按照功能块来分别测试 集成测试就是将几个功能组合起来来进行测试
- 也就是说针对功能与功能之间的互相调用来进行测试
<!-- 
  软件里面任何功能都有业务关系 比如订单和库存 库存和订单都是单独的模块 比如下订单要检测库存里面有没有数量 

  集成测试现在说的就是接口测试 这个部分是最简单的
 -->

---

- 3. 系统测试
- 对整个系统全面进行测试包括 功能 *兼容* 文档 等测试
- 就是针对集成测试进行测试(针对几个功能集合一起测试性能)

---

- 4. 验收测试
- 主要分内测 公测 使用不同人群来挖掘项目缺陷
- 性能测试(系统测试)完毕后 验收测试主要是针对指定的项目类型
<!-- 
  比如游戏当中的 公测 和 内测 公测和内测就是验收
  内测: 阿尔法测试  α 
  公测: 贝塔测试    β

  这些字母代表要测试的顺序
 -->

---


> 按代码可见度划分
- 1. 黑盒测试 (系统测试)
- 看不见源代码 主要针对程序 *功能* 进行测试

- 2. 灰盒测试 (集成测试)
- 看见部分代码 主要针对程序 *接口* 进行测试

- 3. 白盒测试 (单元测试)
- 看见全部代码 主要针对程序 *源代码* 进行测试


> 自动化测试归属什么测试?
- 理论上说黑盒测试, 实际中属于功能测试 因为自动化测试*只针对程序的功能*

> 总结:
- 1. 系统测试 和 黑盒测试 重点核心是 功能测试
- 2. 集成测试 和 灰盒测试 又称 接口测试
- 3. 单元测试 和 白盒测试 是对 代码 进行测试
- 4. 自动化测试 归属于 功能测试
- 5. 性能测试 安全测试 归属于 专项测试

---


> 测试策略
- 指的是做某个测试之前采用的一种方法
- 我们这里介绍一个 *冒烟测试*

<!-- 
  举例:
    本月20号 开发要交付给测试4个模块 给测试3天时间 要把这几个模块测试完毕 

    4个模块要投入6个人 测试验证的时候发现 主功能都跑不通 登录都登录不进去 依赖登录以后要验证的点都需要等着开发修复

    开发修复 修复了2天 3天后项目经理说要交付完成 
    找开发 开发会说找测试 测试还没测完呢
    找测试 测试会说找开发 开发修复还没修复完呢

  这样就会耽误工期 开发不写bug 测试能耽误工期么
 -->

> 冒烟测试:
- 大规模执行测试之前 针对程序的主功能进行验证 保证程序具备可测性

- 上述的情况下最好的解决方案就是冒烟测试
- *冒烟就是跑模块的主功能*确保可以进入到正常的测试环节

<!-- 
  交付上来的4个模块我们要先试用一下 如果没具备可测性(主功能都跑不通) 那开发晚上加班自己搞定
 -->

> 面试题:
- 提测标准是什么?  -- 冒烟测试通过
- 测试之前要怎么做?  -- 进行冒烟测试

----------------

### 质量模型 & 测试模型
- 测试怎么测？ 比如一个功能(需求)我们应该考虑哪些方面？

> 质量模型: 
- 提供测试设计不同角度视野 和 *验证方向*
- 衡量一个软件一个硬件的质量如何 应该从哪几个方面考虑 就从哪几个方面进行测试就可以了

<!-- 
  软件质量模型: 
    - 1. 功能性     - 重点
      - 验证软件的功能是否满足需求(根据需求文档里面会有要求的功能)
      - 功能的数量是对的 而且都实现了

    - 2. 性能效率     - 重点
      - 验证软件的性能是否满足需求
      - 比如要求软件能满足20000人的需求

    - 3. 兼容性     - 重点
      - 验证软件与主流硬件和软件兼容
      - 比如我们开发的app跟抖音冲突

    - 4. 易用性     - 重点
      - 便于使用 体验感

    - 5. 可靠性
      - 性能和功能应用可靠

    - 6. 信息安全性     - 重点
      - 信息在传输或者存储过程的安全程度

    - 7. 可维护性
      - 便于维护

    - 8. 可移植性
      - 具备迁移和便捷性
 -->


- 通过 上面的知识点 最起码我们应该知道 对方给我们任何需求 我们可以从上述的几点来考虑

---


> 测试模型 (开发模型)
- 在现在的企业中 开发和测试 处于什么样的环节
- 不同角色对项目开发的一种模式或者说流程 不同的角色在项目中应该做什么样的事情 每一种角色应该匹配哪个环节

> W模型
- 简称 双V 即以开发主导的一个 V 和 以测试主导的一个 V 构成

- 开发V:

    用户需求                交付

      需求分析            实施

        概要设计        集成

          详细设计    单元测试

                编码
<!-- 
  用户需求: 
    产品来处理

  需求分析: 
    跟开发一起分析

  概要设计: 
    开发要进行概要设计 应该有哪些功能和哪些模块

  详细设计: 
    每个功能里面具体应该怎么去写 应该有哪些内容 生成文档 对着文档进行编码实现
 -->


- 测试V:

      验收测试设计

        系统测试设计            验收测试

          集成测试设计        系统测试

            单元测试设计    集成测试

                    单元测试

- 根据需求文档提取需求 根据需求设计测试点 根据测试点写用例覆盖测试点


> 结论:
- 测试 和 开发 每一个环节都一一对应 也就是说 测试从产品的需求文档一旦确定以后测试就要从最开发介入 测试伴随着整个产品的开发周期

- 测试对象不仅是程序还有需求 设计文档
- 测试介入较早 及早发现问题 降低修复成本


> 问题:
- 实施起来比较复杂 难度大 对于需求阶段和设计阶段的测试设计要求较高
- 需求不熟悉对单功能就没有办法覆盖

----------------

### 测试流程 (需求分析)
- 进入企业后该怎么进行测试

> 1. 需求分析
- 确保各部门需求理解一致
- 各部分站在自己的角度上 对需求进行查漏补缺
<!-- 
  产品调研 调研后会确定需求文档 公司通过 进行立项 才会有项目组
  立项后 肯定是有完整的需求了

  项目中的角色一般会有 开发 测试 产品

  产品会给大家先讲需求 项目是干啥的 主要有哪些功能 有什么需求 
  这个环节就是需求分析评审

  可能会有的问题:
   站在测试角度对需求文档进行查漏补缺
 -->


> 2. 计划编写
- 测什么(测试目标和范围) 谁来测(人员安排) 怎么测(测试工具 测试策略) 这3点是测试计划的核心
<!-- 
  各个部分要开始写计划

  开发部门: 写研发的计划
  测试部门: 写测试的计划
 -->

- 整个的测试团队都是围绕这个计划进行的 单个人拿到他负责的需求 会写一个个人的计划(什么时候开始提取测试点 什么时候开始写用例 什么时候进行评审 什么时候进行交付 什么时候执行冒烟)

- 这个计划会跟开发一起用 因为测试计划要和开发进行同步 *这个计划公司会有现成的模版*

- 测试驱动开发


> 3. 测试用例设计
- 验证测试时执行的文档项目是否符合需求的操作文档(按照写好的东西执行就完了 这个也叫做用例)


> 4. 用例执行
- 项目模块开发完成开始执行 用例文档 实施测试
<!-- 
  当我们输入错误的密码 发现也能登录成功 这就是 缺陷
 -->


> 5. 缺陷管理
- 对缺陷进行管理的过程
- 提交 -- 修复 -- 验证 -- 关闭
<!-- 
  缺陷本身是一个闭环 比如测试发现缺陷了需要提交给开发 开发进行修复 修复完成了告知测试 测试说发版本吧 把修复的代码更新一下 更新完之后 测试会再次的验证 验证正确关闭bug

  缺陷管理使用的工具
    excel
    jira
    qq 微信都可以
 -->


> 6. 测试报告
- 实施测试结果文档 
- 测试完之后会写结果文档 比如A模块总共有多少个bug 负责人是谁 bug的分析 bug的总结 bug的描述 发现的问题是怎么解决的

----------------

### 测试用例
- 用为测试项目而设计的*执行文档* 看着我们的执行文档 去进行测试

> 什么是测试用例
- 用例:
- 用户使用的案例的简称 这些案例中我们选哪些测试 那我们可以从质量模型的角度来着手

- 比如我们要测试一款手机 比如:
- 1. 是否能开机:
  - 打开手机按下电源键3秒钟 看是否能开机

- 2. 验证内存:
  - 打开手机设置查看内存是否为64G

- 3. 验证屏幕:
  - 打开手机在白屏北京下检查屏幕是否有黑色点

- 4. 检查运行速度
  - 打开手机下载吃鸡游戏 是否运行流畅


> 测试用例的作用
- 防止漏测 实施测试的标准(操作文档 - 点点点)
- 大厂中一般不会让自己写的用例自己执行

- 一般来说 测试分为 
  执行用例(放入职的会做这个 认识中国字的都能执行)
  设计用例(业务不熟悉的人设计不了)


> 测试用例的编写格式  
- 作用: 防止漏测 和 实施测试的步骤(标准)

> 8大要素:
- 用例编号:
  - 项目 + 模块 + 编号

- 用例标题:
  - 预期结果 + 操作步骤

- 模块/项目:
  - 所属项目或模块

- 前置条件:
  - 要执行此条用例 有哪些前置操作

- 优先级: 
  - 表示用例的重要程度或者影响力p0 ~ p4 (p0最高)

- 测试步骤:
  - 描述操作步骤

- 测试数据:
  - 操作的数据 没有的话可以为空

- 预期结果:
  - 期望达到的结果


> 如何设计用例
- *不同的场景和需求 有不同的用例设计方法* 需要学习用例的设计方法
- 我们学了设计方法 根据需求往方法里面套就可以了

- 设计用例的时候是定要先覆盖业务 然后再覆盖单模块 单功能

----------------

### 目标
> 能够针对穷举场景设计测试点
> 能够针对限定边界规则设计测试点
> 能够对条件依赖关系进行设计测试点
> 能够使用对于项目业务进行设计用例

- 下面一一进行展开说明

----------------

### 等价类划分法 (qq验证)
- 等价类划分法是用来解决穷举问题的 使用的方法就是等价类

> 等价类说明
- 在所有测试数据中 具有某种*共同特征(看分类)*的数据集合进行划分

> 等价类分类
- 有效等价类: 满足需求的数据集合
- 无效等价类: 不满足需求的数据集合
<!-- 
  说白了 只要是有效的都是一个特点 有效和无效我们只取一个 我们不用去穷举(一百个情况 要想一百种测试方案 不用)

  比如 注册的昵称为6-8位字符串

  有效: 6 7 8 位都可以注册成功
  无效: 小于6位 大于8位的时候也可以注册成功

  比如我们测试的时候 就可以 来一个4位 来一个7位 进行测试
  因为站在等价类划分 分别进行了 有效 和 无效 的情况测试

  不用再去测别的
 -->


> 等价类步骤
- 使用等价类方法的步骤

- 1. 明确需求
- 2. 确定有效和无效等价类
- 3. 提取数据编写测试用例


> 案例:
- 需求: 验证 QQ账号 的合法性
- 要求: 6 ~ 10位自然数

- 测试人员在写用例的时候 软件是没有的 只有需求文档

- 步骤:
- 下面就是使用等价类 我们编写的测试用例 用来覆盖需求(不是真正的完整的覆盖, 完整的覆盖需要结合下一个知识点)

- 1. 明确需求:
    6 - 10位自然数

- 2. 确定有效和无效等价类
    有效          无效
    8位自然数     4位自然数
                 8位非自然数
<!-- 
  选择8位非自然数的原因: 
  在测试类型符合与否的时候 位数一定要合格 我们在验证一个点的时候 其它点必须符合条件
 -->

- 3. 提取数据编写用例(要用什么数据进行测试)
    有效           无效
    12345678      1234
                  1234567a


----------------

### 边界值分析法
- 用来解决边界限制

----------------

### 判定表法
- 解决多条件依赖 

----------------

### 场景法
- 解决业务问题

----------------

### 错误推测法

----------------

### 案例
