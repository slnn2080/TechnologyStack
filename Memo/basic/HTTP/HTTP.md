### HTTP
- Web 浏览器、服务器和相关的Web 应用程序都是通过HTTP 相互通信的

- HTTP的特点
- HTTP 使用的是可靠的数据传输协议，因此即使数据来自地球的另一端，它也能够确保数据在传输的过程中不会被损坏或产生混乱


### Web客户端和服务器
- Web 内容都是存储在Web 服务器上的。Web 服务器所使用的是HTTP 协议，因此经常会被称为HTTP 服务器。

- HTTP客户端发送http请求 HTTP服务端会在http响应中会送所请求的数据
<!-- 
  最常见的客户端就是Web 浏览器
 -->

> 资源
- 最简单的Web 资源就是Web 服务器文件系统中的静态文件。这些文件可以包含任意内容

- 但资源不一定非得是静态文件。资源还可以是根据需要生成内容的软件程序。


> 媒体类型
- 因特网上有数千种不同的数据类型，HTTP 仔细地给每种要通过Web 传输的对象都打上了名为MIME 类型（MIME type） 的数据格式标签。


> MIME 类型
- MIME 类型是一种文本标记，表示一种*主要的对象类型和一个特定的子类型*，中间由一条斜杠来分隔。

- HTML 格式的文本文档由 
    text/html

- 普通的 ASCII 文本文档由
    text/plain

- JPEG 格式的图片为 
    image/jpeg

- GIF 格式的图片为 
    image/gif

- Apple 的 QuickTime 电影为 
    video/quicktime

- 微软的 PowerPoint 演示文件为 
    application/vnd.ms-powerpoint


> URI(统一资源标识符)
- 每个Web 服务器资源都有一个名字，这样客户端就可以说明它们感兴趣的资源是什么了。

- URI 就像因特网上的邮政地址一样，在世界范围内唯一标识并定位信息资源。
<!-- 
  http://www.joes-hardware.com/specials/saw-blade.gif
  访问Joe 商店服务器上的图片资源的
 -->

- URI 有两种形式
- 1. URL
- 2. URN


> URL(统一资源定位符)
- 是资源标识符最常见的形式
- URL 描述了一台特定服务器上某资源的特定位置。
- 是浏览器寻找信息时所需的资源位置。通过URL，人类和应用程序才能找到、使用并共享因特网上大量的数据资源。
<!-- 
  http://www.joes-hardware.com/specials/saw-blade.gif

  http://   
      使用http协议

  www.joes-hardware.com
      主机名

  /specials/saw-blade.gif
      获取名为 xx 的资源
 -->

- 大部分URL 都遵循一种标准格式，这种格式包含三个部分。
> 方案 + 服务器地址 + 某个资源
<!-- 
  URL 的第一部分被称为方案（scheme），说明了访问资源所使用的协议类型。这部分通常就是HTTP 协议（http://）。
 -->

> URN(统一资源名)
- URN 是作为特定内容的唯一名称使用的，与目前的资源所在地无关
- 使用这些与位置无关的URN，就可以将资源四处搬移。


> 事务
- 一个HTTP 事务由一条（从客户端发往服务器的）请求命令和一个（从服务器发回客户端的）响应结果组成。
- 这种通信是通过名为HTTP 报文


> 方法
- HTTP 支持几种不同的请求命令，这些命令被称为HTTP 方法
- 每条HTTP 请求报文都包含一个方法这个方法会告诉服务器要执行什么动作（获取一个Web 页面、运行一个网关程序、删除一个文件等）
<!--  
  GET     从服务器向客户端发送命名资源
  PUT     将来自客户端的数据存储到一个命名的服务器资源中去
  DELETE  从服务器中删除命名资源
  POST    将客户端数据发送到一个服务器网关应用程序
  HEAD    仅发送命名资源响应中的HTTP 首部
 -->


> 状态码
- 每条HTTP 响应报文返回时都会携带一个状态码。状态码是一个三位数字的代码，告知客户端请求是否成功，或者是否需要采取其他动作
<!--    
  200 OK。文档正确返回
  302 Redirect（重定向）。到其他地方去获取资源
  404 Not Found（没找到）。无法找到这个资源
 -->


> 报文
- HTTP 报文是由一行一行的简单字符串组成的。HTTP 报文都是纯文本，不是二进制代码，所以人们可以很方便地对其进行读写
<!-- 
  // 请求报文
  GET /test HTTP/1.0
  Accept: text/*
  Accept-Language: en, fr

  // 响应报文
  HTTP/1.0 200 ok
  Content-type: text/plain
  Content-length: 19

  hi i am a message!
 -->

- HTTP 报文包括以下三个部分。
- 1. 起始行
    报文的第一行就是起始行，
    在请求报文中用来说明要做些什么，
    在响应报文中说明出现了什么情况。

- 2. 首部字段
    起始行后面有零个或多个首部字段。
    每个首部字段都包含一个名字和一个值，
    为了便于解析，两者之间用冒号（:）来分隔。
    首部以一个空行结束。添加一个首部字段和添加新行一样简单。

- 3. 主体
    空行之后就是可选的报文主体了，其中包含了所有类型的数据
    请求主体中包括了要发送给Web 服务器的数据

    响应主体中装载了要返回给客户端的数据。


> 响应报文中的首部字段
> Content-Length
- 响应主体的长度

> Content-Type
- 文档的MIME 类型。


> TCP/IP
- HTTP 是个应用层协议。HTTP 无需操心网络通信的具体细节；它把联网的细节都交给了通用、可靠的因特网传输协议TCP/IP。
<!-- 
  因特网自身就是基于TCP/IP 的，TCP/IP 是全世界的计算机和网络设备常用的层次化分组交换网络协议集。
  
  TCP/IP 隐藏了各种网络和硬件的特点及弱点，使各种类型的计算机和网络都能够进行可靠地通信。
 -->

- TCP 提供了：
- 1. 无差错的数据传输；
- 2. 按序传输（数据总是会按照发送的顺序到达）；
- 3. 未分段的数据流（可以在任意时刻以任意尺寸将数据发送出去）

- TCP协议的特点
- 只要建立了TCP 连接，客户端和服务器之间的报文交换就不会丢失、不会被破坏，也不会在接收时出现错序了。

<!-- 
  HTTP    应用层
  TCP     传输层
  IP      网络层
  链路    链路层
  硬件    物理层
 -->


> 　连接、IP地址及端口号
- 在HTTP 客户端向服务器发送报文之前，需要用网际协议（Internet Protocol，IP）地址和端口号在客户端和服务器之间建立一条TCP/IP 连接。

- 建立一条TCP 连接的过程:
- 1. 需要知道服务器的IP 地址
- 2. 与服务器上运行的特定软件相关的TCP 端口号。

- 怎么获得HTTP 服务器的IP 地址和端口号呢？
- 通过URL!
<!-- 
  http://207.200.83.29:80/index.html
  http://www.netscape.com:80/index.html

  第一个URL 使用了机器的IP 地址，207.200.83.29 以及端口号80。

  第二个URL 没有使用数字形式的IP 地址，它使用的是文本形式的域名，或者称为
  主机名（www.netscape.com）。

  主机名就是IP 地址比较人性化的别称。

  默认端口号是80
 -->

<!-- 
  (a) 浏览器从URL 中解析出服务器的主机名；
  (b) 浏览器将服务器的主机名转换成服务器的IP 地址；
  (c) 浏览器将端口号（如果有的话）从URL 中解析出来；
  (d) 浏览器建立一条与Web 服务器的TCP 连接；
  (e) 浏览器向服务器发送一条HTTP 请求报文；
  (f) 服务器向浏览器回送一条HTTP 响应报文；
  (g) 关闭连接，浏览器显示文档。
 -->


> 代理
- 位于客户端和服务器之间的HTTP 中间实体。
- 这是Web 安全、应用集成以及性能优化的重要组成模块。
- 代理位于客户端和服务器之间，接收所有客户端的HTTP 请求，并
将这些请求转发给服务器(可能会对请求进行修改之后转发)

- 代理还可以对请求和响应进行过滤
<!-- 
  比如，在企业中对下载的应用程序进行病毒检测，或者对小学生屏蔽一些成人才能看的内容。
 -->


> 缓存
- HTTP 的仓库，使常用页面的副本可以保存在离客户端更近的地方。
- Web 缓存（Web cache）或代理缓存（proxy cache）是一种特殊的HTTP 代理服务器
<!-- 
  也就是说缓存也是服务器？
  可以将经过代理传送的常用文档复制保存起来
  下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了
 -->


> 网关
- 连接其他应用程序的特殊Web 服务器。
- 通常用于将HTTP 流量*转换成其他的协议*

- 网关接受请求时就好像自己是资源的源端服务器一样。客户端可能并不知道自己正在与一个网关进行通信。


> 隧道
- 对HTTP 通信报文进行盲转发的特殊代理。
- 建立起来之后，就会在两条连接之间对原始数据进行盲转发的HTTP 应用程序

- HTTP 隧道通常用来在一条或多条HTTP 连接上转发非HTTP 数据，转发时不会窥探数据。


> Agent代理
- 发起自动HTTP 请求的半智能Web 客户端。
- 用户Agent 代理 是代表用户发起HTTP 请求的客户端程序
<!-- 
  所有发布Web 请求的应用程序都是HTTP Agent 代理。
  到目前为止，我们只提到过一种HTTP Agent 代理：Web 浏览器，
 -->

-------------------------

### URL语法
- 大多数URL 方案的URL 语法都建立在这个由9 部分构成的通用格式上：

- <scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>
<!-- 
  几乎没有哪个URL 中包含了所有这些组件。
  URL 最重要的3 个部分是方案（scheme）、主机（host）和路径（path）。
 -->

- <scheme> 方案
  - 访问服务器以获取资源时要使用哪种协议

- <user> 用户
  - 某些方案访问资源时需要的用户名

- <password> 密码
  - 用户名后面可能要包含的密码，中间由冒号（:）分隔

- <host> 主机
  - 资源宿主服务器的主机名或点分IP 地址

- <port> 端口
  - 资源宿主服务器正在监听的端口号。很多方案都有默认端口号（HTTP 的默认端口号为80）

- <path> 路径
  - 服务器上资源的本地名，由一个斜杠（/）将其与前面的URL 组件分隔开来

- <params> 参数
  - 某些方案会用这个组件来指定输入参数。参数为名/ 值对。URL 中可以包含多个参数字段，它们相互之间以及与路径的其余部分之间用分号（;）分隔

- <query> 查询
  - 查询组件的内容没有通用格式。用字符“?”将其与URL 的其余部分分隔开来

- <frag> 片段
  - 一小片或一部分资源的名字。引用对象时，不会将frag 字段传送给服务器；这个字段是在客户端内部使用的。通过字符“#”将其与URL 的其余部分分隔开来


> 方案
- 方案实际上是规定如何访问指定资源的主要标识符，它会告诉负责解析URL 的应用程序应该使用什么协议

- 方案组件必须以一个字母符号开始，由第一个“:”符号将其与URL 的其余部分分隔开来。方案名是大小写无关的


> 主机与端口
- 要想在因特网上找到资源，应用程序要知道是哪台机器装载了资源，以及在那台机器的什么地方可以找到能对目标资源进行访问的服务器。URL 的主机和端口组件提供了这两组信息。


> 用户名和密码
- 很多服务器都要求输入用户名和密码才会允许用户访问数据
<!-- 
  ftp://ftp.prep.ai.mit.edu/pub/gnu
  ftp://anonymous@ftp.prep.ai.mit.edu/pub/gnu
  ftp://anonymous:my_passwd@ftp.prep.ai.mit.edu/pub/gnu
  http://joe:joespasswd@www.joes-hardware.com/sales_info.txt
 -->


> 编码机制
- 为了避开安全字符集表示法带来的限制，人们设计了一种编码机制，用来在URL 中表示各种不安全的字符。

- 这种编码机制就是通过一种“转义”表示法来表示不安全字符的，这种转义表示法包含一个百分号（%），后面跟着两个表示字符ASCII 码的十六进制数。


-------------------------

### 报文
- 如果说HTTP 是因特网的信使，那么HTTP 报文就是它用来搬东西的包裹了

- HTTP 报文是在HTTP 应用程序之间发送的数据块
- HTTP 使用术语流入（inbound）和流出（outbound）来描述事务处理（transaction）的方向

- 流入 指 客户端发送请求
- 流出 指 服务端返回响应

- HTTP 报文会像河水一样流动。不管是请求报文还是响应报文，所有报文都会向下游（downstream） 流动（ 参见图3-2）。所有报文的发送者都在接收者的上游（upstream）


> 报文的组成部分
- 。每条报文都包含一条来自客户端的请求，或者一条来自服务器的响应。它们由三个部分组成：

- 1. 对报文进行描述的起始行
- 2. 包含属性的首部（header）块
- 3. 包含数据的主体（body）部分。


> 请求报文的格式：
  <method> <request-URL> <version>
  <headers>
  <entity-body>

- 方法（method）
- 客户端希望服务器对资源执行的动作。

- 请求URL
- 命名了所请求资源，或者URL 路径组件的完整URL。

- 版本
- 报文所使用的HTTP 版本，其格式看起来是这样的
<!-- 
  HTTP/<major>.<minor>
 -->

- 状态码
- 这三位数字描述了请求过程中所发生的情况

- 原因短语
- 数字状态码的可读版本，包含行终止序列之前的所有文本。

- 首部
- 可以有零个或多个首部，每个首部都包含一个名字，后面跟着一个冒号（:），然后是一个可选的空格，接着是一个值，最后是一个CRLF。
- 首部是由一个空行（CRLF）结束的，表示了首部列表的结束和实体主体部分的开始。

- 实体的主体部分
- 实体的主体部分包含一个由任意数据组成的数据块。并不是所有的报文都包含实体的主体部分，有时，报文只是以一个CRLF 结束。


> 响应报文的格式（注意，只有起始行的语法有所不同）：
  <version> <status> <reason-phrase>
  <headers>
  <entity-body>


> 常用的http方法
  GET     从服务器获取一份文档否
  HEAD    只从服务器获取文档的首部否
  POST    向服务器发送需要处理的数据是
  PUT     将请求的主体部分存储在服务器上是
  TRACE   对可能经过代理服务器传送到服务器上去的报文进行追踪否
  OPTIONS 决定可以在服务器上执行哪些方法否
  DELETE  从服务器上删除一份文档否

> 安全方法
- HTTP 定义了一组被称为安全方法的方法。GET 方法和HEAD 方法都被认为是安全的，这就意味着使用GET 或HEAD 方法的HTTP 请求都不会产生什么动作。

- 不产生动作，在这里意味着HTTP 请求不会在服务器上产生什么结果。


> GET
- 通常用于请求服务器发送某个资源


> HEAD
- HEAD 方法与GET 方法的行为很类似，但服务器在响应中只返回首部。不会返回实体的主体部分

- 这就允许客户端在未获取实际资源的情况下，对资源的首部进行检
查。使用HEAD，
<!-- 
  在不获取资源的情• 况下了解资源的情况（比如，判断其类型）；
  通过查看响应中的状态码，看看某个对象是否存在；
  通过查看首部，测试资源是否被修改了。
 -->


> PUT
- 与GET 从服务器读取文档相反，PUT 方法会向服务器写入文档。
- PUT 方法的语义就是让服务器用请求的主体部分来创建一个由所请求的URL 命名的新文档，或者，如果那个URL 已经存在的话，就用这个主体来替代它。

- 因为PUT 允许用户对内容进行修改，所以很多Web 服务器都要求在执行PUT 之前，用密码登录。


> POST
- POST 方法起初是用来向服务器输入数据的 通常会用它来支持HTML
的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到它要去的地方


> TRACE
- 客户端发起一个请求时，这个请求可能要穿过防火墙、代理、网关或其他一些应用程序。每个中间节点都可能会修改原始的HTTP 请求。
- TRACE 方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子。TRACE 请求会在目的服务器端发起一个“环回”诊断。行程最后一站的服务器会弹回一条TRACE 响应，并在响应主体中携带它收到的原始请求报文。
- 这样客户端就可以查看在所有中间HTTP 应用程序组成的请求/ 响应链上，原始报文是否，以及如何被毁坏或修改过


> OPTIONS
- OPTIONS 方法请求Web 服务器告知其支持的各种功能。


> DELETE
- DELETE 方法所做的事情就是请服务器删除请求URL 所指定的资源。但是，客户端应用程序无法保证删除操作一定会被执行。

---------------

> 状态码分类
  100 ～ 199 100 ～ 101 信息提示
  200 ～ 299 200 ～ 206 成功
  300 ～ 399 300 ～ 305 重定向
  400 ～ 499 400 ～ 415 客户端错误
  500 ～ 599 500 ～ 505 服务器错误


> 首部
- HTTP 首部字段向请求和响应报文中添加了一些附加信息。本质上来说，它们只是一些名/ 值对的列表。

- 分类
- 通用首部:
    既可以出现在请求报文中，也可以出现在响应报文中。

- 请求首部
    提供更多有关请求的信息。

- 响应首部
    提供更多有关响应的信息。

- 实体首部
    描述主体的长度和内容，或者资源自身。

- 扩展首部
    规范中没有定义的新首部。