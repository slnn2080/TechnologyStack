### Http协议
- 协议是指双方或多方相互约定 大家都需要遵守的规则叫协议

- http协议
- 就是指客户端和服务器之间通信时 发送的数据 需要遵守的规则叫做http协议

- http协议中发送的数据又叫做报文


### 请求的 http协议格式
- 客户端 给 服务器 发送数据叫请求
- 服务器 给 客户端 回传数据叫响应

- 上述的过程都需要遵守协议


> 请求:
- 请求分为 get请求 和 post请求

> get请求的http协议格式
- get请求的http协议格式分为两个部分:
- 1. 请求行:
  - 请求行分为3个部分:
  - 1. 请求的方式: get
  - 2. /请求资源路径?请求参数#片段
  - 3. 请求的协议和版本号: HTTP/1.1


- 2. 请求头
  - 请求头是由 
    key: value 
    组成 不同键值对表示不同的含义

- 下面的内容就是 get请求的 http 协议内容:
```js
// 请求行部分
GET /project/ HTTP/1.1

// 请求头部分
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/;q=0.8,application/signed-exchange;v=b3;q=0.9

Accept-Language: zh-CN,zh;q=0.9

User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.83 Safari/537.36

Accept-Encoding: gzip, deflate, br

Host: localhost:8080

Connection: keep-alive

Cache-Control: max-age=0
sec-ch-ua: " Not A;Brand";v="99", "Chromium";v="99", "Google Chrome";v="99"
sec-ch-ua-mobile: ?0
sec-ch-ua-platform: "macOS"

Upgrade-Insecure-Requests: 1

Sec-Fetch-Site: none
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document

Cookie: _gcl_au=1.1.1969632477.1642737980; ...

If-None-Match: W/"388-1647958095621"
If-Modified-Since: Tue, 22 Mar 2022 14:08:15 GMT
```

> q权重系数
- 范围: 0 =< q <= 1
- q 值越大，请求越倾向于获得其“;”之前的类型表示的内容
- 若没有指定 q 值，则默认为1，若被赋值为0，则用于提醒服务器哪些是浏览器不接受的内容类型。


> 常见的get请求头
- Accept:
- 告诉服务器 客户端可以接收的数据类型
<!-- 
  */* 表示任意类型数据
 -->

- Accept-Language:
- 告诉服务器客户端可以接收的语言类型 
  zh_CH
  en_US
  ja

- User-Agent:
- 用户代理(浏览器的信息): 
- 数据是我们操作浏览器 浏览器替我们发送的 浏览器就是代理

- Accept-Encoding:
- 告诉服务器 客户端可以接收的数据的编码格式(或者压缩格式)

- Host:
- 请求的服务器的ip和端口号

- Connection:
- 告诉服务器请求连接如何处理
- 常用的值:
- 1. keep-alive: 
  告诉服务器回传数据后不要马上关闭 保持一小段时间的连接

- 2. closed:
  马上关闭


> post请求的http协议格式
-  post请求分为4部分
- 1. 请求行
  - 请求行分为3个部分:
  - 1. 请求的方式: POST
  - 2. /请求资源路径?请求参数#片段
  - 3. 请求的协议和版本号: HTTP/1.1

- 2. 请求头
  - key:value 不同的请求头 有不同的含义

- 3. 空行

- 4. 请求体
  - 就是发送给服务器的数据


- 下面的内容就是 post请求的 http 协议内容:
```js
// 请求行
POST /project/hello2 HTTP/1.1

// 请求头
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/;q=0.8,application/signed-exchange;v=b3;q=0.9

Referer: http://localhost:8080/project/

Accept-Language: zh-CN,zh;q=0.9

User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.83 Safari/537.36

Accept-Encoding: gzip, deflate, br

Host: localhost:8080

Connection: keep-alive
Content-Length: 28

Content-Type: application/x-www-form-urlencoded

Cache-Control: max-age=0

sec-ch-ua: " Not A;Brand";v="99", "Chromium";v="99", "Google Chrome";v="99"

sec-ch-ua-mobile: ?0
sec-ch-ua-platform: "macOS"
Upgrade-Insecure-Requests: 1
Origin: http://localhost:8080

Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document

Cookie: _gcl_au=1.1.1969632477.1642737980; ...


// 空行

// 请求体
username=sam&password=123321
```

> 常见的post请求头
- get和post大部分的请求头是相同的

- Referer:
- 请求发起时 浏览器地址栏的地址(从哪来) 
<!-- 
  比如 
  前端页面:
  http://localhost:8080/project/
  页面有一个 form表单
  action="http://localhost:8080/project/hello2"

  也就是说我们点击 提交的时候 会跳转到 http://localhost:8080/project/hello2

  这时我们再打开控制台的 network 查看 Referer
  会发现它的值为 http://localhost:8080/project/

  也就是说我们可以从这个请求头上看出 从哪来到/hello2这个页面的


  应用场景:
  - 1. 从这个请求头也能看出 哪个网站给我导的流量比较多
  - 2. 防止盗链 这个没细说
 -->

- Content-Type:
- 表示发送数据的类型 常用的值:
  - application/x-www-form-urlencoded 
    - 表示提交的数据格式是: key=value&key=value
    - 然后对url进行编码(把非英文的内容转换为 %xxx%xx)

  - multipart/form-data:
    - 表示以多段的形式提交数据给服务器(以流的形式)
    - 用于上传

- Content-Length:
- 发送数据的长度

- Cache-Control:
- 表示如何控制缓存 
- no-cache不缓存


> get请求有哪些:
- 1. form标签 method = get
- 2. a标签
- 3. link标签 引入css
- 4. script标签 引入js文件
- 5. img标签 引入图片
- 6. iframe 引入html页面
- 7. 在浏览器地址栏输入地址后敲回车


> post请求
- form标签 method = post

----------------

### 响应的 http协议格式
- 跟请求的相比而言 也是分3个部分

- 1. 响应行
  - 响应行分为4个部分
  - 1. 响应的协议和版本号  HTTP/1.1
  - 2. 响应的状态码       200
  - 3. 响应状态描述符(对响应状态码进行描述的)   OK

- 2. 响应头
  - key: value
  - 不同的响应头 有不同的含义
  - 表示一些服务器的信息

- 3. 空行

- 4. 响应体
  - 回传给客户端的数据


下面的内容就是 响应的 http 协议内容:
```js
// 响应航
HTTP/1.1 200 OK

// 响应头
Server: Apche-Coyote/1.1
Accept-Ranges: bytes
ETag: W/"415-1648127565264"
Last-Modified: Thu, 24 Mar 2022 13:12:45 GMT
Content-Type: text/html
Content-Length: 415
Date: Thu, 24 Mar 2022 14:08:22 GMT
Keep-Alive: timeout=20
Connection: keep-alive

// 空行

// 响应体
```

> 常见的响应头信息:
- Server:
- 表示服务器的信息

- Content-Type:
- 表示响应体的数据类型 如: text/html
- 显示 文本/html文本

- Content-Length:
- 数据的长度

- Date:
- 请求响应的时间(GMT是格林时间距北京差8小时)

- Accept-Ranges:
- 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器某个部分资源。
- bytes
- none


> 常见的响应码说明
- 200:
  表示请求成功

- 302:
  表示请求重定向

- 404:
  表示请求服务器已经收到了 但是你要的数据不存在
  (可能是请求地址错了)

- 500:
  表示服务器已经收到请求 但是服务器内部错误
  (服务器的代码错误)


> MIME类型说明
- MIME是HTTP协议中数据类型

> 格式:
- 大类型/小类型

> 常见的MIME类型

  超文本标记语言文本: 
      .html   text/html

  普通文本:
      .txt    text/plan

  RTF文本:
      .rtf    application/rtf

  GIF图形:
      .gif    image/gif
  
  JPEG图形:
      .jpeg   image/jpeg

  GZIP文件:
      .gz     application/x-gzip

  TAR文件:
      .tar    application/x-tar






























--- 下面的部分是看书记录的 ---

### HTTP
- Web 浏览器、服务器和相关的Web 应用程序都是通过HTTP 相互通信的

- HTTP的特点
- HTTP 使用的是可靠的数据传输协议，因此即使数据来自地球的另一端，它也能够确保数据在传输的过程中不会被损坏或产生混乱


### Web客户端和服务器
- Web 内容都是存储在Web 服务器上的。Web 服务器所使用的是HTTP 协议，因此经常会被称为HTTP 服务器。

- HTTP客户端发送http请求 HTTP服务端会在http响应中会送所请求的数据
<!-- 
  最常见的客户端就是Web 浏览器
 -->

> 资源
- 最简单的Web 资源就是Web 服务器文件系统中的静态文件。这些文件可以包含任意内容

- 但资源不一定非得是静态文件。资源还可以是根据需要生成内容的软件程序。


> 媒体类型
- 因特网上有数千种不同的数据类型，HTTP 仔细地给每种要通过Web 传输的对象都打上了名为MIME 类型（MIME type） 的数据格式标签。


> MIME 类型
- MIME 类型是一种文本标记，表示一种*主要的对象类型和一个特定的子类型*，中间由一条斜杠来分隔。

- HTML 格式的文本文档由 
    text/html

- 普通的 ASCII 文本文档由
    text/plain

- JPEG 格式的图片为 
    image/jpeg

- GIF 格式的图片为 
    image/gif

- Apple 的 QuickTime 电影为 
    video/quicktime

- 微软的 PowerPoint 演示文件为 
    application/vnd.ms-powerpoint


> URI(统一资源标识符)
- 每个Web 服务器资源都有一个名字，这样客户端就可以说明它们感兴趣的资源是什么了。

- URI 就像因特网上的邮政地址一样，在世界范围内唯一标识并定位信息资源。
<!-- 
  http://www.joes-hardware.com/specials/saw-blade.gif
  访问Joe 商店服务器上的图片资源的
 -->

- URI 有两种形式
- 1. URL
- 2. URN


> URL(统一资源定位符)
- 是资源标识符最常见的形式
- URL 描述了一台特定服务器上某资源的特定位置。
- 是浏览器寻找信息时所需的资源位置。通过URL，人类和应用程序才能找到、使用并共享因特网上大量的数据资源。
<!-- 
  http://www.joes-hardware.com/specials/saw-blade.gif

  http://   
      使用http协议

  www.joes-hardware.com
      主机名

  /specials/saw-blade.gif
      获取名为 xx 的资源
 -->

- 大部分URL 都遵循一种标准格式，这种格式包含三个部分。
> 方案 + 服务器地址 + 某个资源
<!-- 
  URL 的第一部分被称为方案（scheme），说明了访问资源所使用的协议类型。这部分通常就是HTTP 协议（http://）。
 -->

> URN(统一资源名)
- URN 是作为特定内容的唯一名称使用的，与目前的资源所在地无关
- 使用这些与位置无关的URN，就可以将资源四处搬移。


> 事务
- 一个HTTP 事务由一条（从客户端发往服务器的）请求命令和一个（从服务器发回客户端的）响应结果组成。
- 这种通信是通过名为HTTP 报文


> 方法
- HTTP 支持几种不同的请求命令，这些命令被称为HTTP 方法
- 每条HTTP 请求报文都包含一个方法这个方法会告诉服务器要执行什么动作（获取一个Web 页面、运行一个网关程序、删除一个文件等）
<!--  
  GET     从服务器向客户端发送命名资源
  PUT     将来自客户端的数据存储到一个命名的服务器资源中去
  DELETE  从服务器中删除命名资源
  POST    将客户端数据发送到一个服务器网关应用程序
  HEAD    仅发送命名资源响应中的HTTP 首部
 -->


> 状态码
- 每条HTTP 响应报文返回时都会携带一个状态码。状态码是一个三位数字的代码，告知客户端请求是否成功，或者是否需要采取其他动作
<!--    
  200 OK。文档正确返回
  302 Redirect（重定向）。到其他地方去获取资源
  404 Not Found（没找到）。无法找到这个资源
 -->


> 报文
- HTTP 报文是由一行一行的简单字符串组成的。HTTP 报文都是纯文本，不是二进制代码，所以人们可以很方便地对其进行读写
<!-- 
  // 请求报文
  GET /test HTTP/1.0
  Accept: text/*
  Accept-Language: en, fr

  // 响应报文
  HTTP/1.0 200 ok
  Content-type: text/plain
  Content-length: 19

  hi i am a message!
 -->

- HTTP 报文包括以下三个部分。
- 1. 起始行
    报文的第一行就是起始行，
    在请求报文中用来说明要做些什么，
    在响应报文中说明出现了什么情况。

- 2. 首部字段
    起始行后面有零个或多个首部字段。
    每个首部字段都包含一个名字和一个值，
    为了便于解析，两者之间用冒号（:）来分隔。
    首部以一个空行结束。添加一个首部字段和添加新行一样简单。

- 3. 主体
    空行之后就是可选的报文主体了，其中包含了所有类型的数据
    请求主体中包括了要发送给Web 服务器的数据

    响应主体中装载了要返回给客户端的数据。


> 响应报文中的首部字段
> Content-Length
- 响应主体的长度

> Content-Type
- 文档的MIME 类型。


> TCP/IP
- HTTP 是个应用层协议。HTTP 无需操心网络通信的具体细节；它把联网的细节都交给了通用、可靠的因特网传输协议TCP/IP。
<!-- 
  因特网自身就是基于TCP/IP 的，TCP/IP 是全世界的计算机和网络设备常用的层次化分组交换网络协议集。
  
  TCP/IP 隐藏了各种网络和硬件的特点及弱点，使各种类型的计算机和网络都能够进行可靠地通信。
 -->

- TCP 提供了：
- 1. 无差错的数据传输；
- 2. 按序传输（数据总是会按照发送的顺序到达）；
- 3. 未分段的数据流（可以在任意时刻以任意尺寸将数据发送出去）

- TCP协议的特点
- 只要建立了TCP 连接，客户端和服务器之间的报文交换就不会丢失、不会被破坏，也不会在接收时出现错序了。

<!-- 
  HTTP    应用层
  TCP     传输层
  IP      网络层
  链路    链路层
  硬件    物理层
 -->


> 　连接、IP地址及端口号
- 在HTTP 客户端向服务器发送报文之前，需要用网际协议（Internet Protocol，IP）地址和端口号在客户端和服务器之间建立一条TCP/IP 连接。

- 建立一条TCP 连接的过程:
- 1. 需要知道服务器的IP 地址
- 2. 与服务器上运行的特定软件相关的TCP 端口号。

- 怎么获得HTTP 服务器的IP 地址和端口号呢？
- 通过URL!
<!-- 
  http://207.200.83.29:80/index.html
  http://www.netscape.com:80/index.html

  第一个URL 使用了机器的IP 地址，207.200.83.29 以及端口号80。

  第二个URL 没有使用数字形式的IP 地址，它使用的是文本形式的域名，或者称为
  主机名（www.netscape.com）。

  主机名就是IP 地址比较人性化的别称。

  默认端口号是80
 -->

<!-- 
  (a) 浏览器从URL 中解析出服务器的主机名；
  (b) 浏览器将服务器的主机名转换成服务器的IP 地址；
  (c) 浏览器将端口号（如果有的话）从URL 中解析出来；
  (d) 浏览器建立一条与Web 服务器的TCP 连接；
  (e) 浏览器向服务器发送一条HTTP 请求报文；
  (f) 服务器向浏览器回送一条HTTP 响应报文；
  (g) 关闭连接，浏览器显示文档。
 -->


> 代理
- 位于客户端和服务器之间的HTTP 中间实体。
- 这是Web 安全、应用集成以及性能优化的重要组成模块。
- 代理位于客户端和服务器之间，接收所有客户端的HTTP 请求，并
将这些请求转发给服务器(可能会对请求进行修改之后转发)

- 代理还可以对请求和响应进行过滤
<!-- 
  比如，在企业中对下载的应用程序进行病毒检测，或者对小学生屏蔽一些成人才能看的内容。
 -->


> 缓存
- HTTP 的仓库，使常用页面的副本可以保存在离客户端更近的地方。
- Web 缓存（Web cache）或代理缓存（proxy cache）是一种特殊的HTTP 代理服务器
<!-- 
  也就是说缓存也是服务器？
  可以将经过代理传送的常用文档复制保存起来
  下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了
 -->


> 网关
- 连接其他应用程序的特殊Web 服务器。
- 通常用于将HTTP 流量*转换成其他的协议*

- 网关接受请求时就好像自己是资源的源端服务器一样。客户端可能并不知道自己正在与一个网关进行通信。


> 隧道
- 对HTTP 通信报文进行盲转发的特殊代理。
- 建立起来之后，就会在两条连接之间对原始数据进行盲转发的HTTP 应用程序

- HTTP 隧道通常用来在一条或多条HTTP 连接上转发非HTTP 数据，转发时不会窥探数据。


> Agent代理
- 发起自动HTTP 请求的半智能Web 客户端。
- 用户Agent 代理 是代表用户发起HTTP 请求的客户端程序
<!-- 
  所有发布Web 请求的应用程序都是HTTP Agent 代理。
  到目前为止，我们只提到过一种HTTP Agent 代理：Web 浏览器，
 -->

-------------------------

### URL语法
- 大多数URL 方案的URL 语法都建立在这个由9 部分构成的通用格式上：

- <scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>
<!-- 
  几乎没有哪个URL 中包含了所有这些组件。
  URL 最重要的3 个部分是方案（scheme）、主机（host）和路径（path）。
 -->

- <scheme> 方案
  - 访问服务器以获取资源时要使用哪种协议

- <user> 用户
  - 某些方案访问资源时需要的用户名

- <password> 密码
  - 用户名后面可能要包含的密码，中间由冒号（:）分隔

- <host> 主机
  - 资源宿主服务器的主机名或点分IP 地址

- <port> 端口
  - 资源宿主服务器正在监听的端口号。很多方案都有默认端口号（HTTP 的默认端口号为80）

- <path> 路径
  - 服务器上资源的本地名，由一个斜杠（/）将其与前面的URL 组件分隔开来

- <params> 参数
  - 某些方案会用这个组件来指定输入参数。参数为名/ 值对。URL 中可以包含多个参数字段，它们相互之间以及与路径的其余部分之间用分号（;）分隔

- <query> 查询
  - 查询组件的内容没有通用格式。用字符“?”将其与URL 的其余部分分隔开来

- <frag> 片段
  - 一小片或一部分资源的名字。引用对象时，不会将frag 字段传送给服务器；这个字段是在客户端内部使用的。通过字符“#”将其与URL 的其余部分分隔开来


> 方案
- 方案实际上是规定如何访问指定资源的主要标识符，它会告诉负责解析URL 的应用程序应该使用什么协议

- 方案组件必须以一个字母符号开始，由第一个“:”符号将其与URL 的其余部分分隔开来。方案名是大小写无关的


> 主机与端口
- 要想在因特网上找到资源，应用程序要知道是哪台机器装载了资源，以及在那台机器的什么地方可以找到能对目标资源进行访问的服务器。URL 的主机和端口组件提供了这两组信息。


> 用户名和密码
- 很多服务器都要求输入用户名和密码才会允许用户访问数据
<!-- 
  ftp://ftp.prep.ai.mit.edu/pub/gnu
  ftp://anonymous@ftp.prep.ai.mit.edu/pub/gnu
  ftp://anonymous:my_passwd@ftp.prep.ai.mit.edu/pub/gnu
  http://joe:joespasswd@www.joes-hardware.com/sales_info.txt
 -->


> 编码机制
- 为了避开安全字符集表示法带来的限制，人们设计了一种编码机制，用来在URL 中表示各种不安全的字符。

- 这种编码机制就是通过一种“转义”表示法来表示不安全字符的，这种转义表示法包含一个百分号（%），后面跟着两个表示字符ASCII 码的十六进制数。


-------------------------

### 报文
- 如果说HTTP 是因特网的信使，那么HTTP 报文就是它用来搬东西的包裹了

- HTTP 报文是在HTTP 应用程序之间发送的数据块
- HTTP 使用术语流入（inbound）和流出（outbound）来描述事务处理（transaction）的方向

- 流入 指 客户端发送请求
- 流出 指 服务端返回响应

- HTTP 报文会像河水一样流动。不管是请求报文还是响应报文，所有报文都会向下游（downstream） 流动（ 参见图3-2）。所有报文的发送者都在接收者的上游（upstream）


> 报文的组成部分
- 。每条报文都包含一条来自客户端的请求，或者一条来自服务器的响应。它们由三个部分组成：

- 1. 对报文进行描述的起始行
- 2. 包含属性的首部（header）块
- 3. 包含数据的主体（body）部分。


> 请求报文的格式：
  <method> <request-URL> <version>
  <headers>
  <entity-body>

- 方法（method）
- 客户端希望服务器对资源执行的动作。

- 请求URL
- 命名了所请求资源，或者URL 路径组件的完整URL。

- 版本
- 报文所使用的HTTP 版本，其格式看起来是这样的
<!-- 
  HTTP/<major>.<minor>
 -->

- 状态码
- 这三位数字描述了请求过程中所发生的情况

- 原因短语
- 数字状态码的可读版本，包含行终止序列之前的所有文本。

- 首部
- 可以有零个或多个首部，每个首部都包含一个名字，后面跟着一个冒号（:），然后是一个可选的空格，接着是一个值，最后是一个CRLF。
- 首部是由一个空行（CRLF）结束的，表示了首部列表的结束和实体主体部分的开始。

- 实体的主体部分
- 实体的主体部分包含一个由任意数据组成的数据块。并不是所有的报文都包含实体的主体部分，有时，报文只是以一个CRLF 结束。


> 响应报文的格式（注意，只有起始行的语法有所不同）：
  <version> <status> <reason-phrase>
  <headers>
  <entity-body>


> 常用的http方法
  GET     从服务器获取一份文档否
  HEAD    只从服务器获取文档的首部否
  POST    向服务器发送需要处理的数据是
  PUT     将请求的主体部分存储在服务器上是
  TRACE   对可能经过代理服务器传送到服务器上去的报文进行追踪否
  OPTIONS 决定可以在服务器上执行哪些方法否
  DELETE  从服务器上删除一份文档否

> 安全方法
- HTTP 定义了一组被称为安全方法的方法。GET 方法和HEAD 方法都被认为是安全的，这就意味着使用GET 或HEAD 方法的HTTP 请求都不会产生什么动作。

- 不产生动作，在这里意味着HTTP 请求不会在服务器上产生什么结果。


> GET
- 通常用于请求服务器发送某个资源


> HEAD
- HEAD 方法与GET 方法的行为很类似，但服务器在响应中只返回首部。不会返回实体的主体部分

- 这就允许客户端在未获取实际资源的情况下，对资源的首部进行检
查。使用HEAD，
<!-- 
  在不获取资源的情• 况下了解资源的情况（比如，判断其类型）；
  通过查看响应中的状态码，看看某个对象是否存在；
  通过查看首部，测试资源是否被修改了。
 -->


> PUT
- 与GET 从服务器读取文档相反，PUT 方法会向服务器写入文档。
- PUT 方法的语义就是让服务器用请求的主体部分来创建一个由所请求的URL 命名的新文档，或者，如果那个URL 已经存在的话，就用这个主体来替代它。

- 因为PUT 允许用户对内容进行修改，所以很多Web 服务器都要求在执行PUT 之前，用密码登录。


> POST
- POST 方法起初是用来向服务器输入数据的 通常会用它来支持HTML
的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到它要去的地方


> TRACE
- 客户端发起一个请求时，这个请求可能要穿过防火墙、代理、网关或其他一些应用程序。每个中间节点都可能会修改原始的HTTP 请求。
- TRACE 方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子。TRACE 请求会在目的服务器端发起一个“环回”诊断。行程最后一站的服务器会弹回一条TRACE 响应，并在响应主体中携带它收到的原始请求报文。
- 这样客户端就可以查看在所有中间HTTP 应用程序组成的请求/ 响应链上，原始报文是否，以及如何被毁坏或修改过


> OPTIONS
- OPTIONS 方法请求Web 服务器告知其支持的各种功能。


> DELETE
- DELETE 方法所做的事情就是请服务器删除请求URL 所指定的资源。但是，客户端应用程序无法保证删除操作一定会被执行。

---------------

### 状态码
- HTTP 状态码被分成了五大类。状态码为客户端提供了一种理解事务处理结果的便捷方式。

> 状态码分类
  100 ～ 199  100 ～ 101 信息提示
  200 ～ 299  200 ～ 206 成功
  300 ～ 399  300 ～ 305 重定向
  400 ～ 499  400 ～ 415 客户端错误
  500 ～ 599  500 ～ 505 服务器错误


> 100 ~ 199 信息性状态码
- HTTP/1.1 向协议中引入了信息性状态码。

- 100
  - Continue
  - 说明收到了请求的初始部分，请客户端继续。发送了这个状态码之后，服务器在收到请求之后必须进行响应。


- 101
  - Switching Protocols
  - 说明服务器正在根据客户端的指定，将协议切换成Update 首部所列的协议


> 200 ~ 299 成功的状态码
- 客户端发起请求时，这些请求通常都是成功的。

- 200 OK
  - 请求没问题，实体的主体部分包含了所请求的资源

- 201 Created
  - 用于创建服务器对象的请求（比如，PUT）。
  - 响应的实体主体部分中应该包含各种引用了已创建的资源的URL，
  - Location 首部包含的则是最具体的引用。
  - 服务器必须在发送这个状态码之前创建好对象


- 202 Accepted
  - 请求已被接受，但服务器还未对其执行任何动作。
  - 不能保证服务器会完成这个请求；这只是意味着接受请求时，它看起来是有效的。
  - 服务器应该在实体的主体部分包含对请求状态的描述，
  - 或许还应该有对请求完成时间的估计（或者包含一个指针，指向可以获取此信息的位置）


- 203 Non-Author i tat iveInformation
  - 实体首部
  - 包含的信息不是来自于源端服务器，而是来自资源的一份副本。如果中间节点上有一份资源副本，
  - 但无法或者没有对它所发送的与资源有关的元信息（首部）进行验证，就会出现这种情况。
  - 这种响应码并不是非用不可的；如果实体首部来自源端服务器，响应200 状态的应用程序就可以将其作为一种可选项使用


- 204 No Content
  - 响应报文中包含若干首部和一个状态行，但没有实体的主体部分。
  - 主要用于在浏览器不转为显示新文档的情况下，对其进行更新（比如刷新一个表单页面）


- 205 Reset Content
  - 另一个主要用于浏览器的代码。负责告知浏览器清除当前页面中的所有HTML 表单元素


- 206 Partial Content
  - 成功执行了一个部分或Range（范围）请求。
  - 客户端可以通过一些特殊的首部来获取部分或某个范围内的文档——这个状态码就说明范围请求成功了

  - 206 响应中必须包含
      Content-Range、
      Date
      ETag 或 Content-Location 首部


> 300 ~ 399 重定向状态码
- 重定向状态码要么告知客户端使用替代位置来访问他们所感兴趣的资源，要么就提供一个替代的响应而不是资源的内容。

- 如果资源已被移动，可发送一个重定向状态码和一个可选的Location 首部来告知客户端资源已被移走，以及现在可以在哪里找到它

- 浏览器就可以在不打扰使用者的情况下，透明地转入新的位置了。


- 300 Multiple Choices
  - 客户端请求一个实际指向多个资源的URL 时会返回这个状态码
  - 比如服务器上有某个HTML 文档的英语和法语版本。返回这个代码时会带有一个选项列表；这样用户就可以选择他希望使用的那一项了。有多个版本可用时，客户端需要沟通解决


- 301 Moved Permanently
  - 在请求的URL 已被移除时使用。响应的Location 首部中应该包含资源现在所处的URL


- 302 Found
  - 与301 状态码类似；但是，客户端应该使用Location 首部给出的URL 来临时定位资源。将来的请求仍应使用老的URL


- 303 See Other
  - 告知客户端应该用另一个URL 来获取资源。
  - 新的URL 位于响应报文的Location 首部。其主要目的是允许POST 请求的响应将客户端定向到某个资源上去


- 304 Not Modified
  - 客户端可以通过所包含的请求首部，使其请求变成有条件的。
  - 如果客户端发起了一个条件GET请求，而最近资源未被修改的话，就可以用这个状态码来说明资源未被修改。
  - 带有这个状态码的响应不应该包含实体的主体部分


- 305 Use Proxy
  - 用来说明必须通过一个代理来访问资源
  - 代理的位置由Location首部给出。很重要的一点是，客户端是相对某个特定资源来解析这条响应的，不能假定所有请求，甚至所有对持有所请求资源的服务器的请求都通过这个代理进行。如果客户端错误地让代理介入了某条请求，可能会引发破坏性的行为，而且会造成安全漏洞


- 307 Temporary Redirect
  - 与301 状态码类似；但客户端应该使用Location 首部给出的URL来临时定位资源。将来的请求应该使用老的URL


> 400 ~ 499 客户端错误状态码
- 有时客户端会发送一些服务器无法处理的东西
- 比如格式错误的请求报文，或者最常见的是，请求一个不存在的URL。

- 浏览网页时，我们都看到过臭名昭著的404 Not Found 错误码——这只是服务器在告诉我们，它对我们请求的资源一无所知。


- 400 Bad Request
  - 用于告知客户端它发送了一个错误的请求


- 401 Unauthorized  为经许可的
  - 与适当的首部一同返回，在这些首部中请求客户端在获取对资源的访问权之前， 对自己进行认证。


- 403 Forbidden
  - 用于说明请求被服务器拒绝了
  - 如果服务器想说明为什么拒绝请求，可以包含实体的主体部分来对原因进行描述。
  - 但这个状态码通常是在服务器不想说明拒绝原因的时候使用的


- 404 Not Found
  - 用于说明服务器无法找到所请求的URL。通常会包含一个实体，以便客户端应用程序显示给用户看


- 405 Method Not Allowed
  - 发起的请求中带有所请求的URL 不支持的方法时，使用此状态码。
  - 应该在响应中包含Allow 首部，以告知客户端对所请求的资源可以使用哪些方法


- 406 Not Acceptable
  - 客户端可以指定参数来说明它们愿意接收什么类型的实体。
  - 服务器没有与客户端可接受的URL 相匹配的资源时，使用此代码
  - 通常，服务器会包含一些首部，以便客户端弄清楚为什么请求无法满足。


- 408 Request Timeout
  - 如果客户端完成请求所花的时间太长，服务器可以回送此状态码，并关闭连接。超时时长随服务器的不同有所不同，但通常对所有的合法请求来说，都是够长的


- 409 Conflict
  - 用于说明请求可能在资源上引发的一些冲突。服务器担心请求会引发冲突时，可以发送此状态码 响应中应该包含描述冲突的主体


- 410 Gone
  - 与404 类似，只是服务器曾经拥有过此资源。主要用于Web 站点的维护，这样服务器的管理者就可以在资源被移除的情况下通知客户端了


- 411 Length Required
  - 服务器要求在请求报文中包含Content-Length 首部时使用


- 412 Precondition Failed
  - 客户端发起了条件请求，且其中一个条件失败了的时候使用。
  - 客户端包含了Expect 首部时发起的就是条件请求。


- 413 Request Entity Too Large
  - 客户端发送的实体主体部分比服务器能够或者希望处理的要大时，使用此状态码


- 414 Request URI Too Long
  - 客户端所发请求中的请求URL 比服务器能够或者希望处理的要长时，使用此状态码


- 415 Unsupported Media Type
  - 服务器无法理解或无法支持客户端所发实体的内容类型时，使用此状态码


- 416 Requested Range Not Satisfiable
  - 请求报文所请求的是指定资源的某个范围，而此范围无效或无法满足时，使用此状态码


- 417 Expectation Failed
  - 请求的Expect 请求首部包含了一个期望，但服务器无法满足此期望时，使用此状态码。


> 500 ~ 599 服务器错误状态码
- 有时客户端发送了一条有效请求，服务器自身却出错了。这可能是客户端碰上了服务器的缺陷，或者服务器上的子元素，比如某个网关资源，出了错

- 代理尝试着代表客户端与服务器进行交流时，经常会出现问题。


- 500 Internal Server Error
  - 服务器遇到一个妨碍它为请求提供服务的错误时，使用此状态码


- 501 Not Implemented
  - 客户端发起的请求超出服务器的能力范围（比如，使用了服务器不支持的请求方法）时，使用此状态码


- 502 Bad Gateway
  - 作为代理或网关使用的服务器从请求响应链的下一条链路上收到了一条伪响应（比如，它无法连接到其父网关）时，使用此状态码


- 503 Service Unavailable
  - 用来说明服务器现在无法为请求提供服务，但将来可以。如果服务器知道什么时候资源会变为可用的，可以在响应中包含一个Retry-After 首部


- 504 Gateway Timeout
  - 与状态码408 类似，只是这里的响应来自一个网关或代理，它们在等待另一服务器对其请求进行响应时超时了


- 505 HTTP Version Not Supported
  - 服务器收到的请求使用了它无法或不愿支持的协议版本时，使用此状态码。有些服务器应用程序会选择不支持协议的早期版本

---------------

### 首部
- 首部和方法配合工作，共同决定了客户端和服务器能做什么事情
- 在请求和响应报文中都可以用首部来提供信息

- HTTP 首部字段向请求和响应报文中添加了一些附加信息。本质上来说，它们只是一些名/ 值对的列表。


- 分类
- 通用首部:
    这些是客户端和服务器都可以使用的通用首部。可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能。

- 请求首部
    从名字中就可以看出，请求首部是请求报文特有的。
    它们为服务器提供了一些额外信息，比如客户端希望接收什么类型的数据。

- 响应首部
    响应报文有自己的首部集，以便为客户端提供信息
    比如，客户端在与哪种类型的服务器进行交互

- 实体首部
    实体首部指的是用于应对实体主体部分的首部。比如，可以用实体首部来说明实体主体部分的数据类型。

- 扩展首部
    扩展首部是非标准的首部，由应用程序开发者创建，但还未添加到已批准的HTTP 规范中去。


> 通用首部
- 有些首部提供了与报文相关的最基本的信息，它们被称为通用首部。

- Connection
    允许客户端和服务器指定与请求/ 响应连接有关的选项


- Date
    提供日期和时间标志，说明报文是什么时间创建的


- MIME-Version
    给出了发送端使用的MIME 版本


- Trailer
    如果报文采用了分块传输编码（chunked transfer encoding）方式，就可以用这个首部列出位于报文拖挂（trailer）部分的首部集合


- Transfer-Encoding
    告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式


- Update
    给出了发送端可能想要“升级”使用的新版本或协议


- Via
    显示了报文经过的中间节点（代理、网关）


> 通用缓存首部
- HTTP/1.0 引入了第一个允许HTTP 应用程序缓存对象本地副本的首部，这样就不需要总是直接从源端服务器获取了

- Cache-Control
    用于随报文传送缓存指示

- Pragma
    另一种随报文传送指示的方式，但并不专用于缓存


> 请求首部
- 请求首部是只在请求报文中有意义的首部。用于说明是谁或什么在发送请求、请求源自何处，或者客户端的喜好及能力

- 服务器可以根据请求首部给出的客户端信息，试着为客户端提供更好的响应。

- Client-IP
    - 提供了运行客户端的机器的IP 地址

- From
    - 提供了客户端用户的E-mail 地址

- Host
    - 给出了接收请求的服务器的主机名和端口号

- Referer
    - 提供了包含当前请求URI 的文档的URL

- UA-Color
    - 提供了与客户端显示器的显示颜色有关的信息

- UA-CPU
    - 给出了客户端CPU 的类型或制造商

- UA-Disp
    - 提供了与客户端显示器（屏幕）能力有关的信息

- UA-OS
    - 给出了运行在客户端机器上的操作系统名称及版本

- UA-Pixels
    - 提供了客户端显示器的像素信息

- User-Agent
    - 将发起请求的应用程序名称告知服务器


> Accept首部
- Accept 首部为客户端提供了一种将其喜好和能力告知服务器的方式，
- 包括它们想要什么，可以使用什么，以及最重要的，它们不想要什么。

- 这样，服务器就可以根据这些额外信息，对要发送的内容做出更明智的决定。
- Accept 首部会使连接的两端都受益。客户端会得到它们想要的内容，服务器则不会浪费其时间和带宽来发送客户端无法使用的东西。

- Accept
    - 告诉服务器能够发送哪些媒体类型

- Accept-Charset
    - 告诉服务器能够发送哪些字符集

- Accept-Encoding
    - 告诉服务器能够发送哪些编码方式

- Accept-Language
    - 告诉服务器能够发送哪些语言

- TE
    - 告诉服务器可以使用哪些扩展传输编码


> 条件请求首部
- 有时客户端希望为请求加上某些限制。
- 比如，如果客户端已经有了一份文档副本，就希望只在服务器上的文档与客户端拥有的副本有所区别时，才请求服务器传输文档。

- 通过条件请求首部，客户端就可以为请求加上这种限制，要求服务器在对请求进行响应之前确保某个条件为真


- Expect
    - 允许客户端列出某请求所要求的服务器行为

- If-Match
    - 如果实体标记与文档当前的实体标记相匹配，就获取这份文档

- If-Modified-Since
    - 除非在某个指定的日期之后资源被修改过，否则就限制这个请求

- If-None-Match
    - 如果提供的实体标记与当前文档的实体标记不相符，就获取文档

- If-Range
    - 允许对文档的某个范围进行条件请求

- If-Unmodified-Since
    - 除非在某个指定日期之后资源没有被修改过，否则就限制这个请求

- Range
    - 如果服务器支持范围请求，就请求资源的指定范围


> 安全请求首部
- HTTP 本身就支持一种简单的机制，可以对请求进行质询/ 响应认证
- 这种机制要求客户端在获取特定的资源之前，先对自身进行认证，这样就可以使事务稍微安全
一些。

- Authorization
    - 包含了客户端提供给服务器，以便对其自身进行认证的数据

- Cookie
    - 客户端用它向服务器传送一个令牌——它并不是真正的安全首部，但确实隐含了安全功能

- Cookie2
    - 用来说明请求端支持的cookie 版本


> 代理请求首部
- Max-Forward
    - 在通往源端服务器的路径上，将请求转发给其他代理或网关的最大次数 —— 与TRACE 方法一同使

- Proxy-Authorization 
    - 与Authorization 首部相同，但这个首部是在与代理进行认证时使用的

- Proxy-Connection
    - 与Connection 首部相同，但这个首部是在与代理建立连接时使用的



> 响应首部
- 响应报文有自己的响应首部集。响应首部为客户端提供了一些额外信息，
- 比如谁在发送响应、响应者的功能，甚至与响应相关的一些特殊指令。

- 这些首部有助于客户端处理响应，并在将来发起更好的请求。

- Age
    - （从最初创建开始）响应持续时间

- public
    - 服务器为其资源支持的请求方法列表

- Retry-After
    - 如果资源不可用的话，在此日期或时间重试

- Server
    - 服务器应用程序软件的名称和版本

- Title
    - 对HTML 文档来说，就是HTML 文档的源端给出的标题

- Warning
    - 比原因短语中更详细一些的警告报文


> 协商首部
- 如果资源有多种表示方法——比如，如果服务器上有某文档的法语和德语译稿，HTTP/1.1 可以为服务器和客户端提供对资源进行协商的能力

- Accept-Ranges
    - 对此资源来说，服务器可接受的范围类型

- Vary
    - 服务器查看的其他首部的列表，可能会使响应发生变化；也就是说，这是一个首部列表，服务器会根据这些首部的内容挑选出最适合的资源版本发送给客户端


> 安全响应首部
- Proxy-Authenticate
    - 来自代理的对客户端的质询列表

- Set-Cookie
    - 不是真正的安全首部，但隐含有安全功能；可以在客户端设置一个令牌，以便服务器对客户端进行标识

- WWW-Authenticate
    - 来自服务器的对客户端的质询列表


> 实体首部
- 有很多首部可以用来描述HTTP 报文的负荷。由于请求和响应报文中都可能包含实体部分，所以在这两种类型的报文中都可能出现这些首部。

- 实体首部提供了有关实体及其内容的大量信息，从有关对象类型的信息，到能够对资源使用的各种有效的请求方法。总之，实体首部可以告知报文的接收者它在对什么进行处理。

- Allow
    - 列出了可以对此实体执行的请求方法

- Location
    - 告知客户端实体实际上位于何处；用于将接收端定向到资源的位置（URL）上去


> 内容首部
- 内容首部提供了与实体内容有关的特定信息，说明了其类型、尺寸以及处理它所需的其他有用信息。
- 比如，Web 浏览器可以通过查看返回的内容类型，得知如何显示对象

- Content-Base
    - 解析主体中的相对URL 时使用的基础URL

- Content-Encoding
    - 对主体执行的任意编码方式

- Content-Language
    - 理解主体时最适宜使用的自然语言

- Content-Length
    - 主体的长度或尺寸

- Content-Location
    - 资源实际所处的位置

- Content-MD5
    - 主体的MD5 校验和

- Content-Range
    - 在整个资源中此实体表示的字节范围

- Content-Type
    - 这个主体的对象类型


> 实体缓存首部
- 通用的缓存首部说明了如何或什么时候进行缓存。实体的缓存首部提供了与被缓存实体有关的信息

- 比如，验证已缓存的资源副本是否仍然有效所需的信息，以及更好地估计已缓存资源何时失效所需的线索。


- ETag
    - 与此实体相关的实体标记

- Expires
    - 实体不再有效，要从原始的源端再次获取此实体的日期和时间

- Last-Modified
    - 这个实体最后一次被修改的日期和时间

---------------

### TCP链接
- 世界上几乎所有的HTTP 通信都是由TCP/IP 承载的，TCP/IP 是全球计算机及网络设备都在使用的一种常用的分组交换网络分层协议集。

- 客户端应用程序可以打开一条TCP/IP 连接，连接到可能运行在世界任何地方的服务器应用程序。一旦连接建立起来了，在客户端和服务器的计算机之间交换的报文就永远不会丢失、受损或失序


> TCP流是分段的、由IP分组传送
- TCP 的数据是通过名为IP 分组（或IP 数据报）的小数据块来发送的。这样的话，如图4-3a 所示，HTTP 就是“HTTP over TCP over IP”这个“协议栈”中的最顶层了。

- 其安全版本HTTPS 就是在HTTP 和TCP 之间插入了一个（称为TLS 或SSL的）密码加密层（图4-3b）。

- HTTP 要传送一条报文时，会以流的形式将报文数据的内容通过一条打开的TCP 连接按序传输。TCP 收到数据流之后，会将数据流砍成被称作段的小数据块，并将段封装在IP 分组中，通过因特网进行传输（参见图4-4）。所有这些工作都是由TCP/IP 软件来处理的，HTTP 程序员什么都看不到。

- 每个TCP 段都是由IP 分组承载，从一个IP 地址发送到另一个IP 地址的。每个IP分组中都包括
    - 一个 IP 分组首部（通常为 20 字节）；
    - 一个 TCP 段首部（通常为 20 字节）；
    - 一个 TCP 数据块（0 个或多个字节）。

- IP 首部包含了源和目的IP 地址、长度和其他一些标记。TCP 段的首部包含了TCP端口号、TCP 控制标记，以及用于数据排序和完整性检查的一些数字值。

> HTTP 事务的时延有以下几种主要原因。
- 客户端首先需要根据URI 确定Web 服务器的IP 地址和端口号。如果最近没有对URI 中的主机名进行访问，通过DNS 解析系统将URI 中的主机名转换成一个IP地址可能要花费数十秒的时间3。

- 接下来，客户端会向服务器发送一条TCP 连接请求，并等待服务器回送一个请求接受应答。每条新的TCP 连接都会有连接建立时延。这个值通常最多只有一两秒钟，但如果有数百个HTTP 事务的话，这个值会快速地叠加上去。

- 一旦连接建立起来了，客户端就会通过新建立的TCP 管道来发送HTTP 请求。数据到达时，Web 服务器会从TCP 连接中读取请求报文，并对请求进行处理。因特网传输请求报文，以及服务器处理请求报文都需要时间。

- 然后，Web 服务器会回送HTTP 响应，这也需要花费时间。

- 这些TCP 网络时延的大小取决于硬件速度、网络和服务器的负载，请求和响应报文的尺寸，以及客户端和服务器之间的距离。TCP 协议的技术复杂性也会对时延产生巨大的影响。


> 　常被误解的Connection首部
- Connection: close
- 说明发送完下一条报文之后必须关闭的连接。