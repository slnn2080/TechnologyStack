### java版的hello world
- 1. 将 java 代码编写到扩展名为 .java 的文件中
- 2. 通过 javac 命令对象该文件进行编译

> javac Java文件名
- 将文件编译为字节码文件
<!-- 
  javac demo.java
  .java文件会被编译成 字节码文件(.class文件)
 -->

> java 字节码文件名(类名)不要后缀
- 执行字节码文件
- 3. 通过 java 命令对生成的class文件进行运行
- 这里注意 我们使用 java 运行字节码文件的时候不要加.class后缀
<!-- 
  java HelloChina
 -->

- 完整的步骤
<!-- 
  class HelloChina {
    public static void main(String[] args) {
      System.out.println("Hello, world");
    }
  }

  javac demo.java
  java HelloChina     // 这里没有后缀名 .class
 -->  


> 注意：
- 1. classpath的问题
  - 当我们使用 java HelloChina 去执行这个.class字节码文件的时候 可能会提示操作 找不到或无法加载主类 HelloChina

  - 这可能是我们配置过classpath 我们可能在网上看过 除了配置path环境变量之外还要配置classpath

  - 不用配置classpath， classpath就是.class字节码文件的path 如果我们配置了classpath就意味着 我们写 java HelloChina 的时候 会去classpath里面找 而实际上我们的字节码文件可能在别的位置上 所以会报错

  - 默认会在当前路径下找 .class 文件

- 2. java文件里面单词严格区别大小写
- 3. java文件里面执行语句后都要有分号
<!-- 
  System.out.println("Hello, world");
 -->

- 4. 一个源文件中是可以声明多个class类的 但是只能最多有一个类可以被声明为 public的
<!-- 
  public 用来修改这个类的权限大小
  同时 
  public关键字 只能加在和文件名同名的类前 类名和源文件名必须相同
  文件名为demo 那么public只能加在 demo类前 public class demo { }
 -->

- 5. 程序的入口是main()方法  格式是固定的
<!-- 
  class Hello {
    // main()方法
    public state void main(String[] args) {

    }
  }
 -->

- 6. 输出语句
- System.out.println("")
- 该语法会在语句输出后 换行  先输出后换行
<!-- 
  System.out.println()    // 里面什么也不写的话 就是代表换行
 -->

- System.out.print("")
- 该语法不会换行

- 7. 每一条执行语句都以分号结尾
<!-- 
  技巧:
  从右往左看 除了 } 结尾的 剩下的都要以分号结尾
 -->


> 编译过程
- 编译以后 会生成一个或多个字节码文件 有几个类就会有几个字节码文件
- 字节码文件的文件名与java源文件中的类名相同


> 特性
- 面向对象性：
  两个要素: 类 对象
  三个特征: 封装 继承 多态

- 健壮性:
- 去除了c语言中的指针 有了自动的垃圾回收机制

- 跨平台性
- 功劳公共与 jvm 我们现在使用的虚拟机是 hotspot

----------------------------

### 注释
- 用于注解说明解释程序的文字就是注释
- java中的注释类型

> 单行注释  //

> 多行注释  /* */

> 文档注释(java特有)
- 语法：
  /**

  */

- 注释内容可以被JDK提供的工具 javadoc 所解析 生成一套以网页文件形式体现的该程序的说明文档

- javadoc 解析的类 类前要加上 public
- javadoc 只能解析 文档注释标记起来的内容
<!-- 
  /** 
    文档注释
    @author: sam
    @version: v1.0
    
    这是我的第一个程序
  */
  public class Demo { ... }
 -->

> 执行命令
- javac -d 文件名字 -author -version 文件名.java
- 生成的文件夹会在当前目录
- -author -version对应着@author @version

----------------------------

### 关键字 和 保留字

> 关键字
- 定义:
- 被java语言赋予了特殊的含义 用作专门用途的字符串

- 特点
- 关键字中所有字母都为小写

- 网址
- https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keyword.html

<!-- 
  用于定义数据类型的关键字

    class     interface     enum      byte      short
    int       long          float     double   char
    boolean   void



  用于定义流程控制的关键字

    if      else    switch    case    default
    while   do      for       break   continue
    return



  用于定义访问权限修饰符的关键字

    private   protected   public



  用于定义类 函数 变量修饰符的关键字

    abstract    final   static    synchronized


  
  用于定义类与类之间关系的关键字

    extends   implements


  
  用于定义建立实例及引用实例 判断实例的关键字

    new     this      super     instanceof



  用于包的关键字

    package   import



  其他修饰符关键字

    native    strictfp    transjent   volatile    assert



  用于定义数据类型值的字面值    下面的三个不算关键字 但还可以当做关注字

    true    false   null
 -->


> 保留字
- 现有java版本尚未使用 但以后版本可能会作为关键字使用 自己命名标识符时要避免使用这些保留字
<!-- goto const 等 -->

----------------------------

### 标识符
- java对各种变量 方法 和 类等要素命名时使用的 字符序列(单词) 被称为标识符
- 总的来说 凡事自己可以起名字的地方都叫做标识符

> 定义合法标识符规则
- 26个英文字母大小写 0-9 _ $ 组成
- 数字不可以开头
- 不可以使用关键字和保留字 但能包含关键字和保留字
- java中严格区分大小写 长度无限制
- 标识符不能包含空格


> 命名规范
- 包名
- 多单词组成时所有字母都小写 xxxyyyzzz

- 类名 接口名 大驼峰
- 多单词组成时 第一个单词首字母小写 第二个单词开始每个单词首字母大写 XxxYyyZzz

- 变量名 方法名 小驼峰
- 多单词组成时 第一个单词首字母小写 第二个单词开始每个单词首字母大写 xxxYyyZzz

- 常量名
- 所有字母都大写，多单词时每个单词用下划线连接 XXX_YYY_ZZZ

**注意：**
- 如果不遵守如上的规则 编译可以通过 编译能通过 运行也没有问题 但建议遵守
 
----------------------------

### 变量

> 变量的概念
- 内存中的一个存储区域
- 该区域的数据可以在同一类型范围内不断变化
- 变量是程序中最基本的存储单环 包含变量类型 变量名 存储的值


> 变量的作用
- 用在内存中保存数据


> 使用变量的注意
- 1. java中每个变量必须先声明 后使用
- 2. 使用变量名来访问这块区域的数据

- 3. 变量的作用域：
    其定义所在的一对{ }内

- 4. 变量只有在其作用域内才有效
- 5. 同一个作用域内 不能定义重名的变量


> 数据类型 变量名 = 变量值
- java定义变量的格式
<!-- 
  // 整型
    int myNum = 666;
    
  // 或者还可以这么写
    int myAge;
    myAge = 18;
 -->

**注意：**
- 1. 变量必须要赋初始值
- 2. 变量必须先声明后使用 注意书写顺序
- 3. 变量有作用域 在作用域内有效
- 4. 同一个作用域内 不能声明同名变量
<!-- 
  int myAge;
  System.out.println(myAge);    // 错误: 可能尚未初始化变量myAge
 -->


> 变量的类型 --- 按照类型区分
- 数据类型分为两类
- 1. 基本数据类型
    - 数值型
        - 整数类型(byte, short, int, long)  百特
        <!-- 存储空间是从小到大来的 -->

        - 浮点类型(float, double)

    - 字符型(char)

    - 布尔型(boolean)


- 2. 引用数据类型
    - 类(class)
    <!-- 
      java里字符串是一个 类 的类型 也就是引用类型
      同时我们存大量的字符的时候 好像也没有办法使用char 因为老师这意思char里只能装一个字符
     -->

    - 接口(interface)

    - 数组([])


> 变量的类型 --- 在类中声明的位置(面向对象的时候会详细讲)
    - 成员变量
    - 局部变量

- 补充知识：
- 在方法体外 类体内 声明的变量成为 成员变量
- 在方法体内       声明的变量成为 局部变量
<!--          
                      实例变量 -- 不以static修饰
            成员变量
                      类变量   -- 以static修饰
  所有变量

                      形参(方法 构造器中定义的变量)
            局部变量   方法局部变量 (在方法内定义)   
                      代码块局部变量 (在代码块内定义)

  注意：
  两者在初始化值方面的异同

  同：都有生命周期
  异：局部变量除形参外 需显示初始化
 -->

    
> 基本数据类型的使用 -- 整型
- 表示整数的 正负都可以 java中定义了4中整型 区别就是它们占用的空间不一样
- java各整数类型有固定的表数范围和字段长度 不受具体os的影响 以保证java程序的可移植性

- java的整型常量默认为int型 

- 声明long型常量必须加  l 或 L
<!-- 
  在使用long型的时候 必须以小写l 或者 大写L结尾
  long num = 345223L;  
  输出结果不会带有L
 -->

- java程序中变量通常声明为int 除非不足以表示较大的数 才用long


- 类型        占用存储空间      表数范围
- byte        1字节=8bit位    -128 ~ 127
- short       2字节           -2^15 ~ 2^15-1
- int         4字节           -2^31 ~ 2^31-1(约21亿)
- long        8字节           -2^63 ~ 2^63-1

- byte：
<!-- 
  从存储上讲是最小的单位 1字节=8bit 一个bit存0或者存1 两种情况 一共8个 所以byte一共有多少中组合方式 2^8=256 

  所以一个byte能表示256个数 0~255，但是这么表示就没有负数了 所以就是-128~127 加起来就是256
 -->

- short:
<!-- 
  它是byte的倍 也就是 2^16 
  那我们也分一半 就变成了 -2^15 ~ 2^15-1  因为还有一个0
 -->

- int   是 short 的2倍
- long  是 int 的2倍

<!-- 
  byte b1 = 12;
  byte b2 = -128;
  // b2 = 128;     编译不通过 超出范围了 -128 ~ 127

  // 声明long型变量 必须以"l" or "L"结尾
  long b3 = 234234234L;     // 234234234

  System.out.println(b1);
  System.out.println(b2);
  System.out.println(b3);
 -->


> 基本数据类型的使用 -- 浮点型
- 通俗的讲就是带有小数点
- 与证书类型类似 java浮点类型也有固定的表数范围和字段长度 不受具体操作系统的影响

- 浮点型常量有两种表示形式

    - 十进制数形式: 
        - 5.12    512.0f    .512(必须有小数点)

    - 科学计数法形式:
        - 5.12e2  512E2   100E-2

- float:  单精度 尾数可以精确到7位有效数字 很多情况下精度很难满足需求
<!-- 
  float存储数据量不仅少 精度也有限
  float表示数值的范围比long还大
 -->

- double: 双精度 精度是float的两步 通常采用此类型
<!-- 
  double存储数据量不仅多 精度也高
 -->

- 通常定义浮点型变量时 使用 double型

- 声明 float型 常量 结尾必须加 "f" 或 "F"


- 类型            占用存储空间      表数范围
- 单精度 float     4字节            -3.403E38 ~ 3.403E38
- 双精度 double    8字节            -1.798E308 ~ 1.798E308

- 这里的E指的是10 - E38 -> 10^38

<!-- 
  double b4 = 11.03;

  // 定义float型时  变量要以 F 结尾
  float d5 = 12.4F;
 -->


> 基本数据类型的使用 -- 字符类型(只能声明一个字符)
- char型数据用来表示通常意义上的 字符(2字节)
- 用处：
- 声明一个字符

- 1个字符 = 2个字节
- char会占用16个bit

- 通过 char型 定义的变量 只能定义一个字符
<!-- 
  char c1 = 'a'
  c1 = 'AB'   // 这里不能写两个 因为这相当于两个字符

  比如我们要是想定义 “张三” 这时候就不能使用char型 而是要使用字符串型
 -->

- java中的所有字符都使用unicode编码 故一个字符可以存储一个字母 一个汉字 或者其它书面语的一个字符

- 字符型 变量的三种表现形式

> char型的使用方式 
- 单引号('')括起来的单个字符 但是内部只能放一个
- 比如：
  char c1 = 'a';
  char c2 = '中';
  char c3 = '9';

- java中还允许使用转义字符 “\” 来将其后的字符转变为特殊字符型变量
- 例如
  char c4 = '\n';    \n表示换行符 \t制表符

- 直接使用 Unicode 值来表示字符型常量
- 比如
  char c5 = '\u0043'
  代表一个十六进制整数 底层输出一个数的时候 也对应一个字符

**char类型是可以进行运算的 因为它都对应有 Unicode 码**

- 这里注意：
- 命令行默认是使用系统的编码格式解析的 比如我们中国电脑的系统默认格式为gbk
- 当我们将编码格式改为utf-8的时候 打印中文的时候可能会出现乱码
- 我们要保证 写入 和 读取 时候的字符集是同一个


> 基本数据类型的使用 -- 布尔型
- 布尔型只能有两个值

  boolean b1 = true;

- 我们常常在条件判断 循环结构中使用
<!-- 
  boolean b1 = true
  if(b1) {
    System.out.println("你就不能参\'单身派对\'了")
  } else {
    System.out.println("你有女朋友了")
  }
 -->

----------------------------

### 基本数据类型转换
> 自动类型提升:
- 容量小的类型 自动转换为 容量大的数据类型
- 数据类型按容量大小排序为
<!-- 
  byte
  char    -- int -- long -- float -- double
  short
 -->

**注意:**
- byte, char, short 相互之间做运算的话 结果的类型都应该取 int


> 定义：
- 有多种类型的数据混合运算时 系统首先自动将所有数据转换成容量最大的那种数据类型 然后在进行计算

- 当表数范围小 和 表数范围大 的变量进行运算的时候 结果自动提升为表数范围大的类型(比如一个byte 一个int 那么计算结果要取int 或 以上)
<!-- 
  表数范围小: byte 一个字节 8bit
  表数范围大: int  四个字节 32bit

  当它们进行运算的时候 res 的类型就是int 因为类型会自动提升到 表数范围大的类型上

  byte b1 = 2;
  int i1 = 13;

  int res = b1 + i1;
  System.out.println(res);  // 15

  也就是 在取两个类型结果的时候 我们要定义什么类型去接收这个结果(res)

  我们也可以定义 long 来接收
  long res = b1 + i1;     // 15

  我们也可以定义 float 来接收
  float res = b1 + i1;    // 15.0  结果会补个0
 -->

- 一个表数范围小的类型 赋值给 表数范围大的类型 也没有问题
<!-- 
  short num = 1;
  double number = num;
 -->

- 说明
- 此时的容量大熊啊指的是 表示数的范围的大和小 不是指占用的内存空间
- 比如 float容量要大于long容量


> char型运算
- char型时可以做运算的 
<!-- 
  // char型的变量 对应着 unicode 码
  char str = 'a';  // 97
  int num = 8;

  int res = str + num;

  System.out.println(res);    // 105
 -->


> 总结
- 强制类型转换 是 自动类型提升 的逆过程
<!-- 
  其中 boolean 不能与其它类型进行运算 因为它只有true 和 false
  java中true 就是 true false 就是 false 不能像js那样 0 1
  所以下面中 我们所提到的 自动类型提升 不包括 布尔型

  byte short int long 可以做运算因为它们是数值
  char 能做运算 因为它的unicode对应着一个编码 比如 a 对应 97 97可以做运算
 -->
      

**注意:**
- byte short char 之间不会相互转换 他们三者在计算时首先转换为int类型
<!-- 
  byte    ↘
  short     →   int
  char    ↗
 -->

- boolean类型不能与其它数据类型运算
- 当把任何基本数据类型的值 和 字符串(String)进行连接运算时(+) 基本数据类型的值将自动转化为字符串(String)类型


> 强制类型转换
- 自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型
- 使用时要加上强制转换符: ()  但可能造成精度降低或溢出 格外要注意

- 通常 字符串不能直接转换为基本类型 但通过基本类型对应的包装类则可以实现把字符串转换为基本类型
<!-- 
  String a = "43"; int i = Integet.parseInt(a);
 -->

**注意:**
- boolean类型不可以转换为其它的数据类型



----------------------------

### 运算符

----------------------------

### 程序流程控制

----------------------------




























--------------------------------

### 基础扩展部分

### 命令
- java
  执行java文件时 使用的命令

- javac
  编译的时候 使用的命令

- javadoc
  生成一个以网页形式的文档


> Java当中的多环境切换
<!-- 
  "java.configuration.runtimes": [
      {
          "name": "JavaSE-1.8",
          "path": "D:\\soft\\Java\\jdk1.8.0_231",
          "default": true
      },
      {
          "name": "JavaSE-11",
          "path": "D:\\soft\\Java\\jdk-11.0.2",
      },
  ],
 -->


### Oracle密码
- Xl5467426/
https://login.oracle.com/mysso/signon.jsp


/Library/Java/JavaVirtualMachines/jdk-11.0.13.jdk/Contents/Home/
/Library/Java/JavaVirtualMachines/jdk1.8.0_311.jdk/Contents/Home/


> 环境变量
JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_311.jdk/Contents/Home/

PATH=$JAVA_HOME/bin:$PATH:

CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.

export JAVA_HOME
export PATH
export CLASSPATH


- 多版本jdk切换
<!-- 
  export JAVA_8_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_311.jdk/Contents/Home
  export JAVA_11_HOME=/Library/Java/JavaVirtualMachines/jdk-11.0.13.jdk/Contents/Home

  export JAVA_HOME=$JAVA_8_HOME

  alias jdk8="export JAVA_HOME=$JAVA_8_HOME"
  alias jdk11="export JAVA_HOME=$JAVA_11_HOME"

  export PATH=$PATH:$JAVA_HOME/bin:$GRADLE_HOME/bin
 -->

- sudo -i vi /etc/.bash_profile
- source /etc/.bash_profile

- source ~/.bash_profile



### 环境搭建

> JDK
- 它是提供给java开发人员使用的 其中包含了java的开发工具 也包括了JRE
- 安装了JDK 就不用单独安装JRE了
- JDK里面包含了两个部分

- JRE java运行环境
- 开发工具： 编译工具 javac.exe  打包工具 jar.exe等


> JRE java运行环境
- 包括java虚拟机和java程序所需的核心类库(java se)等
- 如果想要运行一个开发好的java程序 计算机中只需要安装JRE即可

- 简单而言 使用 JDK 的开发工具完成的java程序 交给JRE去运行


> JRD
- JRD = JVM + Java核心类库


> 环境变量中的 JAVA_HOME
- 它里面存的是bin的上一层目录
<!-- path = %JAVA_HOME%\bin   //这是window里面的 -->


> JDK的安装地址
- www.oracle.com
- java.sun.com


### Java
- java基础是学习javaEE 大数据 android开发的基石

- 常用语法
- C C++ Java PHP Kotlin Python Scala等
<!-- 
  Kotlin 谷歌出的语言 用来开发安卓的
  python 快速开发效率高 适合处理数据 跟java比起来小巫见大巫
  Oc 苹果的开发语言
  Go 具有java的开发效率 和 C的执行效率
 -->

- Java语言的应用可以应用在3个不同的领域当中

>  Java SE 标准版
- 支持面向桌面级应用的Java平台 提供了完整的Java核心API 此版本以前成为J2EE
<!-- QQ 360 -->

>  Java EE 企业版
- 为企业环境下的应用程序提供的一套解决方案 该技术体系中包含的技术如 Servlet Jsp等 主要针对Web应用程序开发 版本以前成为 J2EE
<!-- Web后台 -->

>  Java ME 小型版
- 支持Java程勋运行在移动端上的平台 对Java API有所精简 并加入了针对移动端的支持 此版本以前成J2ME

>  现在 Java 应用的领域
- 1. 企业级应用
  后台开发
  主要指复杂的大企业的软件系统 各种类型的网站 java的安全机制以及它的跨平台的优势 使它在分布式系统领域开发中有广泛应用 应用领域包括金融 电信 电子商务

- 2. Android平台应用
  安卓应用程序使用java语言编写 安卓开发水平的高低很大程度上取决于java语言核心能力是否扎实

- 3. 大数据平台开发
  大数据都提供给java接口


>  java语言的特点
- 跨平台性
- 我们java的应用程序实际上是跑在JVM上面的 JVM装在了不同的操作系统上 因为有了JVM 同一个Java程序在三个不同的操作系统中都可以执行 这样实现的java程序的跨平台性

- 不同操作系统的jvm不同
<!-- 
  window linux mac
 -->


> JVM 虚拟机
- jvm是一个虚拟的计算机 具有指令集并使用不同的存储区域 负责执行指令 管理数据 内存 寄存器

- 对于不同的平台 有不同的虚拟机
- 只有某平台踢动了对应的java虚拟机 java程序才可以在此平台运行
- java虚拟机机制屏蔽了底层运行平台的差别 实现了 一次编译 到处运行


### 人机交互方式
- 图形化界面 GUI
- 命令行方式 CLI
- 需要有一个控制台 输入特定的指令 让计算机完成一些操作


### 中央处理器
- CPU是计算机的大脑，它从内存中获取指令 然后执行这些指令

- 包括：
- 控制单元 和 算术/逻辑单元

- 控制单元：
- 用于控制和协调其他组件的动作

- 算术/逻辑单元：
- 用于完成数值运算 + - * / 和逻辑运算比较

- 每台计算机中都有一个内部时钟 该时钟以固定速度发射电子脉冲 时钟速度越快 在给定的时间段内执行的指令就越多
- 速度的计量单位是Hz 1Hz相当于每秒一个脉冲 随着cpu速度不断的提供 目前以千兆赫GHz来表述
<!-- 
  买电脑看GHz

  1khz = 1024hz
  1mhz = 1024khz
  1ghz = 1024mhz
 -->

- 最初一个cpu只有一个核core， 核是处理器中实现指令读取和执行的部分
- 一个多核cpu是一个具有两个或者更多独立核的组件 可提高cpu的处理能力

--------------------------------

### 计算机的硬件介绍
<!-- 
  输入设备 -- > 存   储   器 -- > 输出设备

             ↑ ↓       影↓ ↑虚

      -------------------------------
            运算器      控制器
      -------------CPU---------------


            实体箭头 - 数据流
            影体箭头 - 指令流
            虚线箭头 - 控制流
 -->

--------------------------------

### IT定律之计算机行业发展规律
- 摩尔定律
- 安迪-比尔定律
- 反摩尔定律

--------------------------------

### 计算机硬件介绍
- 内存中的信息在断电的时候会丢失 那么我们可以考虑将程序和数据永久的保存在存储设备上
- 当计算机确定需要这些数据的时候 再移入内存 因为从内存中读取比从存储设备读取要快得多

- 存储设备主要有以下三种

> 磁盘驱动器
- 每台计算机至少有一个硬盘驱动器 硬盘用于永久的保存数据和程序

> 光盘驱动器 CD DVD
- CD的容量可达700mb
- DVD的容量可达4.7gb

> USB闪存驱动器
- 通用串行总线 可以使用usb打印机 数码相机 鼠标 外部硬盘驱动器连接到计算机上
- usb闪存驱动器很小 可用于存储和传输数据的设备


> 比特bit 和 字节byte
- 在讨论内存前 先清除数据是如何存储在计算机中的

- 计算机就是一系列的电路开关 每个开关存在两种状态：
- 关 和 开
- 如果电路是开的 它的值就是1
- 如果电路是关的 它的值就是0

- 一个0 或者 一个1存储为一个比特bit 是计算机中最小的存储单位
- 计算机中最基本的存储单元是字节 byte 每个字节由8个比特构成 从存储数据的角度来看字节才是最小的单位

- 计算机的存储能力是以字节和多字节来衡量的如下

  千字节    kb = 1024b
  兆字节    mb = 1024kb
  千兆字节  gb = 1024mb
  万亿字节  tb = 1024gb

- 后面还有pb eb zb yb等单位


> 内存 RAM
- 由一个有序的字节序列组成 用于存储程序以及程序需要的数据
- 一个程序和他的数据在被cpu执行前必须移动计算机的内存中

- 每个字节都有一个唯一的地址 使用这个地址确定字节的位置 以便于存储和获取数据
<!-- 
  2000    01000011
  2001    01110010
 -->

- 一个计算机具有的ram越多 它的运行速度就越快 但是此规律是有限制的
- 内存与cpu一样 也构建在表面嵌有数百万晶体管的硅半导体芯片上 但内存芯片更简单 更低速 更便宜

<!-- 
      CPU         内存         硬盘

                              美女.jpg    二进制文件

  怎么将图片显示在屏幕上是要做运算的 并不是从硬盘直接到cpu 
  要想要cpu使用硬盘的数据 必须要将数据加载到 内存中

  cpu 只跟内存 进行交互 cpu的数据都是从内存中来来回回的读 再写到内存当中

  硬盘中的数据必须也要先加载到内存里面 
 -->

- 实测发现：
- 内存的读取数据的速度是硬盘读取速度的10倍 在某些环境里 硬盘和内存之间的速度差距可能会更大 而cpu的速度比内存不知道还要快多少倍

- 当我们把程序从硬盘放到内存以后 cpu就直接在内存运行程序 这样比cpu直接在硬盘运行程序要快很多

- 内存解决了一部分cpu运行过快 而硬盘数据存取太慢的问题 提供了我们电脑的运行速度 内存就如同一条高速车道 数据由传输速度较慢的硬盘通过这高速车道传送至cpu进行处理

- 但内存是带电存储的一旦断电数据就会消失 而且容量有限 所以要长时间存储程序或数据就需要使用硬盘

- 内存在这里起了两个作用
- 1. 保存硬盘读取的数据 提供给cpu使用
- 2. 保存cpu的一些临时执行结果 以便cpu下次使用或保存到硬盘

--------------------------------

### 输入与输出设备
- 常见的输入设备
  键盘 和 鼠标

- 常见的输出设备
  显示器 和 打印机

- 显示器屏幕分辨率：
  是指显示设备水平和垂直方向上显示的像素 px 
  分辨率可以手工设置
  分辨率越高 图像越锐化 越清晰

--------------------------------

### 万维网 因特网 互联网
- 关系
- 互联网 > 因特网 > 万维网
<!-- 
  万维网是无数个网络站点和网页的集合 他们在一起构成了因特网最主要的部分
  它实际上是多媒体的集合 是由超级链接连接而成的 我们通常通过网络浏览器上网观看的 就是万维网的内容

  万维网只是因特网最主要的一个部分 这里只说了 web客户端和web服务端
  因特网实际上还包含了 电子邮件 usenet以及新闻组

  互联网是最大的一个概念
 -->

--------------------------------

### 字符集
- 在计算机的底层都是2进制的 所有的汉字代码在底层存的时候 都是010101
- 比如
  一个 a 它是97
  一个 b 它是98
  一个 c 它是99

  我们将 97 98 99 用二进制去表示 传递给计算机底层
  当我们打开某个文件的时候 再通过某种字符集的方式再还原回去a b c

  我们如何将 a 对应成 2进制 再还原回来 中间的对应关系 就叫做字符集
  <!-- 
    Unicode 编码

    - 乱码
    - 世界上存在着多种编码方式 同一个二进制数字可以被解释成不同的符号 因此 要想打开一个文本文件 就必须知道它的编码方式 否则用错误的编码方式解读 就会出现乱码


    - unicode
    - 一种编码 将世界上所有的符号都纳入其中 每一个符号都给予一个独一无二的编码 使用 unicode没有乱码的问题


    - unicode的缺点
    - unicode只规定了符号的二进制代码 却没有规定这个二进制代码应该如何存储 无法区别unicode和asc2 

    - 计算机无法区分三个字节表示一个符号还是分别表示三个符号 另外我们知道 英文字母只用一个字节表示就够了 如果unicode统一规定 每个符号用三个或者四个字节表示 那么每个英文字母前必然有2到3个字节是0 这对存储空间来说是极大的浪费



    真正落地实施的是 utf-8
    它是unicode是一种实现方式 也是更大的一种字符集 它是一种边长的编码方式 它可以使用1-6个字节表示一个符号 根据不同的符号而变化字节的长度

    - utf-8的编码规则
    - 对于单字节的utf-8编码 该字节的最高位为0 其余7位用来对字符进行编码
    - 对于多字节的utf-8编码 如果编码包含n个字节 那么第一个字节的前n位为1
    - 第一个字节的n + 1位为0 该字节的剩余各位用来对字符进行编码 在第一个字节之后的所有字节 都是最高两位为 10 其余6位用来对字符进行编码
   -->