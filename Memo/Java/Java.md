### java版的hello world
- 1. 将 java 代码编写到扩展名为 .java 的文件中
- 2. 通过 javac 命令对象该文件进行编译

> javac Java文件名
- 将文件编译为字节码文件
- 语法不对就会编译不通过
<!-- 
  javac demo.java
  .java文件会被编译成 字节码文件(.class文件)
 -->

> java 字节码文件名(类名)不要后缀
- 执行字节码文件
- 3. 通过 java 命令对生成的class文件进行运行
- 这里注意 我们使用 java 运行字节码文件的时候不要加.class后缀
<!-- 
  java HelloChina
 -->

- 完整的步骤
<!-- 
  class HelloChina {
    public static void main(String[] args) {
      System.out.println("Hello, world");
    }
  }

  javac demo.java
  java HelloChina     // 这里没有后缀名 .class
 -->  


> 注意：
- 1. classpath的问题
  - 当我们使用 java HelloChina 去执行这个.class字节码文件的时候 可能会提示操作 找不到或无法加载主类 HelloChina

  - 这可能是我们配置过classpath 我们可能在网上看过 除了配置path环境变量之外还要配置classpath

  - 不用配置classpath， classpath就是.class字节码文件的path 如果我们配置了classpath就意味着 我们写 java HelloChina 的时候 会去classpath里面找 而实际上我们的字节码文件可能在别的位置上 所以会报错

  - 默认会在当前路径下找 .class 文件

- 2. java文件里面单词严格区别大小写
- 3. java文件里面执行语句后都要有分号
<!-- 
  System.out.println("Hello, world");
 -->

- 4. 一个源文件中是可以声明多个class类的 但是只能最多有一个类可以被声明为 public的
<!-- 
  public 用来修改这个类的权限大小
  同时 
  public关键字 只能加在和文件名同名的类前 类名和源文件名必须相同
  文件名为demo 那么public只能加在 demo类前 public class demo { }
 -->

- 5. 程序的入口是main()方法  格式是固定的
<!-- 
  class Hello {
    // main()方法
    public state void main(String[] args) {

    }
  }
 -->

- 6. 输出语句
>    System.out.println("")
- 该语法会在语句输出后 换行  先输出后换行
<!-- 
  System.out.println()    // 里面什么也不写的话 就是代表换行
 -->

> System.out.print("")
- 该语法不会换行

- 7. 每一条执行语句都以分号结尾
<!-- 
  技巧:
  从右往左看 除了 } 结尾的 剩下的都要以分号结尾
 -->

> System.currentTimeMillis()
-  它的返回值是 long型 的毫秒数
<!-- 
  long start = System.currentTimeMillis();
 -->


> 编译过程
- 编译以后 会生成一个或多个字节码文件 有几个类就会有几个字节码文件
- 字节码文件的文件名与java源文件中的类名相同


> 特性
- 面向对象性：
  两个要素: 类 对象
  三个特征: 封装 继承 多态

- 健壮性:
- 去除了c语言中的指针 有了自动的垃圾回收机制

- 跨平台性
- 功劳公共与 jvm 我们现在使用的虚拟机是 hotspot

----------------------------

### 注释
- 用于注解说明解释程序的文字就是注释
- java中的注释类型

> 单行注释  //

> 多行注释  /* */

> 文档注释(java特有)
- 语法：
  /**

  */

- 注释内容可以被JDK提供的工具 javadoc 所解析 生成一套以网页文件形式体现的该程序的说明文档

- javadoc 解析的类 类前要加上 public
- javadoc 只能解析 文档注释标记起来的内容
<!-- 
  /** 
    文档注释
    @author: sam
    @version: v1.0
    
    这是我的第一个程序
  */
  public class Demo { ... }
 -->

> 执行命令
- javac -d 文件名字 -author -version 文件名.java
- 生成的文件夹会在当前目录
- -author -version对应着@author @version

----------------------------

### 关键字 和 保留字

> 关键字
- 定义:
- 被java语言赋予了特殊的含义 用作专门用途的字符串

- 特点
- 关键字中所有字母都为小写

- 网址
- https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keyword.html

<!-- 
  用于定义数据类型的关键字

    class     interface     enum      byte      short
    int       long          float     double   char
    boolean   void



  用于定义流程控制的关键字

    if      else    switch    case    default
    while   do      for       break   continue
    return



  用于定义访问权限修饰符的关键字

    private   protected   public



  用于定义类 函数 变量修饰符的关键字

    abstract    final   static    synchronized


  
  用于定义类与类之间关系的关键字

    extends   implements


  
  用于定义建立实例及引用实例 判断实例的关键字

    new     this      super     instanceof



  用于包的关键字

    package   import



  其他修饰符关键字

    native    strictfp    transjent   volatile    assert



  用于定义数据类型值的字面值    下面的三个不算关键字 但还可以当做关注字

    true    false   null
 -->


> 保留字
- 现有java版本尚未使用 但以后版本可能会作为关键字使用 自己命名标识符时要避免使用这些保留字
<!-- goto const 等 -->

----------------------------

### 标识符
- java对各种变量 方法 和 类等要素命名时使用的 字符序列(单词) 被称为标识符
- 总的来说 凡事自己可以起名字的地方都叫做标识符

> 定义合法标识符规则
- 26个英文字母大小写 0-9 _ $ 组成
- 数字不可以开头
- 不可以使用关键字和保留字 但能包含关键字和保留字
- java中严格区分大小写 长度无限制
- 标识符不能包含空格


> 命名规范
- 包名
- 多单词组成时所有字母都小写 xxxyyyzzz

- 类名 接口名 大驼峰
- 多单词组成时 第一个单词首字母小写 第二个单词开始每个单词首字母大写 XxxYyyZzz

- 变量名 方法名 小驼峰
- 多单词组成时 第一个单词首字母小写 第二个单词开始每个单词首字母大写 xxxYyyZzz

- 常量名
- 所有字母都大写，多单词时每个单词用下划线连接 XXX_YYY_ZZZ

**注意：**
- 如果不遵守如上的规则 编译可以通过 编译能通过 运行也没有问题 但建议遵守
 
----------------------------

### 变量

> 变量的概念
- 内存中的一个存储区域
- 该区域的数据可以在同一类型范围内不断变化
- 变量是程序中最基本的存储单环 包含变量类型 变量名 存储的值


> 变量的作用
- 用在内存中保存数据


> 使用变量的注意
- 1. java中每个变量必须先声明 后使用
- 2. 使用变量名来访问这块区域的数据

- 3. 变量的作用域：
    其定义所在的一对{ }内

- 4. 变量只有在其作用域内才有效
- 5. 同一个作用域内 不能定义重名的变量


> 数据类型 变量名 = 变量值
- java定义变量的格式
<!-- 
  // 整型
    int myNum = 666;
    
  // 或者还可以这么写
    int myAge;
    myAge = 18;
 -->

**注意：**
- 1. 变量必须要赋初始值
- 2. 变量必须先声明后使用 注意书写顺序
- 3. 变量有作用域 在作用域内有效
- 4. 同一个作用域内 不能声明同名变量
<!-- 
  int myAge;
  System.out.println(myAge);    // 错误: 可能尚未初始化变量myAge
 -->


> 变量的类型 --- 按照类型区分
- 数据类型分为两类
- 1. 基本数据类型
    - 数值型
        - 整数类型(byte, short, int, long)  百特
        <!-- 存储空间是从小到大来的 -->

        - 浮点类型(float, double)

    - 字符型(char)

    - 布尔型(boolean)


- 2. 引用数据类型
    - 类(class)
    <!-- 
      java里字符串是一个 类 的类型 也就是引用类型
      同时我们存大量的字符的时候 好像也没有办法使用char 因为老师这意思char里只能装一个字符
     -->

    - 接口(interface)

    - 数组([])


> 变量的类型 --- 在类中声明的位置(面向对象的时候会详细讲)
    - 成员变量
    - 局部变量

- 补充知识：
- 在方法体外 类体内 声明的变量成为 成员变量
- 在方法体内       声明的变量成为 局部变量
<!--          
                      实例变量 -- 不以static修饰
            成员变量
                      类变量   -- 以static修饰
  所有变量

                      形参(方法 构造器中定义的变量)
            局部变量   方法局部变量 (在方法内定义)   
                      代码块局部变量 (在代码块内定义)

  注意：
  两者在初始化值方面的异同

  同：都有生命周期
  异：局部变量除形参外 需显示初始化
 -->

    
> 基本数据类型的使用 -- 整型
- 表示整数的 正负都可以 java中定义了4中整型 区别就是它们占用的空间不一样
- java各整数类型有固定的表数范围和字段长度 不受具体os的影响 以保证java程序的可移植性

- java的整型常量默认为int型 

- 声明long型常量必须加  l 或 L
<!-- 
  在使用long型的时候 必须以小写l 或者 大写L结尾
  long num = 345223L;  
  输出结果不会带有L
 -->

- java程序中变量通常声明为int 除非不足以表示较大的数 才用long


- 类型        占用存储空间      表数范围
- byte        1字节=8bit位    -128 ~ 127
- short       2字节           -2^15 ~ 2^15-1
- int         4字节           -2^31 ~ 2^31-1(约21亿)
- long        8字节           -2^63 ~ 2^63-1

- byte：
<!-- 
  从存储上讲是最小的单位 1字节=8bit 一个bit存0或者存1 两种情况 一共8个 所以byte一共有多少中组合方式 2^8=256 

  所以一个byte能表示256个数 0~255，但是这么表示就没有负数了 所以就是-128~127 加起来就是256
 -->

- short:
<!-- 
  它是byte的倍 也就是 2^16 
  那我们也分一半 就变成了 -2^15 ~ 2^15-1  因为还有一个0
 -->

- int   是 short 的2倍
- long  是 int 的2倍

<!-- 
  byte b1 = 12;
  byte b2 = -128;
  // b2 = 128;     编译不通过 超出范围了 -128 ~ 127

  // 声明long型变量 必须以"l" or "L"结尾
  long b3 = 234234234L;     // 234234234

  System.out.println(b1);
  System.out.println(b2);
  System.out.println(b3);
 -->

----------------

> 基本数据类型的使用 -- 浮点型
- 通俗的讲就是带有小数点
- 与证书类型类似 java浮点类型也有固定的表数范围和字段长度 不受具体操作系统的影响

- 浮点型常量有两种表示形式

    - 十进制数形式: 
        - 5.12    512.0f    .512(必须有小数点)

    - 科学计数法形式:
        - 5.12e2  512E2   100E-2

- float:  单精度 尾数可以精确到7位有效数字 很多情况下精度很难满足需求
<!-- 
  float存储数据量不仅少 精度也有限
  float表示数值的范围比long还大
 -->

- double: 双精度 精度是float的两步 通常采用此类型
<!-- 
  double存储数据量不仅多 精度也高
 -->

- 通常定义浮点型变量时 使用 double型

- 声明 float型 常量 结尾必须加 "f" 或 "F"


- 类型            占用存储空间      表数范围
- 单精度 float     4字节            -3.403E38 ~ 3.403E38
- 双精度 double    8字节            -1.798E308 ~ 1.798E308

- 这里的E指的是10 - E38 -> 10^38

<!-- 
  double b4 = 11.03;

  // 定义float型时  变量要以 F 结尾
  float d5 = 12.4F;
 -->

----------------

> 基本数据类型的使用 -- 字符类型(只能声明一个字符)
- char型数据用来表示通常意义上的 1字符(2字节)
- 用处：
- 声明一个字符

- 1个字符 = 2个字节
- char会占用16个bit

- 通过 char型 定义的变量 只能定义一个字符
<!-- 
  char c1 = 'a'
  c1 = 'AB'   // 这里不能写两个 因为这相当于两个字符

  比如我们要是想定义 “张三” 这时候就不能使用char型 而是要使用字符串型
 -->

- java中的所有字符都使用unicode编码 故一个字符可以存储一个字母 一个汉字 或者其它书面语的一个字符

- 字符型 变量的三种表现形式


> char型的使用方式 
- 单引号('')括起来的单个字符 但是内部有且只能放一个少了多了都不行 
- char型里面必须要有值 为空报错
<!-- 
  char a = '';     报错
  char a = ' ';    这可以
 -->

- 比如：
  char c1 = 'a';
  char c2 = '中';
  char c3 = '9';

- java中还允许使用转义字符 “\” 来将其后的字符转变为特殊字符型变量
- 例如
  char c4 = '\n';    \n表示换行符 \t制表符

- 直接使用 Unicode 值来表示字符型常量
- 比如
  char c5 = '\u0043'
  代表一个十六进制整数 底层输出一个数的时候 也对应一个字符

**char类型是可以进行运算的 因为它都对应有 Unicode 码**

- 这里注意：
- 命令行默认是使用系统的编码格式解析的 比如我们中国电脑的系统默认格式为gbk
- 当我们将编码格式改为utf-8的时候 打印中文的时候可能会出现乱码
- 我们要保证 写入 和 读取 时候的字符集是同一个

----------------

> 基本数据类型的使用 -- 布尔型
- 布尔型只能有两个值

  boolean b1 = true;

- 我们常常在条件判断 循环结构中使用
<!-- 
  boolean b1 = true
  if(b1) {
    System.out.println("你就不能参\'单身派对\'了")
  } else {
    System.out.println("你有女朋友了")
  }
 -->

----------------------------

### 基本数据类型转换
- 我们下面说的运算包括 运算 和 赋值， 也就是说赋值也是运算的一种情况

> 自动类型提升:
- 容量小的类型 自动转换为 容量大的数据类型
- 数据类型按容量大小排序为
<!-- 
  byte
  char    -- int -- long -- float -- double
  short
 -->

**注意:**
- byte, char, short 相互之间做运算的话 结果的类型都应该取 int


> 定义：
- 有多种类型的数据混合运算时 系统首先自动将所有数据转换成容量最大的那种数据类型 然后在进行计算

- 当表数范围小 和 表数范围大 的变量进行运算的时候 结果自动提升为表数范围大的类型(比如一个byte 一个int 那么计算结果要取int 或 以上)
<!-- 
  表数范围小: byte 一个字节 8bit
  表数范围大: int  四个字节 32bit

  当它们进行运算的时候 res 的类型就是int 因为类型会自动提升到 表数范围大的类型上

  byte b1 = 2;
  int i1 = 13;

  int res = b1 + i1;
  System.out.println(res);  // 15

  也就是 在取两个类型结果的时候 我们要定义什么类型去接收这个结果(res)

  我们也可以定义 long 来接收
  long res = b1 + i1;     // 15

  我们也可以定义 float 来接收
  float res = b1 + i1;    // 15.0  结果会补个0
 -->

- 一个表数范围小的类型 赋值给 表数范围大的类型 也没有问题
<!-- 
  short num = 1;
  double number = num;
 -->

- 说明
- 此时的容量大熊啊指的是 表示数的范围的大和小 不是指占用的内存空间
- 比如 float容量要大于long容量

----------------

> char型运算
- char型时可以做运算的 
<!-- 
  // char型的变量 对应着 unicode 码
  char str = 'a';  // 97
  int num = 8;

  int res = str + num;

  System.out.println(res);    // 105
 -->


> 总结
- 强制类型转换 是 自动类型提升 的逆过程
<!-- 
  其中 boolean 不能与其它类型进行运算 因为它只有true 和 false
  java中true 就是 true false 就是 false 不能像js那样 0 1
  所以下面中 我们所提到的 自动类型提升 不包括 布尔型

  byte short int long 可以做运算因为它们是数值
  char 能做运算 因为它的unicode对应着一个编码 比如 a 对应 97 97可以做运算
 -->
      

**注意:**
- byte short char 之间不会相互转换 他们三者在计算时首先转换为int类型
<!-- 
  byte    ↘
  short     →   int
  char    ↗
 -->

**boolean类型不能与其它数据类型运算**
- 当把任何基本数据类型的值 和 字符串(String)进行连接运算时(+) 基本数据类型的值将自动转化为字符串(String)类型

**注意:**
- boolean类型不可以转换为其它的数据类型

----------------

> 强制类型转换
- 自动类型提升的逆运算，将容量大的数据类型转换为容量小的数据类型
<!-- 
  正常来说两个基本类型变量间运算的时候 容量小的会自动提升为容量大的数据类型
  但是我们有的时候就希望
  运算后的结果的类型是容量小的那个类型
 -->

- 场景：
<!-- 
  比如数据库中会存放很多的表有一张用户的表中的数据有10万条 
  我们使sql查询这个表有多少条记录 它会返回一个值 默认情况下 我们查询这个表的数据有多少 它会返回一个long型的结果(它怕int装不下)

  但是我们在java里面就想拿int去接收这个数 这时候就需要将long型强制转换为int型 这时候我们就需要使用强转符
 -->

 ----------------

> 强制转换符: ()
> 使用方式: 要使用哪种类型接收 变量 = (指定要转成哪种类型)变量
<!-- 
  // 目标 我们定义一个double类型的变量 就用int来接收
  double num = 12.3;

  // 使用强转符 内部指定要强制转换为什么类型
  int number = (int)num;

  // 我们使用的是int来接收 int是整型 所以是12 即使num是12.9 接收后也是12
  这种现象叫做截断
  System.out.println(number);    // 12


  还有一种情况 下面这种情况也算精度损失 至于为什么是-128等到2进制的时候我们再来看
  int i = 128;
  byte b = (byte)i

  System.out.println(b)   // -128
 -->

- 上面我们能看到本身这个数据是12.9但是转换后精度降低变成12了 这种现象叫做损失精度


> 扩展:
- 通常 字符串不能直接转换为基本类型 但通过基本类型对应的包装类则可以实现把字符串转换为基本类型
<!-- 
  String a = "43"; int i = Integet.parseInt(a);
 -->


> 变量运算规则的两种特殊情况
- 1. 上面说了定义 long型 变量 数值的后面要加上L
- 但是有的时候 我们在编译 long型 变量的时候 后面不加L 能编译也不报错
<!-- 
  long i = 123333;    
      结尾没加L 这是这个123333就会被认为是 int 型
      int型赋值给long 相当于自动类型提升了

  当 123333这个部分要是超出int的表数范围就会报错 这时候我们就要加上L
  int是4个字节
  long是8个字节
 -->

- float型一定要加F 不然编译都会不通过x
<!-- 
  float f = 12.3;   
    这里不加F的话 12.3会默认为double 这时double转为float就会报错了
    上面是 int 转为 long 属于自动提升
 -->

- 2. 我们看下下面的情况
<!-- 
  定义一个byte
  byte num = 12
  byte res = num + 1    报错

  我们定义了一个byte 然后让它 + 1  然后我们试着用byte型变量去接收 就会提示错误

  上面的1我们看做是一个常量 不像是变量可以不断的变化值 对于整型的常量来将默认的是int型
 -->

> 总结:
- 1. 对于整型常量   默认为 int 型
- 2. 对于浮点型常量 默认为 double 型

----------------------------

### 字符串类型: String 引用类型的变量
- String不是基本数据类型 属于引用数据类型 
- String定义的数值使用""包裹 不是单引号 这里要跟char型区分开
<!-- 
  我的天啊 在js里 字符串是基本数据类型 但是这里竟然是引用数据类型
 -->

> 使用方式:
- String 变量 = “值”
- 使用方式 与 基本数据类型一致
<!-- 
  // 下面的情况都可以
  String str = "hello";
  String str = "a";
  String str = "";

  System.out.println(str);
      这里要注意 System.out.println("hello"); 这里相当于输出的是一个常量
 -->

 ----------------

> String 和 8种基本数据类型之间的运算
- String可以 和 8种基本数据类型做运算(包括 boolean) 且运算只能是 + (连接运算)
- 相当于跟其它类型的结果拼接成字符串(拼接的结果的类型也是 String )
<!-- 
  String str = "学号";
  int num = 1001;

  // 只能是连接运算 同时接受变量的类型也是 String
  String info = str + num;

  System.out.println(info);
 -->

**是不是说每一种变量都要指定类型？**

- 我们在程序中怎么判断+是字符串的连接还是 运算的+ 
- 我们就看 + 的前后有没有String

----------------

> 练习
- 要点: 
- char型做运算的时候会对应 asn2码 所以会是正常的数字
<!-- 
  // 终端输出 * *
  System.out.println("* *");              // * *
  System.out.println('*' + '\t' + '*');   // 93  char对应asn2码 会做运算
  System.out.println('*' + "\t" + '*');   // * *  
  System.out.println('*' + ('\t' + "*")); // * *
  System.out.println('*' + '\t' + "*");   // 51*
 -->


- 判断
- 要点
- 3.5f 在做字符串拼接的时候 f也是没有的
<!-- 
  String str1 = 4           // 不对  因为String要想使用的时候必须用“”引起来
  
  String str2 = 3.5f + ""   // "3.5"
  
 -->

----------------------------

### 不同进制表示的方式
- 所有数字在计算机底层都以 二进制 形式存在
- java整数常量默认是int类型
- 二进制默认占64位 第64位是符号位

- 二进制的整数有如下的三种形式


> 原码
- 直接将一个数值 换成二进制数 最高位是符号位


> 负数的反码
- 是对原码按位取反 只是最高位(符号位)确定为1


> 负数的补码
- 起反码加1


**总结**
- 计算机以二进制补码的形式保存所有的整数
- 正数的原码 反码 补码都相同
- 负数的补码是反码+1

----------------

> 对于整数 有四种表示方式
- 1. 二进制(binary): 0, 1
    满2进1， 以0b 或 0B 开头

- 2. 十进制(decimal): 0-9
    满10进1

- 3. 八进制(octal): 0-7
    满8进1 以数字0开头表示

- 4. 十六进制(hex): 0-9 and A-F
    满16进1 以0x或0X开头表示
    此处的A-F不区分大小写 如: 0x21AF + 1 = 0X21B0

<!-- 
  打印结果都是10进制
  int num1 = 0b110;     // 0b开头  是2进制    6
  int num2 = 110;       //                  110
  int num3 = 0127;      // 0开头   是8进制    87
  int num4 = 0x110A;    // 0x开头  是16进制   4362

  System.out.println("num1 = " + num1);
  System.out.println("num2 = " + num2);
  System.out.println("num3 = " + num3);
  System.out.println("num4 = " + num4);
 -->

----------------

> 符号位
- 一个2进制的数的最高位(最左侧的位数) 称之为符号位
- 该符号位 如果是0 就表示正数
- 该符号位 如果是1 就表示负数
<!-- 
  0 0 0 0 1 1 1 0     byte - 正数   因为左侧的符号位为0

  1 0 0 0 1 1 1 0   - 负数
 -->

----------------

> 2进制 转换为 10进制
- 正数的原码 补码 反码是一样的 所以 一个正数的二进制数 你叫做原码 补码 反码都可以
- 三码合一

- 演示：
<!-- 
    我们定义一个byte --- 为一个bit

    --- --- --- --- --- --- --- --- 
    0   0   0   0   0   1   1   0       = 6

    从右往左看 第一位是第0位 第二位是第1位
 -->

----------------

> 正数的 2进制转为10进制的 技巧：
- 1000 = 8
- 每一位就是 2^几次幂 比如第0位就是 2^0
- 然后我们看看当前位是0 还是 1 
- 如果是1 就是 1*2^0
- 如果是0 就是 0*2^0

- 最后我们进行累加
- 1110 = 1*2^3 + 1*2^2 + 1*2^1 + 0*2^0 = 14(10进制的14)
<!-- 
  0 1 1 0 1 1 1 0
  2^6 + 2^5 + 2^3 + 2^2 + 2^1  
 -->

----------------

> 二进制中的负数
- 我们拿到负数的时候 首先要关心我们拿到的是负数的原码 负数的反码 还是 负数的补码

- 负数的原码:
- 将正数的最高位改成1 就是该负数的原码
<!-- 
  00001110 是正数 上面我们计算的结果是 14
  10001110 是负数 我们可以叫他 -14 的原码
 -->

- 反码
- 我们拿到了负数的原码后 除了符号位 各个位取反 结果就是反码
<!-- 
  00001110    正数 14
  10001110    负数 -14 的原码

  11110001    负数 -14 的反码
 -->

- 补码
- 我们拿到了反码 在反码的基础上加1
<!-- 不是每一位+1 就是最右侧的位数加1 -->
<!-- 
  11110001  负数-14的反码

  11110001 + 1 
  11110010  负数-14的补码
 -->

- 计算机的底层都以补码的方式存储数据 不管是正数还是负数
- 为了得到补码才需要原码和反码 之后就可以不要它们了

<!-- 
  10111011 这是10进制的几？
  首先这一定是补码 默认就是补码 其它两码没有用

  10111011 - 1 = 10111010(反码) = 11000101(原码) = 69

  ---

  正127 byte类型最大8bit 01111111

  +127  01111111
  -127  11111111  原码
  -127  10000000  反码
  -127  10000001  补码  底层-127 就是这样

  -128长啥样
  10000001 - 1 = 10000000 底层-128
 -->

- 上面我们接触过一个案例 我们将int类型的数据 强制转换为 byte类型的数据的时候 会发现原来的128 竟然变成了 -128 这是为什么?
<!-- 
  int i = 128;
  byte b = (byte)i;

  System.out.println(b)   // -128


  int是32位的 我们强制转换为byte后就剩 1000 0000了 然后这个输出后就是-128

  1000 0000在int里面1不是符号位 而转换为byte后就变成符号位了
 -->

----------------------------

### 10进制如何转为2进制
- 技巧:
- 除2取余的逆

- 案例
- 13的2进制是多少？
<!-- 
  13 / 2 = 商6余1
  商6 / 2 = 商3余0
  商3 / 2 = 商1余1
  商1 / 2 = 商0余1
  商0 / 2 = 商0余0    从下往上看 0不算 取逆 1101
 -->

- 总结：
- 这个数除以2 看余数商继续除以2 递归 结果从下往上看 就是 2进制


> 那2 8 10 16进制之间怎么转换？
- 进制的基本转换

----------------

> 十进制 二进制互转
- 二进制转成十进制 乘以2的基数
- 十进制转成二进制 除以2取余数

----------------

> 二进制 和 八进制 十六进制
- 因为八进制恰好是二进制的三次幂 十六进制是二进制的四次幂
- 所以

> 2进制 -> 8 16进制
<!-- 
  000 000 011 101 001

          3    5    1

  八进制就是0351
  因为8是2的3次幂 所以我们将2进制中每3位算出一个数字


  十六进制就是每4位算出一个数字
  1110 1001
     E    9

  十六进制就是 0xE9
-->

----------------

> 8 16进制 -> 2进制
- 08进制就拿出每一位数字 拆成3位 01组成的
- 16进制就拿出每一位数字 拆成4位 01组成的


- 思路
- 上面我们了解了 二进制和十进制之间的转换 那我们再知道二进制和八进制 和 十六进制之间如何转换
- 我们再在这几个进制之间转换的时候 就可以通过二进制过渡下再得到结果 

----------------------------

### 运算符
- 运算符是一种特殊的符号 用以表示数据的运算 赋值 和 比较等
- 1. 算术运算符
- 2. 赋值运算符
- 3. 比较运算符 或者叫 关系运算符
- 4. 逻辑运算符
- 5. 位运算符(开发的时候用的比较少)
- 6. 三元运算符


### 算术运算符
- 这个部分很常见 我们下面先拿除法来举例子

> 除法
- 12 / 5  --- 除法简单说理解就是将一个数分成几份
<!-- 
  1. int型在除不尽的时候 小数部分会省略
  int num1 = 12;
  int num2 = 5;

  int res = num1 / num2;          // 2
  int res = num1 / num2 * num2;   // 10

  --------

  2. 
  - 思考：
  - 12 / 5 我们就想得到比较精确地结果应该怎么做？

  - 方法1:
  - 我们定义一个double型 接收 两个int型的结果可以么? -- 不行！！
  - 因为num1 / num2先是int的结果已经是2了 然后赋值给double 所以是2.0
    double res = num1 / num2;     // 2.0


  - 方法2:
  - 先利用 + 将num2的结果转为浮点型结果 然后num1 与 浮点型进行运算结果会类型提升到double型
  - double res = num1 / (num2 + 0.0);   // 2.4


  - 方法3:
  - 利用强制类型转换 得到我们想要得结果
  - double res = (double)num1 / num2;

 -->

----------------

> 取模 %
- 结论:
- 结果的符号(是+ 还是-) 跟被模数(n % m, n就是被模数)的符号相同
<!-- 
  int m = -12
  int n = 5

  int res = m % n     // -2
 -->

**技巧**
- a % b 的结果是 0 到 b - 1
- 比如 12 % 5 结果不会超过5 为 0 到 4
<!-- 
  a % 1 的结果肯定是0 
  1. 因为不可能超过1 
  2. 任何数/1都会除尽
 -->

----------------

> ++n, 先运算后取值  - 先自增1 然后再运算
> n++, 先取值后运算  - 先运算  然后再自增1
- 不管是++n 还是 n++ 都表示变量自增1
- 区别是 它们在涉及到运算的时候 是先自增 还是先运算

> 注意： 自增1 不会改变它原本变量的数据类型
<!-- 
  int a = 10;
  int b = ++a;

  System.out.println("a = " + a + ", b = " + b);     // 11 11

-----

  int a1 = 10;
  int b1 = a1++;

  System.out.println("a1 = " + a1 + ", b1 = " + b1); // 11 10

-----

  对于a来讲 不管是++n 还是n++ 都是自增1

-----

  int a = 10;
  a++;  or  ++a;    这里都自增1了
  int b = a;

  System.out.println("a = " + a + "b = " + b);   // b： 11
-->

**注意：**
- 我们在使用的时候可能会出现这种情况
- 定义一个short型变量10 然后让它变成11
<!-- 
  short a = 10;
  a = a + 1;

  编译报错:
  常量1会被当成整型int 这样运算会类型自动提升为int 再将结果赋值给原先的 short型的a 就会编译报错
 -->

- 那应该怎么解决？
- 强转就是截断
<!-- 
  a = (short)(a + 1);
 -->

- 或者让数字自增1 自增运算不会改变原本数据的数据类型

- 假如我们定义一个byte 127 让这个变量自增 结果会怎么样
<!-- 
  byte a = 127;
  a++;

  System.out.println(a);    -128

  01111111...   127 正数 除了符号位是0 其余位是1 然后 +1  进位
  10000000...   符号位为1 其余是0 就是 -128 呗
 -->

----------------

> 练习:
- 随意给出一个整数 打印显示它的个位数 十位数 百位数的值
- 格式：
- 数字 xxx 的情况如下
- 个位数: 
- 十位数: 
- 百位数: 

- 例如
- 数字 153 的情况如下:
- 个位数: 3
- 十位数: 5
- 百位数: 1
<!-- 
  int num = 187;

  int bai = num / 100;

  int shi = num % 100 / 10;     方式1
  int shi = num / 10 % 10;      方式2

  int ge = num % 10;


  百位逻辑:
  187 / 100 = 1.87 int 取整 1

  十位逻辑:
  187 % 100 = 87  --  87 / 10 int 取整 8

  个位逻辑
  187 % 10 = 7

  System.out.println("百位为: " + bai);
  System.out.println("十位为: " + shi);
  System.out.println("个位为: " + ge);
 -->

----------------

> 符号 = 
- 当 = 两则数据类型不一致的时候可以使用自动类型转换 或 使用强制类型转换原则进行处理


- 支持连续赋值
<!-- 
  先分别定义 再连续赋值
  int num, num1;
  num = num1 = 10;


   同时定义多个变量(共用一个类型)
   int num = 10, num2 = 20;
 -->

----------------

> 扩展赋值运算符:
- += -= *= /= %=
- 要点:
- 利用这样的形式 去运算不会改变该变量的类型
<!-- 
  int num = 10;
  num += 2;   // num = num + 2  // 12
  num %= 2;   // num = num % 2  // 0

  -----

  之前我们知道 如果这样写的话会 编译不通过
  short num = 10;
  num = num + 2;    因为2被看成一个int
      解决方式 或者用int接收 或者 强转为short

  我们还可以这样:
  short num = 10;
  num += 2;       这样编译可以通过结果正常 因为这样写不会改变原类型
 -->


- 在开发中 如果希望变量实现+2的操作 有几种方法 int = 10;
- 1. num = num + 2;
- 2. num += 2; (推荐 因为不会改变数据类型)
<!-- 
  int的时候感觉不出来 当不是int类型的时候 一定是这种方式是最好的
 -->


> 练习：
- 1. 
<!-- 
  int i = 1;
  i *= 0.1;     // *=不会改变原变量的类型 所以还是int 结果是0
  System.out.println(i);
 -->

- 2. 
<!-- 
  int n = 2;
  int m = 3;
  n *= m++;

  System.out.println(n)   // 6
  System.out.println(m)   // 4
 -->

- 3. 
<!-- 
  int n = 10;
  n += (n++) + (++n);
  System.out.println(n);  // 32

  解析：
  n = n + (n++) + (++n)
      10 + 10(原值) + 12(前面n自加了一次是11， 然后++n是新值就为12)
 -->

----------------

### 比较运算符
- 比较运算符的结果都是boolean型 也就是要么是true 要么是false

> == != < > <= >= instanceof

> instanceof
- 检查是否是类的对象
<!-- 
  "hello" instanceof String    // true
 -->


----------------------------

### 逻辑运算符
- 逻辑运算符只适用布尔类型的变量
- 在高一的时候 都会将集合的概念 或 且 非
<!-- 
  或: 都行的意思 
  且: 必须都满足 取交集的意思
  非: 就是取补集的意思
 -->

- &    逻辑与
- &&   短路与

- |    逻辑或
- ||   短路或

- ！    逻辑非
- ^    逻辑异或
- 理解方式:
- 我希望a b它们是异(不一样) 当不一样的结果的时候 运算结果就是true
<!-- 
  当 a 和 b 相同的时候 结果是 false
  当 a 和 b 不同的时候 结果是 true

  a = true
  b = true
  a ^ b    // false
 -->

 > 短路的概念
 - 这里扩展一下高中的物理概念
 <!-- 

    ---- x -----
    |           |
    ------。↗ ---
    - 当我们合上开关的时候 小灯泡会亮


      ↗ → → ↘
    -↗-- x --↘--
    |           |
    ------。↗ ---
    - 这种情况下 即使我们合上开关 小灯泡也不会亮 因为线路绕过小灯泡了

  - 结合上面的知识点 我们再看看 false && true
  - 如果第一个值为false 相当于绕过了第二个值
  -->

> &&
- 只有前后都是true的时候结果才是true
<!-- 
  boolean b = false;
  int num = 10;
  if(b && (num++ > 0)) { ... }


  如果 b 是false 那么条件2 就不重要了 因为短路了
  如果 b 是true  要需要看条件2的值

  结合js中的知识点 && 中 如果条件1为true 会检查条件2
 -->


> & and &&
- 例子：
- 下面的例子主要观察 & 和 &&

- js中没有&
- 它们都是代表逻辑 区别在于
- 当条件1为false的时候
- &  会执行    条件2
- && 不会执行  条件2
<!-- 
  boolean b = true;
  b = false;
  int num = 10;
  if(b & (num++ > 0)) {
    System.out.println("我现在在北京");
  } else {
    System.out.println("我现在在南京");
  }

  boolean b1 = true;
  b1 = false;
  int num1 = 10;
  if(b1 && (num1++ > 0)) {
    System.out.println("我现在在北京");
  } else {
    System.out.println("我现在在南京");
  }
 -->

- 总结：
- 相同点
- 我们不管使用的是单& 还是双&& 运算结果都是相同的 都是只有条件1 条件2都满足的时候才会是true
- 1. & 与 && 的运算结果相同
- 2. 当符号左边是true的时候, 二者都会执行符号右边的运算


- 不同点:
- 当符号左边是false的时候, 单&会继续执行右边条件2的运算, 双&就不再执行符号右边条件2的运算了


> | && ||
<!-- 
  boolean b = false;
  int num = 10;
  if(b | (num++ > 0)) 
  if(b1 || (num++ > 0)) 

    b 和 b1 都是false 所以整体结果是什么 都要看条件2的



  boolean b = true;
  int num = 10;
  if(b | (num++ > 0)) 
  if(b1 || (num++ > 0)) 

    b 和 b1 都是true | 还会看条件2的 但是短路|| 就不会看条件2了 因为已经是true了
 -->

 - 结论
- 相同点:
- 1. | 与 || 的运算结果相同
- 2. 当符号左边是false的时候, 二者都会执行符号右边的运算


- 不同点:
- 当符号左边是true的时候, 单|会继续执行右边条件2的运算, 双||就不再执行符号右边条件2的运算了
<!-- 
  参考js资料:
    - 如果第一个表达式的值为真, 则返回表达式1
    - 如果第一个表达式的值为假, 则返回表达式2
 -->


> 总结
- 上面的单 还是 双都没有区别 但是在开发的时候 我们选择单还是双呢？
- 我们在开发的时候 优先使用短路的 也就是 双&& ||

----------------

> 练习：
- 1. 
- 要点:
- if(条件这里是否会运行 或者说 是否会影响到结果)
- 虽然是条件 但是程序还是运行这里了 所以相应在输出的时候 值也会发生变化
- 只是走不走大括号里面的逻辑 是要看条件是否成立
<!-- 
  int x = 1;
  int y = 1;

  if(x++ == 2 & ++y ==2) {
    x = 7;
  }

  System.out.println(x + ", " +  y);    // 2 2
 -->


- 2. 
- 要点:
- if(条件里面的运算是会运行的 会影响到其它的变量)
<!-- 
  boolean x = true;
  boolean y = false;
  short z = 42;
  if((z++ == 42) && (y = true)) z++;
  if((x = false) || (++z == 45)) z++;

  System.out.println("z= " + z);

  解析：
  if((z++ == 42) && (y = true)) z++;
  z++是旧值是42   --  true
  y被修改为       --  true
  所以 z++ 也会执行 这里 z++包括条件里面的 一共是2次 到这里z为44


  if((x = false) || (++z == 45)) z++;
  x为false会看条件2 ++z是新值 45 条件2里等式成立 会运行最后的z++ 

   所以结果是46
 -->

----------------

> 位运算符
- 我们看到这里的时候先不用看注释的部分 先看下面 回头在看注释里总结的部分

- <<      左移        3 << 2 = 12  -- 3*2*2 = 12
<!-- 
  空位补0， 被移除的高位丢弃 空缺位补0
 -->

- >>      右移        3 >> 1 = 1   -- 3 / 2 = 1
<!-- 
  被移位的二进制最高位是0 右移后 空缺位补0
  最高位是1 空缺位补1
 -->

- >>>     无符号右移   3 >>> 1 = 1  -- 3 /2 = 1
<!-- 
  被移位二进制最高位无论是0 或者 1 空缺位都用0补
 -->

- &       与运算      6 & 3 = 2
<!-- 
  二进制位进行 & 运算 只有 1&1时 结果是1  否则是0
 -->

- |       或运算      6 | 3 = 7
<!-- 
  二进制位进行 | 运算 只有 0|0时 结果是0 否则是1
 -->

- ^       异或运算    6 ^ 3 = 5
<!-- 
  相同二进制位进行 ^ 运算 结果是0  1^1=0    0^0=0
  不相同二进制位进行 ^ 运算 结果是 1^0=1    0^1=1
 -->

- ~       取反运算    ~6 = -7
<!--  
  正数取反 各二进制码按补码各位取反
  负数取反 各二进制码按补码各位取反
 -->

- 位运算是直接对 整数 的二进制进行的运算
- 位运算操作的都是数值 而其结果也是一个数值
<!-- 
  这里注意是对 整数 的二进制
  没有对小数 也就是浮点型的数字进行左右移动的
 -->

- 但是用的频率比较低

> << 左移
- 例子： 
- int num = 21；
<!-- 
  0000 0000 0000 0000 0000 0000 0001 0101

  num << 2    左移两位
  相当于左边出去两位 右边就需要补2位 拿0补
    0000 0000 0000 0000 0000 0000 0001 0101
  0000 0000 0000 0000 0000 0000 0001 010100

  原先：
  10101     对应着  2^4  2^2  2^0  它们相加为21

  现在
  1010100   对应着  2^6  2^4  2^2

  首先我们会发现规律：
  1. 左移两位 幂发生了变化 幂数 + 2了
  2. 实际上相当于原先的结果( 2^4  2^2  2^0 ) 21 再乘以 2^2

  也就是说 21 * 4 = 84


  - 那要是向左移3位呢？ num << 3 ? 
  - 那是不是说 21 * 2^3 = 168   对
 -->

> << 左移 结论
- 每向左移动一位 相当于在原来的基础上 乘以2
- 每向左移动几位 相当于用原来的数 乘以 2的几次幂


> >> 右移
- 每向右移动一位 相当于再原来的基础上 除以2
- 每向右移动几位 相当于用原来的数 除以 2的几次幂
- 貌似的规律貌似的规律都是原数减一半 但是也是在一定的范围内

- 注意：
- 当我们进行右移的时候 需要拿数补位
- 当原数为正数的时候 空位我们全部拿 0 补
- 当原数为负数的时候 空位我们全部拿 1 补

<!-- 
  int num = 21;
  num << 2;   21 * 2 * 2
  num <<< 3;  21 * 2 * 2 * 2
  num <<< 4;  21 * 2 * 2 * 2 * 2
 -->

<!-- 
  int num = 80;
  int res = num >> 3;   80 / 8 = 10

  num >> 1;   // 40
  num >> 2;   // 20
  num >> 3;   // 10
 -->

**注意**
- 1. 位运算符操作的都是整型的数据
- 2. << 在一定范围内 每向左移1位相当于 * 2    原数加一倍
- 3. >> 在一定范围内 每向右移1位相当于 / 2    原数减一半
  - 那是不是说当整型数字 减少一半的时候 或者 增加一倍的时候 我们就可以对这个数字进行 >> << 的操作呢？ 哈哈

- 4. 负数也适用于这个规律
<!-- 
  什么叫在一定范围内呢？ 我们现在是依次左移 但是假如移动到最高位也就是符号位由原来的0变为1了 也就是说由原来的正数变为负数了 那就有问题了
 -->

- 5. 注意 负数 右移补位的问题 正数拿0补 负数拿1补
<!-- 
  右移两位
  100000010011
    100000010011

  我们要拿数补位 因为原本就是负数 所以这时候我们补位要拿1补
  100000010011
  11100000010011
 -->


> 面试题
- 最高效的计算 2 * 8 
- 答案:
- 1. 2 向左移动 3位
- 2. 8 向左移动 1位
<!-- 
  int num = 2;
  int res = num << 3;

  第一种想法：
  单独去想 8 是 2的几次幂   因为左移就是在用数值 * 2的几次幂

  第二种想法：
  2会被扩大几倍 扩大了8倍 但不能直接用2 * 2^8 
  而是我们这种想法要考虑 2分几次翻倍了
  翻一次会是 4
  翻二次会是 8
  翻三次会是 16

  岂不是又到想法1了
 -->
 

> >>> 无符号右移
- 不管这个数原来是正数 还是 负数 补位的时候都拿0来补
<!-- 
  也就是 原本的数 如果是负数 往右 无符号移动一位 瞬间就变成正数了
  使用无符号右移的时候根本就不是想进行 /2 的操作了

  在求集合 和 哈希值原码的时候 底层会用到这个符号 先不讲了
 -->


> &
- n = 12; m = 5;  n & m 结果为4
- 我们要将数值转换为二进制 然后每一位进行 &运算判断

- 技巧：
  我们把0当成false 把1当成true 我们将false 和 true进行 & 逻辑运算
  所以只有 true true结果才是true 其它的结果都是0

- 也就是说 1 和 1 才是1 其它都是0

> 要点： 11为1 找true

<!-- 
  12的底层2进制为   00001100
  5的底层2进制为    00000101    它们进行 & 运算

  
  0 0 0 0 1 1 0 0   &
  0 0 0 0 0 1 0 1
  0 0 0 0 0 1 0 0

  2^2 结果为 4
 -->


> |
- 技巧
- 1看成true 0看成false 然后进行同位 | 运算 
- 只有都是false的时候 才是false 其它的都是true

- 0 和 0 才是0 其它都是1

> 要点： 00为0 找false
<!-- 
  0 0 0 0 1 1 0 0   |
  0 0 0 0 0 1 0 1
  0 0 0 0 1 1 0 1

  2^3 2^2 2^0 = 13
 -->


> ^ 异或
- 技巧
- 1看成true 0看成false 然后进行同位 ^ 运算 
- ^ 异或 我们希望看到的结果是不一样 所以 不一样就是true 对应1
- 其余的情况都是0

> 要点： 一样为0
<!-- 
  0 0 0 0 1 1 0 0   ^
  0 0 0 0 0 1 0 1
  0 0 0 0 1 0 0 1

  2^3 2^0 = 9
 -->


> ~ 取反
- 包括符号位在内 所有的数值0变1 1变0
- int num = 6; ~num;
<!-- 
  0000 0000 0000 0000 0000 0000 0110
  1111 1111 1111 1111 1111 1111 1001  

  结果是 -7 

  6 进行 ~6 是 -7 那 ~-7 是多少？ 是6 
 -->


> 练习：
- int num1 = 10; int num2 = 20;
- 交换两个变量的值

- 场景：
- 1. 购买火车票的时候 我们点击按钮可以互换地址
<!-- 
  北京 -- 唐山
  唐山 -- 北京
 -->

- 2. 数字排序 1 5 4 2 3 排成 1 2 3 4 5
<!-- 
  这里少不了交换变量位置的值 比如5 和 3交换一下
 -->

- 上述的场景中都少不了交换两个变量的值


> 方式1
- 定义一个临时变量

- 技巧
- 每一行最后一个变量 是下一行的开头
<!-- 
  int temp = num1;
  num1 = num2;
  num2 = temp;
 -->


> 方式2
- 相加操作
- 理解举例：
- 有两个岛分别站了一个人 甲乙 ， 岛周围全是水水里有鳄鱼， 甲乙要交换地方
- 做法 甲 跳到 乙的脖子上 让乙跳到甲的位置上 然后甲再蹦到乙的位置上
- 用代码来实现乙蹦到甲的脖子上就是 两个数相加
<!-- 
  // 乙跳到了甲的脖子上 num1为30了 两个人一起的重量 
  并且两个人在同一个岛上 为了交互位置 甲带着乙跳到了 乙所在的岛上 
  接下来开始卸货
  num1 = num1 + num2;   

  // num1为两个人的重量 我们要减去其中的一个人的重量 并赋值给这个人 
  这时候为了交换我们要减去另一个人的重量 不要减自己 (减自己等于没换)
  num2 = num1 - num2;   // num2 = 10 这时候num1还是30

  // 这步就是为了交换值
  num1 = num1 - num2;   // 30 - 10 = 20  num1 = 20
 -->

- 好处： 不用定义临时变量
- 弊端： 两数相加超过本身变量的存储范围 对于数值型的可以用 非数值型的不好用 也就是说有数据类型的限制


> 方式3
- 要点:
- 两个数之间进行异或运算再进行异或运算其中的一个数 结果是另一个数
- a ^ b 如果再 ^ a 结果就是 b
- a ^ b 如果再 ^ b 结果就是 a

<!-- 
  0000 1101    m = 13
  0000 0101    n = 5     ^
  0000 1000    ^运算的结果为8

  0000 0101   n = 5 再跟上面的结果进行^运算
  0000 1101   ^ 2次^运算的结果是13


  1. n ^ m 的结果为k 等于 8
  2. 让k再继续异或其中的一个数 比如我们用k ^ n 结果就变成m了
  m = k^n = (m^n)^n

  n ^ m 得到的结果 ^ n 得到的结果就是 m
  就是两个数异或运算再异或一个数结果就是另一个数 (变过去异或再变回来)
 -->

- 具体实现步骤
<!-- 
  // 实现 交换两个变量的值
  int num1 = 10;
  int num2 = 20;

  // 1. 我们将第一次的异或运算的结果保存
  num1 = num1^num2;

  // 2. 将保存的结果 再次异或其中的一个数值 结果会是另一个数值
  这里num1^num2 结果会是num1的值 但是我们为了交换将这个值给num2
  num2 = num1^num2;

  // 3. 这时候num1还是我们上面保存的结果 我们再次异或num2 
  这里注意经过上面的步骤num2的值已经是num1的值了 也就是说 我们得到的结果会是num2的值 为了交换 我们将结果赋值给num1
  num1 = num1^num2;
 -->

----------------

> 三元运算符
> 格式：
- (条件表达式) ? 表达式1 : 表达式2
- 当条件表达式为true的时候  运算结果是表达式1
- 当条件表达式为false的时候 运算结果是表达式2

**注意：**
- 接收三元运算符的变量类型必须是能够统一 表达式1 和 表达式2 的类型
- 1. 表达式1 和 表达式2 为同种类型 这样接收结果的类型也跟它们一样
<!-- 
  int m = 12;
  int n = 5;
  int max = (m > n) ? m : n;

  n m 都是int 接收它们结果的类型也是int
 -->

- 2. 接收结果为能统一它们的类型
<!-- 
  double num = (m > n) ? 2 : 1.0

  因为num要么就是int 要么就是double 我们要将num定义成能够接收它们两个的类型

  下面的情况就不行 这样怎么定义类型接收呢？ 没办法统一
  (m > n) ? "n大" : 2
 -->


> 三元运算符 与 if-else的联系 与 区别
- 1. 三元运算符可简化if-else语句
- 2. 三元运算符要求必须返回一个结果
- 3. if后的代码块可以有多个语句

<!-- 
  // 获取两个整数的最大值
  int m = 12;
  int n = 5;
  int max = (m > n) ? m : n;
 -->


> 三元表达式的嵌套
- 第二个结构要加上 ( )
- String max = (m > n) ? "m大" : ((m == n) ? "m n相等" : "n")


> 练习
- 获取三个数的最大值
<!-- 
  // 获取两个整数的最大值
  int n1 = 12;
  int n2 = 5;
  int n3 = -43;

  int max = (n1 > n2) 
              ? ((n1 > n3) ? n1 : n3) 
              : ((n2 > n3) ? n2 : n3);
 -->

- 注意：
- 开发的时候这样不好 觉得很帅 但不是真的帅 以后改哪都不敢下手
- 代码帅的定义
- 1. 效率高 这点是基于算法的改良
- 2. 上面的3行代码整成一行了 感觉帅了 但是是让可读性变差了 效率并没有提高 大家还看不懂


> 结论
- 凡是可以使用三元运算符的地方都可以改写成if else
<!-- 
  if(m > n) {
    System.out.println(m)
  } else {
    System.out.println(n)
  }
 -->

- 能用if else的一定能改成三元么？ 不是
- 三元运算符的结构简单 接收变量的类型还有限制 if else比较灵活

- 如果程序既可以使用三元运算符 又可以使用if-eles 那么优先选择三元运算符 原因 简洁 执行效率高
<!-- 
  三元运算符的效率高 毕竟它只是个运算符 而if else是比较复杂的流程控制语句 
-->

----------------------------

### 运算符的优先级
- 运算符有不同的优先级 所谓优先级就是表达式运算中的运算顺序
- 如下表 上一行运算符总是优先于下一行

- 只有单目运算符 三元运算符 赋值运算符是从右向左运算的
<!-- 
  0.  . () {} ; ,
  1.  ++ == ~ ()
  2.  * / %
  3.  + -
  4.  << >> >>>
  5.  < > <= >= instanceof
  6.  == !=
  7.  &
  8.  ^
  9.  |
  10. &&
  11. ||
  12. ? :
  13. =  *=  /=  %=  +=  -=  <<=  >>=  >>>=  &=  ^=  =
-->

- 85集讲刚毕业就业

----------------------------

### 复习
> & && 异同
- 从使用来讲 它们用哪个都是可以的 都表示& 从结果上看都用它们两个谁都是一样的
- 当前面结构为false的时候 &&右侧是不执行的


> String类型的数据之间不能比较大小
- > < >== <== 只能使用在数值类型的数据之间
- == 不仅可以使用在数值类型的数据之间 还可以使用在是他的引用类型之间
<!-- 
  // 1000 2000 是余额
  Account acct1 = new Account(1000)
  Account acct2 = new Account(2000)

  acct1 == acct2;   // 这时候比较的是 两个账户是不是同一个账户
 -->


> 使用程序求一个 0-255 范围内的整数的十六进制
- 该题利用了 
- 1. & 运算
- 2. >>> 无符号右移
- 3. char型与数值的计算

- &运算要点
- 1. 11得1(true true是true) 其余都是0
- 2. (技巧)拿到末4位的值 可以让该数与 15二进制进行&运算
<!-- 
  15的二进制末4位是1111 其余都是0
 -->

- >>> 无符号右移
- 当右移的时候我们不关注/2 目的只是为了取2进制数 拿0补位 就用无符号右移

- char型与数值的计算
- 这题里面利用了三元表达式 当x > 9的时候 做逻辑处理
- 所有将结果确定位char型 x > 9 那么就可能是10 11 12 ...
<!-- 
  A是65
  (i2-10+'A')
  当 i2 为 10 的时候 就是 0 + A = 0 + 65 = 65 = A
  当 i2 为 11 的时候 就是 1 + A = 1 + 65 = 66 = B
 -->

> 具体逻辑
- 核心思路：
- 2进制 转为 16进制，可以将每4位01进行累加算出一个结果
- 0011 1100   60的二进制
- 3    C
<!-- 
  但问题是怎么才能将 1100 单独的从2进制中取出来？

  为了将 末尾4位单独拿出来 
  可以让i1和15进行 &运算 因为15的未4位是1111 其余28位为0
  int i2 = i1 & 15;

  1100
  1111  &
  1100

  我们可以看到和15进行&运算后的结果就是 我们想取出60的2进制的未4位本身


  int i1 = 60;

  // 15的二进制末4位是1111 其余是0 就能够得到60的2进制的末四位
  int i2 = i1 & 15;

  // 这里是 算出 C 的逻辑 利用了 char型变量的相加
  String j = (i2 > 9) ? (char)(i2-10+'A') + "" : i2 + "";  // c

  上面是将0011 1100最低4位取出来了 接下来怎么取0011这四位?
  我们将i1 整体的右移四位 0011 就成为了最低的4位
  只有当我们关心右移是代表/2的时候 才用>> 只是想右移拿0补 目的只是为了取数 那就>>>
  int temp = i1 >>> 4;
  i2 = temp & 15;
  String k = (i2>9) ? (char)(i2-10+'A') + "" : i2 + "";  // 3

  System.out.println(k+""+j);
-->

----------------------------

### 程序流程控制
- 流程控制语句是用来控制程序中各语句执行顺序的语句 可以把语句组合成能完成一定功能的小逻辑模块

- 其流程控制方式采用结构化程序设计中规定的三种基本流程结构
- 1. 顺序结构
- 2. 分支结构
- 3. 循环结构 

> 顺序结构
- 程序从上到下逐行的执行 中间没有任何判断和跳转


> 分支结构
- 根据条件 选择性的执行某段代码
- 有 if else 和 switch case 两种分支语句


> 循环结构
- 根据循环条件 重复性的执行某段代码
- 有 while do for 三种循环语句
<!-- JDK提供了forEach循环 方便的遍历集合 数组元素 -->

------------------

> 分支结构 if else
- 这个语法分成了3种情况用于应对需求
- 条件判断结构

> 1. if(条件表达式) { ... }
- 如果条件表达式为true 则执行 花括号内部的代码逻辑
- 如果条件表达式为false 则跳过 花括号内部的代码逻辑 往下执行(不考虑大括号内部代码)
<!-- 
        条件表达式  ↘
          true    faflse
            ↓        ↓
        执行代码块    ↓
            ↓     ↙
            ↓   ↙
 -->        

<!-- 
  // 举例1 体检
  int heartBeats = 78;
  if(heartBeats <60 || heartBeats > 100) {
    System.out.println("您需要做进一步的检查");
  }

  System.out.println("检查结束");
 -->


> 2. if(条件表达式) { ... } else { ... }
- 二选一
- 如果条件表达式为true 则执行if后的逻辑 
- 如果条件表达式为false 则执行else后的逻辑
- 一条分支执行完毕后 接下来顺序往下执行

- 改分支语句一定会在两个条件中选择一个执行
<!-- 
        条件表达式
      ↙          ↘
    true        false
      ↓           ↓
      ↓           ↓
      ↓  →  ↓  ←  ↓
            ↓
 -->

<!-- 
  2选一 一定会执行下面条件中的一个

  // 举例2 
  int age = 18;
  if(age < 18) {
    System.out.println("你还可以看动画片");
  } else {
    System.out.println("你要工作了");
  }
 -->


> 3. if(条件表达式1) { ... } else if(条件表达式2) { ... } else{}
- 多选一 
- 选择符合条件的其中一条执行大括号内部的语句 然后接着往下执行
- 匹配一个条件执行完毕后 直接会跳出分支结构

<!-- 
  // 举例3
  int age = 18;
  if(age < 0) {
    System.out.println("您输入的数据非法");
  } else if(age < 18) {
    System.out.println("青少年时期");
  } else {
    System.out.println("您该工作了");
  }
 -->


> if-else 使用的说明
- 条件表达式必须是布尔表达式(关系表达式 或 逻辑表达式) 布尔变量
- 语句块只有一条执行语句的时候 一对{}可以省略 但建议保留
- if else语句结构 根据需要可以嵌套使用

- 当if else结构是 多选一 的时候 最后的else是可选的 根据需要可以省略
- 当多个条件是 互斥 关系的时候   条件判断语句以及执行语句间顺序无所谓
- 当多个条件是 包含 关系的时候   ”小上大下 / 子上父下“

> Scanner的应用
- 使用该语法 控制台会要求用户输入值 我们拿scanner中对应的方法获取对应的值

> 通过键盘输入 拿到值
- 该问题 需要新知识 这里只是简单的了解下
- 通过键盘获取不同类型的变量(值) 需要使用 Scanner 类
- 该类用于通过键盘获取值

- 具体的使用方式
- 1. 导包
- 我们想在代码中使用 Scanner 类 这个类在另外一个包下 我们需要将这个类导进来
- 导包操作要写在 Demo类声明的上方

- 2. Scanner的实例化 相当于创建Scanner对象
- Scanner scan = new Scanner(System.in);
<!-- 
  该操作在main方法内部 main()是一个入口 我希望一上来就执行所以放在了这里面
  System.in 键盘输入 上面整体是将Scanner实例化
 -->

- 3. 调用 Scanner 类的相关方法 来获取指定类型的变量
- 在Scanner类下有很多的功能 也就是方法 其中有一个方法叫做 nextInt() 读取一个int型的值
<!-- 
  // 导包
  import java.util.Scanner;

  class Demo {
    public static void main(String[] args) {

      Scanner scan = new Scanner(System.in);
      int num = scan.nextInt();
      System.out.println(num);
      
    }
  }
-->

- 我们还可以获取别的类型的值 也是需要查看 Scanner 类中对应的方法

> next() or nextLine()
- 获取String型数据

> nextByte()
> nextBoolean()
> nextDouble()
> nextFloat()
> nextLong()

<!-- 
  // 导包
  import java.util.Scanner;

  class Demo {
    public static void main(String[] args) {

      Scanner scan = new Scanner(System.in);

      System.out.println("请输入你的姓名: ");
      String name = scan.next();
      System.out.println(name);

      System.out.println("请输入你的年龄: ");
      int age = scan.nextInt();
      System.out.println(age);

      System.out.println("请输入你的体重: ");
      double weight = scan.nextDouble();
      System.out.println(weight);

      System.out.println("你是否相中我了呢?(true/false): ");
      boolean isLove = scan.nextBoolean();
      System.out.println(isLove);

      // 对于char型的获取 Scanner 没有提供相关的方法 只能够获取一个字符串  假如我们就想定义一个char型变量

      可以使用字符串提供的 charAt() 方法 提取指定位置的字符
      char genderChar = gender.charAt(0)
    }
  }

  当用户输入和我们定义接收的类型不相符的时候就会报错
  程序过程当中一旦出现异常就会终止
 -->


**注意**
- 需要根据相应的方法 来输入指定类型的值 如果输入的数据类型与要求的类型不匹配的时候 会报异常 "inputMisMatchException" 导致程序终止


> 练习
- 岳小鹏参加java考试 他和父亲岳不群达成承诺 如果
- 成绩为100 奖励一辆bmw
- 成绩为(80, 99]时 奖励一台iphone
<!-- 
  左开右闭 不包括80 包括99
 -->

- 成绩为[60, 80]时 奖励一个ipad
- 其它时 什么奖励也没有 请从键盘输入岳小鹏的期末成绩 并加以判断
<!-- 
  import java.util.Scanner; 
  class Demo {
    public static void main(String[] args) {

      Scanner scan = new Scanner(System.in);
      System.out.println("请输入岳小鹏的期末成绩: (0-100)");
      int score = scan.nextInt();

      if(score == 100) {
        System.out.println("奖励一辆BMW");
      } else if(score > 88 && score <= 99) {
        System.out.println("奖励一台iphone");
      } else if(score >= 60 && score <= 80) {
        System.out.println("奖励一个ipad");
      } else {
        System.out.println("什么也没有");
      }
    }
  }
 -->

- 总结:
- 1. else的逻辑是可选的 可以不写
- 2. if else if 只要有一个逻辑匹配上了 就会跳出整个结构
- 3. 
- 如果多个条件表达式之间没有交集的关系时 哪个判断和执行语句声明在上面还是下面 无所谓

- 如果多个条件表达式之间有交集的关系时 需要根据实际情况考虑清楚应该将哪个结构声明在上面

- 如果多个条件表达式之间有包含的关系时 通常情况下 需要将范围小的声明在范围大的上面 否则范围小的就没有机会执行了


> 练习2
- 编写程序: 由键盘输入三个正数分别存入变量num1 num2 num3中 并对它们进行排序(使用if else) 并且从小到大输出
<!-- 
  import java.util.Scanner; 
  class Demo {
    public static void main(String[] args) {

      Scanner scan = new Scanner(System.in);
      System.out.println("请输入第一个整数: ");
      int num1 = scan.nextInt();
      System.out.println("请输入第二个整数: ");
      int num2 = scan.nextInt();
      System.out.println("请输入第三个整数: ");
      int num3 = scan.nextInt();

      if(num1 > num2) {

        // 比较num3是否比大的还要大
        if(num3 > num1) {
          System.out.println(num2 + " > " + num1 + " > " + num3);

          // 比较num3是否比小的还要小
        } else if (num3 < num2) {
          System.out.println(num3 + " > " + num2 + " > " + num1);

          // 剩下的情况就是在中间了
        } else {
          System.out.println(num2 + " > " + num3 + " > " + num1);
        }

        // 现在就是num2大的情况 我们再拿num3来进行比较
      } else {
        if(num3 > num2) {
          System.out.println(num1 + " > " + num2 + " > " + num3);
        } else if(num3 < num1) {
          System.out.println(num3 + " > " + num1 + " > " + num2);
        } else {
          System.out.println(num1 + " > " + num3 + " > " + num2);
        }
      }
    }
  }
 -->

**注意：**
- else也有就近原则 当配对关系不明确的时候 else就会和最近的if进行配对
<!-- 
  if(x > 2) 
    if(y > 2)   下面的 else 会和这个if配对
      System.out.println()  

  else {
    这个else和谁配对? 最外围的if没有 { }
  }
 -->


> 练习3
- 我家狗狗5岁了 5岁的狗相当于人类多大呢？
- 狗的前两年 每一年相当于人类的10.5岁 之后每增加一年就增加4岁
- 那么5岁的狗相当于人类多少年龄呢？

- 应该是 10.5 + 10.5 + 4 + 4 + 4 = 33岁

- 编写一个程序 获取用户输入的狗的年龄 通过程序显示其相当于人类的年龄
- 如果用户输入负数 请显一个提示信息
<!-- 
  import java.util.Scanner; 
  class Demo {
    public static void main(String[] args) {

      Scanner scan = new Scanner(System.in);
      int age = scan.nextInt();

      if(age < 0) {
        System.out.println("请输入正确的年龄");
      } else {
        if(age > 0 && age <= 2) {
          System.out.println("狗狗的年龄为: " + age * 10.5 + "岁");
        } else {
          System.out.println("狗狗的年龄为: " + (2*10.5 + (age - 2) * 4) + "岁");
        }
      }
    }
}
 -->


> 练习4
- 假设你想开发一个玩彩票的游戏 程序随机地产生一个两位数的彩票 提示用户输入一个两位数 然后按照下面的规则判定用户是否能赢

- 1. 如果用户输入的数匹配彩票的实际顺序 奖金10000
- 2. 如果用户输入的所有数字匹配彩票的所有数字 但顺序不一致 奖金3000
- 3. 如果用户输入一个数字仅满足顺序情况下匹配彩票的一个数字 奖金1000
- 4. 如果用户输入一个数字仅满足非顺序情况下匹配彩票的一个数字 奖金500
- 5. 如果用户输入的数字没有匹配任何一个数字 则彩票作废


> 随机数 Math.random()
- 它会获得一个double型的数据
- 该方法会返回 >= 0.0 <=1.0 之间的数
<!-- 
  如果 Math.random() * 100 那就变成 [0.0 - 100.0)
 -->

- 上面的题里要求的是2位数 所以我们不能乘以100 我们乘以90 再加上10
<!-- 
  Math.random()*90  [0.0, 90.0)

  然后+10 就会变成[10.0, 100.0)
 -->

- (int)(Math.random() * 90 + 10)

> 公式：
- [a, b]: (int)(Math.random() * (b - a + 1) + a)

<!-- 
  public static void main(String[] args) {
    int value = (int)(Math.random() * 90 + 10);
    System.out.println(value);
  }
 -->

---------------------------- 

### 分支语句2 switch case 结构
> 结构
- 1. break 关键字不是必须写的 为可选 根据实际情况
<!-- 
  一旦执行到此关键字就跳出当前结构
 -->

- 2. switch后的 (表达式) 不是条件表达式
<!-- 
  条件表达式代表它是布尔类型的 switch后面的表达式不是条件表达式
  这个表达式的类型只能是如下6中数据类型之一

   - 1. byte
   - 2. short
   - 3. char
   - 4. int
   - 5. 枚举类型    (jdk5.0新增)
   - 6. String类型 (jdk7.0新增)
 -->

- switch后面的表达式的值会依次跟case后面的值进行==匹配
<!-- 
  switch(表达式) {    // 该表达式不是条件表达式

    case 常量1:       // 只能声明常量 不能声明范围 num > 10 这样不行
      语句；
      break;

    case 常量2:
      语句；
      break;

      ...

    // 类似 else 上面的都没有匹配上的话 我们会执行default
    default:
      语句；
      break；
  }
 -->

- 3. default关键字的位置不是固定的 它可以放到任意位置
- 就是说default后面最好也有break 如果default的位置在其他位置的情况下
<!-- 
  int num = 3

  default: 
    System.out.println("zero");
  case 1:
    System.out.println("zero");
    break;

  进入执行程序后还是先看case有没有匹配上的 没有的话走default
  但是default后面没有break 所以还会执行 case1后面的语句 case后面的语句有break 停止
 -->

> 要点：
- 1. 和 if else 不一样的地方是 一旦if else匹配上其中的一个都 就会跳出整个结构
- 2. switch case 当没有break的时候 一旦匹配上条件后并不会跳出 而是会接着执行其它case结构中的执行语句 直到遇到break关键字 或者 到程序结束为止

- 3. 当多个case后的执行语句一样的时候我们可以考虑合并操作
<!-- 
  case 0:
  case 1:
  case 2:
  case 3:
    System.out.println("不及格");
    break;
 -->

**注意：**
- 一旦匹配上其中的一个条件后 会不进行判断就执行下面的语句

<!-- 
  class Demo {
    public static void main(String[] args) {
      
      switch后面的表达式对数据类型有要求 
      1. 不能放浮点型
      2. 不能放布尔型
      int num = 0;    

      switch(num) {
        case 0:
          System.out.println("zero");
        case 1:
          System.out.println("one");
        default:
          System.out.println("default");
      }
    }
  }

  要想执行多选一的话 我们要加上break关键字
 -->


> 练习：
- 1. 使用 switch 把小写类型的 char型转为大写 只转换 a b c d e 其他的输出 other
- 提示： 
  String word = scan.next();
  char c = word.charAt(0);
  switch(c) { ... }

- 2. 对学生成绩大于60分的 输出合格 低于60分的输出 不合格
<!-- 
  class Demo {
    public static void main(String[] args) {
      int score = 78;
      switch(score/10) {        // 让情况减少  
        我们还可以除以60 结果为0就是不及格 为1就是及格

        case 0:
          System.out.println("不及格");
          break;
        case 1:
          System.out.println("不及格");
          break;
      }
    }
  }
 -->

- 3. 编写程序 从键盘上输入2019年的 month 和 day 要求通过程序输出输入的日期为2019年的第几天
- 思路：
  比如 2月 15日 那就1月的31 + 15呗
<!-- 
  import java.util.Scanner;
  class Demo {
    public static void main(String[] args) {
      Scanner scan = new Scanner(System.in);
      System.out.println("请输入2019年的月份: ");
      int month = scan.nextInt();

      System.out.println("请输入该月的某一天: ");
      int day = scan.nextInt();

      // 定义一个变量 保存总天数
      int num = 0;
      switch(month) {

        // 我们倒着写 从12月份开始写 然后不写break 然后程序就会执行下面的逻辑 把 = 改成 +=
        case 3:
          num += 28;
        case 2:
          num += 31;
        case 1:
          num += day;
      }
    }
  }
-->


> 总结
- 1. 凡是可以使用switch case的结构都可以转换为if-else 反之不成立
<!-- 
  因为switch的表达式有要求
 -->

- 2. 当我们写分支结构时 既可以用if else又可以用switch case 优先使用switch case情况过多除外
<!-- 
  switch的实行效率稍高
 -->

----------------------------

### 循环结构 和 for循环的理解
- 在某些条件满足的情况下 反复执行特定代码的功能

- 循环语句分类
- for
- while
- do while

> 循环语句的四个组成部分
- 1. 初始化部分
- 2. 循环条件部分   -- 是boolean类型
- 3. 循环体部分
- 4. 迭代部分
<!-- 
  1. 先是初始化的部分 -- 再对循环条件进行判断 看它是否满足进入循环的条件 -- 如果不满足直接退出循环结构

  2. 如果满足循环条件 则进入循环体部分执行循环逻辑 -- 进入迭代部分(i++) -- 然后判断这次变化是否满足循环条件 -- 如果还满足则循环执行循环体内部逻辑

  3. 如果不满足循环条件则退出循环结构
 -->

> for循环的结构
  for(①; ②; ④) { ③ }

> 示例： 
<!-- 
  class Demo {
    public static void main(String[] args) {
      for(int i=0; i<5; i++) { 
        System.out.println("输出for结构");
      }

      for(int i=0; i<5; i++) { 
        System.out.println("输出for结构");
      }
    }
  }
 -->

- 思考:
- 上面有两个for循环结构 同时都使用了 i 冲突么？
- 不冲突 因为它们有各自的作用域 属于定义在了 循环体中 在for循环外部 访问不到 i


> 练习：
- 要点：
- 1. 初始化部分放在了外面
- 2. 1;2;3 这三个部分中都可以假如其它的语句 其它语句同时也会得到执行
- 3. 如果 3 中有多条语句的话 中间要使用,分割
<!-- 
  int n = 1;
  for(System.out.println("A"); n < 3; System.out.println("C"), n++) {
    System.out.println(" B");
  }

  输出结果 ABCBCBC
 -->

- 总结：
- for循环的条件部分和if条件部分一样都能够得到执行 所以当中也能写逻辑


> 练习2：
- 遍历100以内的偶数 输出所有偶数的和 输出偶数的个数
<!-- 
  class Demo {
    public static void main(String[] args) {

      int num = 0;
      int odd = 0;

      for(int i=0; i<100; i++) {
        if(i % 2 == 0) {
          System.out.println(i);

          num += i;
          odd = i;    // 或者让 ood+ 额 我基础真差
          odd++;      // or
        }
      }

      // 整个循环结束以后 告诉我结果是多少
      System.out.println(num);
      System.out.println("偶数的个数为： " + odd);
    }
  }
 -->


> 练习3：
- 编写程序从1循环到150 并在每行打印一个值 另外在每个3的倍数行上打印出 “foo”， 在每个5的倍数行上打印“biz” 在每个7的倍数航上打印输出“baz”
<!-- 
  1
  2
  3 foo
  4
  5 biz
  6
  7 baz
 -->

- 错误的思路:
- 这里我使用了else if的结构 因为else if是多选一 当次i的结果只会进入其中的一个分支判断结构
- 我们的例子中 有些数字既能被3整除 又能被 5 7 整除 所以我们要是使用else if的话 当有符合多个情况的数字的时候 只能打印出一种
<!-- 
  if(i % 3 == 0) {
    System.out.println(i + " foo");
  } else if(i % 5 == 0) {
    System.out.println(i + " biz");
  } else if(i % 7 == 0) {
    System.out.println(i + " baz");
  } else if(i % 3 == 0 || i % 5 == 0 || i % 7 == 0) {
    System.out.println(i + " foo biz baz");
  } else {
    System.out.println(i);
  }
 -->

- 所以我们要使用if 独立判断 当次的循环逻辑 会依次的进入到 其它的if中

- 要点：
- 1. 我们要使用 System.out.print 当次循环的最后再使用 System.out.println来换行

- 2. 比如当次是x 先是print输出 x 然后进入其它if判断 符合输出 foo
- 这时当次一行的结果就是 x foo
- 然后进入其它的if判断 如果符合if 当次当行输出 biz
- 这时当次一行的结果就是 x foo biz 因为我们使用的是print
- 最后的时候我们要使用 println 换行

<!-- 
  for(int i=1; i<=150; i++) {
    // 1. 先输出 i 
    System.out.print(i + "  ");
    
    // 2. 如果当次循环符合其它情况就输出 if 中的语句
    if(i % 3 == 0) {
      System.out.print("foo ");
    }

    if(i % 5 == 0) {
      System.out.print("biz ");
    }

    if(i % 7 == 0) {
      System.out.print("baz ");
    }

    System.out.println();
  }
 -->


> 练习4
- 题目： 
- 输入两个正整数m n 求其最大公约数 和 最小公倍数
- 比如 12 和 20的最大公约数是4 最小公倍数是60

- 前置理解:
- 约数: 
- 比目标数小 能被目标数除尽的数 叫约数 
- 12的约数有1 2 3 4 6 12

- 倍数:
- 比目标数大 除以目标数能除尽的
- 12的倍数有12 24 36

- 公约数:
- 即是你的也是我的就叫做公约数
- 12 20的公约数 既能被12除尽 又能被20除尽的数 1 2 4


- 思路：
- 约数代码上的体现: m 除以一个数(i)等于 0 这个数就是约数
- 倍数代码上的体现: i 除以 m 等于0 这个i就是m的倍数

- 公约数和公倍数就是 && m % i == 0 && n % i == 0

> 公约数
- i的取值范围：
- 约数：
- 约数不能比n m当中最小的数还大 我们拿到n m当中最小的数
- 比如 12 的约数 1 2 3 4 6 12 约数不会比12本身还要大
- 
- i的取值范围就应该是1 - 12

- 怎么求最大的公约数
- 上面 i 的取值范围知道了是1 - 12 那么我们从12开始往前 依次拿每一个数当做n m的除数 看看能否除尽一旦除以 它就是n m的最大公约数 

- 要点： 要加break 因为我们是从后往前去匹配 第一个匹配到的就是最大的公约数 所以要break下


> 公倍数
- i的取值范围
- 公倍数(i) 肯定不能比 12 20(n, m)还小 所以肯定大于20
- 20 ~ ？
- 
- ？ 是多少呢 我们定为 n x m 虽然肯定不是最大公倍数 但是它一定能保证是n 和 m的倍数

- 所以i的取值范围就是 12 ~ 12 X 20
- 然后我们开始进行判断

<!-- 
  import java.util.Scanner;
  class Demo {
    public static void main(String[] args) {

      Scanner scan = new Scanner(System.in);
      System.out.println("请输入第一个正整数: ");
      int m = scan.nextInt();
      System.out.println("请输入第二个正整数: ");
      int n = scan.nextInt();


/*
  公约数
  1. 
    m % i == 0 && n % i == 0 这个条件只能保证 i 是约数 
    但是不能保证这个i是最大的约数

  2. 怎么保证 约数i是最大的公约数
    约数的范围是12 那我就拿着 1 - 12 这个范围的数字 依次去除n m
    12 11 10 从后往前的除 一旦发现一个能除尽就说明这个数是最大的公约数

  3. i的范围是多少呢
    约数不能比这个数本身还大 公约数不能比12 20这个12还要大
    i的范围就是 i不能超过12 
    i的范围就是 1 - 12

-----

  公倍数
  1. 公倍数肯定不能比12 20小 所以肯定是>=20 所以i的值就是从两个数中的较大的数开始 
  开始的数是20 那结束的数是多少？  12 x 20 两个数相乘肯定是这两个数的倍数 但肯定不是最小公倍数 这样i的范围就能确定下来
  20 - 12x20

  2. 范围确定了 那就从20开始循环判断 只要i能除尽n m i就是最小公倍数
*/

  // 获取两个数中最小的数
  int min = (m > n) ? n : m;

  // 方法1： 定义一个最大公约数
  int maxY = 0;

  // 因为我们要从12依次往前去判断 所以初始值是12 每次要-- 循环条件是什么？ 到什么时候停 正常我们循环5次的话是 i<5 现在是倒着的 我们要到1停 那就是 i >= 1呗

  for(int i=min; i >= 1; i--) {
    if(m % i == 0 && n % i == 0) {
      // 找到的是所有的约数
      // System.out.println(i);

--
      // 方式2： 直接使用break关键字 因为我们是从后往前去输出 匹配到的第一个一定是最大的公约数 所以匹配到一个就使用break
      // break;
--

      // 方法1： 使用外部变量进行判断赋值
      if(i > maxY) {
        maxY = i;
      }
    }
  }
  System.out.println("最大公约数为: " + maxY);

-- 公倍数：
  int max = (n > m) ? n : m;
  for(int i = max; i < n * m; i++) {
    if(i % n == 0 && i % m == 0) {
      System.out.println("最小公倍数为: " + i);
      break;
    }
  }
}}
 -->


----------------------------

### while循环
- 循环结构的四要素
- 1. 初始化条件
- 2. 循环条件     -- boolean类型
- 3. 循环体
- 4. 迭代条件

- 通常情况下 循环结束都是因为 2 中循环条件返回false了


> while结构
  ①
  while(②) {
    ③
    ④
  }

**注意:**
- 写while循环千万不要丢了迭代条件 一旦丢了 就可能导致死循环


> 执行过程: ① -- ② --　③ --　④　　-- ② --　③ --　④ ...

<!-- 
  // 遍历100以内的所有偶数

  class Demo {
    public static void main(String[] args) {
      int num = 0;
      while(num < 100) {
        if(num % 2 == 0) {
          System.out.println(num);
        }
        num++;
      }
    }
  }
 -->


> for while 区别
- for循环和while循环是可以相互转换的
- 初始化条件的位置不同 for循环的时候是局部变量 while循环的时候是全局变量

----------------------------

### do while 循环
- 循环结构的四要素
- 1. 初始化条件
- 2. 循环条件     -- boolean类型
- 3. 循环体
- 4. 迭代条件

> do while 结构

  ①
  do {
    ③     至少也会执行依次循环体
    ④
  }while(②)


> 执行过程: ① --　③ --　④ -- ② -- ③ --　④ ...
- 上来先走依次逻辑 然后再判断条件
<!-- 
  class Demo {
    public static void main(String[] args) {
      // 遍历100以内的偶数
      int num = 1; 
      do {
        System.out.println(num);
        num++;
      } while (num < 100);
    }
  }
 -->

----------------------------

> 练习:
- 从键盘读入个数不确定的整数 并判断读入的正数和负数的个数 输入为0时结束程序
<!-- 
  一般涉及到循环就要知道 循环结构中的4个部分

  循环次数： 这道题我们判断不出来要循环多少次
  循环终止的条件: 输入 0 的时候
 -->

> 技巧
- 最简单 无限 循环格式: while(true) for(;;)
- 无限循环存在的原因是并不知道循环多少次 需要根据循环体内部某些条件来控制循环的结束

<!-- 
  import java.util.Scanner;
  class Demo {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        // 定义正数 和 负数
        int z = 0;
        int f = 0;

        while(true) {
          // 这步相当于初始化条件
          int num = scan.nextInt();
          
          if(num > 0) {
            z++;
          } else if(num < 0) {
            f++;
          } else {    // 一旦是0的时候 执行break 跳出循环
            break;
          }
        }

        // 跳出循环后 输出 正负数的个数
        System.out.println(z);
        System.out.println(f);
    }
  }
 -->


> 总结
- 结束循环有几种方式
- 1. 循环条件部分返回false
- 2. 在循环体中 执行break

----------------------------

### 嵌套循环
- 将一个循环结构A声明在另一个循环结构B的循环体中，就是嵌套循环
- 在开发中嵌套循环一般不会超出3层

- 外层循环： B
- 内层循环： A

> 要点：
- 1. 内层循环结构遍历一遍 只相当于外层循环 循环体执行了一次
<!-- 
  假设外层循环需要执行m次 内层循环需要执行n次 此时内层循环的循环体一共执行了 n * m 次
 -->

- 2. 外层循环控制行数 内层循环控制列数

<!-- 
  class Demo {
    public static void main(String[] args) {
      // 输出6个星
      // for(int i=0; i<6; i++) {
      //   System.out.print("*");
      // }

      // 输出4行6个星
      for(int i=0; i<4; i++) {
        
        for(int j=0; j<6; j++) {
          System.out.print("*");
        }
        System.out.println();
      }

      /*
        外层控制行数
        内层控制每行的星星

        for(int j=0; j<6; j++) {
          System.out.print("*");
        }
        System.out.println();

        for(int j=0; j<6; j++) {
          System.out.print("*");
        }
        System.out.println();

        for(int j=0; j<6; j++) {
          System.out.print("*");
        }
        System.out.println();

        for(int j=0; j<6; j++) {
          System.out.print("*");
        }
        System.out.println();

        既然要输出4行6颗星 那是不是说就可以把上面的代码重复写4次
        那500行呢？
        所以我们可以把这重复的代码 放到 另一个循环结构中

        - 要点：
        - 先考虑一行怎么输出 然后把实现一行输出的逻辑放入另一个循环中
        - 有一些像 抽离公共部分
      */
    }
  }
 -->


> 打印 正三角形
<!-- 
  *
  **
  ***
  ****
  *****
 -->

- 我的思路
- 外层循环是控制行数的 那么i=0 i<5
- 内层是用来控制输出*的 那每行输出多少呢？ 我们发现第一行i为0 输出1个* 第二行i为1 输出2个星 那就是<j+1
<!-- 还有一种理解方式 j的个数就等于行号 -->

<!-- 
  for(int i=1; i<=5; i++) {
    for(int j=1; j<=i; j++) {
      System.out.print("*");
    }
    System.out.println();
  }

  // or

  for(int i=0; i<5; i++) {
    for(int j=0; j<i+1; j++) {
      System.out.print("*");
    }
    System.out.println();
  }
 -->  


> 打印 倒三角形
- 技巧:
- 在找规律的时候 我们可以将两个数相加 然后用总和减去其中的一个变量

- 技巧:
- 还可以用两个变量相乘得到一个范围(这是突然想起上面的求最小公倍数的案例了)
<!-- 
  *****   0  5    规律 i + j = 5 换句话说 j = 5 - i
  ****    1  4
  ***     2  3
  **      3  2  
  *       4  1
 -->

<!-- 
  for(int i=0; i<5; i++) {
    for(int j=0; j<5-i; j++) {
      System.out.print("*");
    }
    System.out.println();
  }
 -->


> 打印 菱形
<!-- 
          *
         * *
        * * * 
       * * * *
      * * * * *
       * * * *
        * * *
         * *
          *
 -->

- 思路:
- 分成两段打印 先打印 ***** 上面的部分 因为上下两部分的规律不一样
- 外层for循环是控制行数
- 内层1for控制 空格
- 内层2for控制 *

<!-- 
  // 上半部分
  for(int i=0; i<5; i++) {

    // 输出空格
    for(int j=0; j<4 - i; j++) {
      System.out.print(" ");
    }

    // 输出星号
    for(int k=0; k<i + 1; k++) {
      System.out.print("* ");
    }

    System.out.println();
  }

  // 下半部分 偏左平行四边形
  for(int i=0; i<4; i++) {

    // 输出空格
    for(int j=0; j<i+1; j++) {
      System.out.print(" ");
    }

    // 输出星号
    for(int k=0; k<4 - i; k++) {
      System.out.print("* ");
    }

    System.out.println();
  }
 -->


> 100以内的所有质数
- 质数：
- 只能被1和自身整除的自然数（约数里面只有1和它本身 比如7 约数为1，7）
- 质数在很多地方都有使用 因为质数的特性就是不能再分了

- 取值范围
- 除了1 和 这个数本身的数 跟n相除 看看余数 有没有除尽的
- 所以取值范围就是 2 ~ n - 1

> 方式1: 
- 要点:
- flag变量放在外面 做为全局变量使用 这时候 每一次内层循环结束后 都要讲flag设置为初始值
<!-- 
  // 标识i是否被j除尽过 一旦除尽 就修改其值
  boolean flag = true;

  for(int i = 2; i <= 100; i++) { // 遍历100以内的自然数
    for(int j = 2; j < i; j++) {  // j被i去除

      // 如果 i % j == 0 说明这个数一定不是一个质数 因为我们的取值范围就是 2 ~ n-1 如果这里还有==0能除尽的 那就说明它一定不是质数

      // i % j != 0 这个数是质数么？ 得除完 也就是 i 得把所有的j 都除一遍 才能确定是不是一个质数 一次搞不定
      if(i % j == 0) {
        flag = false;
      }
    }

    if(flag == true) {
      System.out.println("质数为: " + i);
    }

    // 重置 flag 因为到4的时候 flag为false flag再就没有被修改回初始值 然后 4 之后就不会再被打印
    flag = true;
  }
}
 -->


> 方式2
- 要点:
- flag变量放在外层循环的里面 这样每一次循环的时候 都会有自己的flag
<!-- 
  for(int i = 2; i <= 100; i++) {
    for(int j = 2; j < i; j++) {

      // 放在内层循环的里面
      boolean flag = true;

      if(i % j == 0) {
        flag = false;
      }
    }

    if(flag == true) {
      System.out.println("质数为: " + i);
    }

    flag = true;
  }
}
 -->


> 方式3
- 当 i % j == 0 的时候 我们直接开始下一轮 看看3 是不是质数
<!-- 
  label:for(int i = 2; i <= 10000; i++) {
    for(int j = 2; j <= Math.sqrt(i); j++) {
      if(i % j == 0) {
        continue label;
      }
    }

    // 能执行到此步骤的都是质数
    System...
  }
 -->


> 优化
- 1. break
- 只对本身是非质数的自然数是有效的

> System.currentTimeMillis()
- long end = System.currentTimeMillis();
<!-- 
  if(i % j == 0) {
    flag = false;
    break;
  }


  long start = System.currentTimeMillis();

  for(int i = 2; i <= 100000; i++) {
    boolean flag = true;
    for(int j = 2; j < i; j++) {
      if(i % j == 0) {
        flag = false;
        break;
      }
    }

    if(flag == true) {
      System.out.println("质数为: " + i);
    }
    flag = true;
  }

  long end = System.currentTimeMillis();
  System.out.println(end - start);
 -->

- 2. 开方
- 对本身是质数的自然数是有效的
- 注意要加上等于 j <=
<!-- 
  for(int j = 2; j <= Math.sqrt(i); j++)
 -->

- 3. 偶数肯定不是质数 我们可以把偶数抽离出来 只去判断奇数


> 完数
- 一个数如果恰好等于它的因子之和 这个数就成为完数
- 例如：
- 6 = 1 + 2 + 3

- 编程找出1000以内的所有完数 (因子: 除去这个数本身的其它约束)
<!-- 
  public static void main(String[] args) {

    int factor = 0;

    for(int i = 1; i <= 1000; i++) {
      for(int j = 1; j < i; j++) {      还可以是 j<=i/2
        // 进去下面的条件就说明它是因子
        if(i % j == 0) {
          factor += j;
        }
      }

      if(i == factor) {
        System.out.println(i);
      }

      // 重置 factor
      factor = 0;
    }

  }
 -->

----------------------------

### 特殊关键字的使用
> break
- 使用在switch case 和 循环结构中

- 作用:
- 结束当前循环


> continue
- 只使用在循环结构中

- 作用
- 结束当次循环

**注意:**
- 1. break 和 continue 的后面不能加其它的执行语句
- 2. break默认情况下 会跳出包裹此关键字最近的一层循环
<!-- 
  for(int i=1: i<=4; i++) {
    for(int j=1: j<=10; j++) {
      if(j % 4 == 0) {
        break;
      }
      System.out.print(j)
    }
    System.out.println()
  }

  // 123
  // 123
  // 123

  因为到4的时候就会结束内层循环 所以每次都是打印到123
 -->

- 3. continue也是跳出包裹此关键字的当次循环


> 如何让break 和 coutinue 跳出指定的for循环
- 在for循环的前面 打一个标记 标记: -- break 标记;
<!-- 
  label: for(int i=1: i<=4; i++) {
    for(int j=1: j<=10; j++) {
      if(j % 4 == 0) {
        break label;
      }
      System.out.print(j)
    }
    System.out.println()
  }
 -->

----------------------------

### 家庭记账软件
- 模拟实现一个基于文本界面的 家庭记账软件
- 主要设计以下的知识点
- 1. 变量的定义
- 2. 基本数据类型的使用
- 3. 循环语句
- 4. 分支语句
- 5. 方法声明 调用 和 返回值的接收
- 6. 简单的屏幕输出格式控制

<!-- 
  运行项目后显示的用户界面

  1. 收支明细
  2. 登记收入
  3. 登记支出
  4. 退出

  请选择(1-4): 
 -->

- 需求说明
- 假设家庭其实的生活基本金为10000元
- 每次登记收入后 收入的金额应累加到基本金上 并记录本次收入明细 以便后续的查询

- 每次登记支出后 支出的金额应从基本金中扣除 并记录本次支出明细 以便后续的查询

- 查询收支明细时 将显示所有的收入 支出明细列表

- 这里等到学完后面再回来看吧 有些不是技术性的问题

----------------------------

### 数组
- 数组是多个相同类型的数据 按一定顺序排列的集合 并使用一个名字命名
- 并通过编号的方式对这些数据进行统一的管理

- 数组的常见概念:
- 数组名
- 下标
- 元素
- 数组的长度

- 数组本身是**引用数据类型** 而数组中的元素可以是任何数据类型 包括基本数据类型 和 引用数据类型

- 创建数组对象会在内存中开辟**一整块** **连续的空间** 而数组名中引用的是这块连续空间的首地址
<!-- 
  数组中一块连续的空间 不会有断开的地方
  不连续的叫做链表 通过地址找到下一个表
 -->

- 数组的长度一旦确定 就不能修改
<!-- 
  长度一旦确定 就不能修改
  比如我做着做着发现还想在数组中增加的元素 在后面补补 不行补不了
 -->

- 我们可以直接通过下标的方式调用指定位置的元素 速度很快

- 数组的分类：
- 1. 按照维度
    一维数组 二维数组 ...

- 2. 按照元素的数据类型分: 
    基本数据类型元素的数组 引用数据类型元素的数组(即对象数组)



### 一维数组的初始化

> 一维数组的声明和初始化
- 数组的初始化 分为**静态初始化** 和 **动态初始化** 
- 数组是引用类型的数据 在创建数组的时候 需要使用 new 关键字


> 静态初始化
- 解析:
- 数组的初始化和数组元素的赋值操作同时进行

- 语法:
    - 数组类型[] 数组名 = new 数组类型[]{指定元素, 指定元素...}
    - int[] ids = new int[]{1, 2, 3};


> 动态初始化
- 解析:
- 数组的初始化和数组元素的赋值操作分开进行

- 语法:
    - 数组类型[] 数组名 = new 数组类型[指定数组长度]
    - String[] names = new String[5]

**注意:**
- 不管是静态初始化 还是 动态初始化 一旦数组初始化完成 数组的长度就确定了
- 长度一旦确定就不能修改
<!-- 
  也就是说 我们创建了一个长度为5的数组 然后我们要存7个数据
  那没有办法 只能再创建一个长度为7的数组 然后把数据一个个的复制进来
 -->


> 如何调用数组的指定位置的元素
- java中通过**索引**来给数组的元素赋值 或者 调用元素
<!-- 
  String[] names = new String[5];
  names[0] = "sam";
  names[1] = "erin";
  names[2] = "nn";
  
  我们这里只添加了3个元素
 -->  

**注意:**
- 这里注意 我们只能写到0 - 4 再给下标5添加数据的时候 在java中是不行的
- 数组的长度是5 但是我们只添加了3个元素 那么其余的两个元素为**null**
<!-- 
  这里跟js不一样 js中是undefined
 -->  


> 如何获取数组的长度
- 数组的下标是从0开始 到数组的长度-1结束

- 属性:
- length
<!-- 
  System.out.println(ids.length);
 -->


> 如何遍历数组
<!-- 
  String[] names = new String[5];

  for(int i=0; i<names.length; i++) {
    System.out.println(names[i]);
  }
 -->


> 数组元素的默认初始化值
- 我们没有给数组的元素指定值 但是该元素会有默认值
- 该初始化值是系统在给我们分配空间的时候自动指定的值

<!-- 
  // 该数组 我们并没有给元素指定 值
  int[] arr = new int[6];

  for(int i=0; i<arr.length; i++) {
    System.out.println(arr[i]);     // 0 int类型的数组的默认值
  }
 -->

> 数组的默认初始化值:
- 1. 所有数组的元素是整型的时候 它的初始化值都一样为: 0
<!-- 
  - int[]     初始化值为 0
  - byte[]    0
  - short[]   0
  - long[]    0

  long[] arr = new long[6]
 -->

- 2. 数组元素的类型为 浮点型 的时候 它的初始化值为: 0.0
<!-- 
  float[] arr = new float[6]
 -->

- 3. 数组元素的类型为 char 型 它的初始化值为: 0(asc2码的0) 
<!-- 
  控制台会显示不出来 像是空格
  但它不是真正的空格 它就是一个 asc2码的值
 -->

- 4. 数组元素的类型为 boolean 型 它的初始化值为: false
<!-- 
  因为在底层 false 就是0
  boolean[] arr = new boolean[6];
 -->

- 5. 数组元素的类型为 String 型 它的初始化值为: null
<!-- 
  String[] arr = new String[6]
-->

- 6. 所有的引用类型的初始值都为 null
<!-- 
  引用类型的变量 要么就是null 要么就是地址值
 -->


> 数组的内存解析
- 数组在内存中是怎么分配结构的

- 内存的简化结构:
- 先说下常用的结构 栈(stack) 和 堆(heap) 和 方法区(methodarea)
<!-- 
  stack栈
  栈是一个从下至上的结构 线性的放数据

  stack中存放着一般是局部变量(一般方法中的变量都是局部变量)
  后添加的在上面 当整个方法结束后 会释放变量 变量依次从栈顶弹出
  --------        
  | 数据4 |
  | 数据3 |
  | 数据2 |
  | 数据1 |
  --------


  heap堆
  堆中存放的数据是new出来的结构  比如 对象 和 数组
  ----------------------
  |                     |
  |                     |
  |                     |
  |                     |
  ----------------------


  methodarea
  静态域里存放着静态的变量
  方法区里面除了常量池 和 静态域之外 还有类加载的信息
  ----------------------------------
  |    常量池         静态域         |
  |   --------      -------------  |
  |   |       |     |           |  |
  |   |       |     |           |  |
  |   |       |     |           |  |
  |   --------      -------------  |
  |                                |
  ----------------------------------

  后面介绍的字符串就放在了 常量池
  static就放在了静态域中
 -->


> 示例： 一维数组的内存解析
- 通过代码我们看看下列的两种情况在内存中是如何分配 和 解析的
<!-- 
  int[] arr = new int[] {1, 2, 3};

  1. 放在main方法中的变量都是局部变量 局部变量都会在 栈结构 中 
      我们在栈结构中 放入arr变量

  2. new int[]{1,2,3} 只要是new出来的都是在 堆结构 中
      而且这个数组的长度是3 所以在堆结构中创建一个 长度为3且连续的存储的结构 并赋上元素的初始值

  3. 堆结构中的 □-□-□ 会有一个 首地址值(第一个元素的地址值)
      首地址值通常是用一个16进制的数(0x开头)来表示 我们会把这个地址值赋值给 栈空间 中的arr

  4. 栈空间中的arr变量 通过地址值 就能找到堆空间中的数组了

  5. 然后开始对堆空间中的数组进行赋值 将默认值替换掉

  --- 栈空间 ---        --- 堆空间 ---

  arr:0x34ab           □-□-□ (第一个元素会有一个首地址值: 0x34ab)

------

  String[] arr = new String[4];
  arr[1] = "刘德华";
  arr[2] = "张学友";
  arr = new String[3];

  1. String[] arr -- 该arr会在 栈空间中声明一个变量 arr
  2. new String[4]; -- 然后会在堆空间中开启一个长度为4且连续的数组
  3. 堆空间中的数组会有一个首地址值 将首地址值赋值给栈空间中的arr
  4. arr通过首地址值指向堆空间中数组的实体 并赋元素初始值

  5. 通过下标的找到堆空间的数组中的 第2 3个元素进行赋值
  6. arr又指向了一个新的数组

  原本的数组会触发垃圾回收(垃圾回收使用了 引用技术算法)

  // 引用技术算法
  - 判断下堆空间中的数组是否还有栈空间的引用指过来 现在发现栈空间没有引用指向这个数组 就意味着它不会再次被调用了 那就会被当做是垃圾 然后被回收 该垃圾会在一个不确定的时间被回收掉


  // 最后 整个main方法执行完毕后 局部变量都会没有了 依次会从栈顶弹出
  变量弹出后 堆空间中的数组没有变量指向它 它也会被当做垃圾被回收掉

  // 所以main方法执行完后 栈 和 堆 都会被清空掉
 -->

> 练习
- 升景坊单间短期出租4个月 550一个月(水电煤公摊 网费35) 空调 卫生间 厨房齐全
- 屋内均是it行业人士 喜欢安静 所以要求出租者最好是同行 或者 刚毕业的年轻人 爱干净 安静
<!-- 
  package src.com;
  public class Demo {
    public static void main(String[] args) {
      
      int[] arr = new int[]{8, 2, 1, 0, 3};
      int[] index = new int[]{2, 0, 3, 2, 4, 0, 1, 3, 2, 3, 3};
      String tel = "";
      for(int i=0; i<index.length; i++) {
        tel += arr[index[i]];
      }
      System.out.println("联系方式: " + tel);
    }
  }

  联系方式: 18013820100
 -->


> 练习2:
- 从键盘读入学生成绩 找出最高分 并输出学生成绩等级
- 成绩 >= 最高分 - 10  -- 等级为A
- 成绩 >= 最高分 - 20  -- 等级为B
- 成绩 >= 最高分 - 30  -- 等级为C
- 其余 等级为D

- 提示 先读入学生人数 根据人数创建 int数组 存放学生成绩

- 要点:
- 1. Scanner效果是让用户输入数据 在控制台中 然后我们用变量来接收数据
- 2. if else if 范围大的放在下面 范围小的放在上面
<!-- 
  package src.com;

  import java.util.Scanner;
  public class Demo {
    public static void main(String[] args) {

      int max = 0;
      Scanner scan = new Scanner(System.in);

      System.out.println("请输入学生人数");
      // 用户与控制台交互效果 让用户输入数据
      int count = scan.nextInt();

      // 根据学生个数创建数组
      int[] arr = new int[count];

      // 给数组的元素赋值
      System.out.println("请依次输入"+count+"名学生的成绩");
      for(int i=0; i<arr.length; i++) {
        arr[i] = scan.nextInt();
        if(arr[i] > max) {
          max = arr[i];
        }
      }

      for(int i=0; i<arr.length; i++) {
        // 范围小的放在上面 范围大的放在下面
        if(arr[i] >= max - 10) {
          System.out.println("成绩为" + arr[i] + " -- 对应等级是: A");
        } else if(arr[i] >= max - 20) {
          System.out.println("成绩为" + arr[i] + " -- 对应等级是: B");
        } else if(arr[i] >= max - 30) {
          System.out.println("成绩为" + arr[i] + " -- 对应等级是: C");
        } else {
          System.out.println("成绩为" + arr[i] + " -- 对应等级是: D");
        }
      }
    }
  }
 -->

----------------------------

### 多维数组的使用
- 数组属于引用数据类型 数组的元素也可以是引用数据类型

- java语言里提供了支持多维数组的语法
- 如果说可以把一维数组当成几何中的线性图形 那么二维数组就相当于一个表格 像右图excel中的表格一样
<!-- 
  姓名    联系电话
  sam    18698712060
 -->

- 对于二维数组的理解：
- 我们可以看成是一维数组arr1又作为另一个一维数组arr2的元素而存在
<!-- 
  是不是说 一维数组相当于flex 二维数组就是grid
  下面有说
 -->

> 应用场景
- 既然老师说二维数组就是像excel表格那样 姓名 和 电话 一一对应 而姓名和电话又各自是一个数组
- 然后我们就能用同一个index 获取对应位置的一组数据了
<!-- 
  name    tel
  sam     186

  name[0] : tel[0]
 -->

- 其实从数组底层的运行机制来看 其实没有多维数组
<!-- 
    --- 栈结构 ---      --- 堆结构 ---
                         □-□ □-□ □-□   
                        ↗ ↗ ↗
    arr        →       □-□-□

    本质上看arr还是一个一维数组 只不过arr中的每一个元素又是一个一维数组
 -->


> 二维数组的声明和初始化
- 和一维数组类似
<!-- 
  回顾一维数组
  int[] arr = new int[]{1,2,3}
 -->

> 二维数组静态初始化
- 语法:
- int[][] arr = new int[][]{{1,2,3}, {4,5,6}}
<!-- 
  [[1,2,3], [4,5,6]]
 -->

> 二维数组动态初始化
- new String[3][2] 
<!-- 
  -------------
  |     |     |   第一行  每行里面有两个元素 [?, ?]
  -------------
  |     |     |   第二行  每行里面有两个元素 [?, ?]
  -------------
  |     |     |   第三行  每行里面有两个元素 [?, ?]
  -------------

  [3]可以看做是3行
  [2]可以看做每行的两个元素  [?, ?]
 -->

- 语法:
- String[][] arr = new String[3][2]
- String[][] arr = new String[3][]
<!-- 
  String[][] arr = new String[3][2]
  先是3个元素构成的一个数组 内部的每一个元素又是一个数组 这个数组的长度为2
  [[1,2], [2,3], [4,5]]

  String[][] arr = new String[3][]
  [[], [], []]    里面还不知道是长度为几的数组
 -->


- 应用场景: 
- 1. String[][] arr = new String[3][2]
- 2. String[][] arr = new String[3][]

- 1的应用场景:
- 当我们 ”行“ ”列“ 都固定的情况下 我们使用 1

- 2的应用场景:
- 当我们 ”行“ 确定 但是 ”列“ 不确定是长度为几的数组的时候 我们可以先不指定 之后用到的时候再指定
<!-- 
  new String[3][]

  -------
  new Sting[3]    我们可以动态指定内层元素数组的长度
  -------
  new Sting[7]
  -------
  new Sting[10]
  -------
 -->


- 这样写也行
<!-- 
  int arr[] = new int[]{1, 2, 3}
  int arr[][] = new int[]{{1, 2, 3}, {4, 5, 6}}

  int[] arr[] = new int[]{{1, 2, 3}, {4, 5, 6}}
 -->


> 数组的简写形式 (类型推断)
- 只针对于静态数组的创建方式 
<!-- 
  其实就是 let arr = [1,2,3] 和 let arr = new Array(1,2,3) 一样
 -->

- 语法：
- int[] arr = {1,2,3}

- 语法:
- int[][] arr = {{1,2,3}, {1,2,3}}


**注意：**
- 简写方式的时候 静态数组的 创建和初始化是在一行的可以简写
- int[] arr = {1,2,3}   // ok

- int[] arr;
- arr = {1,2,3}         // error

- int[] arr;
- arr = new int[]{1, 2, 3}    // ok


> 如何调用数组的指定位置的元素
- 静态初始化的二维数组 的指定位置的元素
- int[][] arr = new int[][]{{1,2,3}, {4,5}};    // 输出2
- System.out.println(arr[0][1]);

- 动态初始化的二维数组 的指定位置的元素
- String[][] arr2 = new String[3][2];   // 输出null
- System.out.println(arr2[1][1]);

> 有点难的地方
- String[][] arr3 = new String[3][];    // 报错
- System.out.println(arr3[1][0]);
<!-- 
  java.lang.NullPointerException
  空指针 的报错信息

  new String[3][]
        --  显示创建了 3行 但是每一行的位置是空的
        -- 每一行的位置应该存的是 另一个一维数组的地址值
        -- 现在没有创建另一个一维数组 就没有地址值 就是空指针
      

  new String[3][]
      这只是有了3行元素 但是每个元素上还没有东西
      我们要是想输出System.out.println
      就要赋值
 -->

- new String[3][]  --  arr3[1][0]
- 上面说了假如我们直接输出的话 会报错
- 因为每一行的元素 还没有值 我们假如想打印第2行的第一个元素 就必须先赋值
- 怎么赋值呢？
- arr3[1] 是第二行元素
- arr3[1] = new String[3]
- 既然每一个元素还是一个一维数组 那我就给它设置为一维数组 长度为3 这样它就又默认值了
<!-- 
  String[][] arr3 = new String[3][];
  // System.out.println(arr3[1][0]);  报空指针的错
  arr3[1] = new String[3];
  System.out.println(arr3[1][0]);

  输出2维数组中的一个元素
  这个元素是一个长度为3的一维数组 
  输出这个一维数组的第0个值
 -->

- 如果定义的是3维数组 那就是3个 String[][][] arr = new ...


> 如何获取数组的长度
- 只要是数组就应该有 length 属性

- int[][] arr = new int[][]{{1,2,3}, {4,5}, {6,7,8}};
- System.out.println(arr.length);   // 3
<!-- 
  上面这样是打印 arr 这个数组的长度 跟它每一个元素（又是一个一维数组)没有关系

  arr[1].length  查看的是 内部第2个元素对应的数组的长度
-->


> 如何遍历二维数组
- 需要双层for循环
- 3维数组就是3层for循环
<!-- 
  int[][] arr = new int[][]{{1,2,3}, {4,5}, {6,7,8}};
  System.out.println(arr.length);   // 3

  for(int i=0; i<arr.length; i++) {
    // 输出二维数组的外层所有元素;
    System.out.println("@整体数组的每个元素为" + arr[i]); 

    for(int j=0; j<arr[i].length; j++) {

      // 输出二维数组的每一个元素对应的数组
      System.out.println("#内层每一个元素中的一维数组的元素为" + arr[i][j]);

    }
  }
 -->


> 数组元素的默认值初始化值
- 规定：
- 二维数组分为外层数组的元素 和 内层数组的元素
<!-- 
  int[] arr = new int[4][3]
  外层元素:
    arr[0], arr[1], arr[2], arr[3], 

  内层元素:
    arr[0][0], arr[0][1], arr[0][2], 
 -->

- 外层数组：
- 因为外层数组的每一个元素就是一个一维数组 这时候我们输出的 就会是这个一维数组的地址值
<!-- 
  因为变量里面保存的就是地址值
  而外层数组的每一个元素位保存的就是 另一个一维数组的地址值
 -->

<!-- 
  // 只有动态创建的数组 才能够看出来 默认值
  // 外层元素的默认值
  System.out.println(arr[0]);     // [I@626b2d4a地址值

  // 内层元素的默认值
  System.out.println(arr[0][0]);  // 0
 -->

> 地址值解析 [I@626b2d4a
- [ -- 一维数组
<!-- 
  [   一维
  [[  二维
 -->  

- I        -- int型
- F        -- float型
- Ljava.lang.String;@5e265ba4  -- string
- @        -- 在什么位置
- 626b2d4a -- 真正的地址值 16进制标识的


- int[][] arr1 = new int[4][];
- System.out.println(arr1[3]);     // null
- System.out.println(arr1[3][1]);  // 报错


> 总结
- 针对于初始化方式一: int[][] arr1 = new int[4][2]
    - 外层元素的初始化值为: 地址值
    - 内层元素的初始化值为: 与一维数组初始化情况相同

- 针对于初始化方式二: int[][] arr1 = new int[4][]
    - 外层元素的初始化值为: null
    - 内层元素的初始化值为: 报错 不能调用 空指针异常


> 二维数组的内存解析
<!-- 
  int[][] arr = new int[4][];
  arr[1] = new int[]{1, 2, 3}
  arr[2] = new int[4]
  arr[2][1] = 30



  int[][] arr = new int[4][];
  因为是[4][] 所以arr的每一个元素的默认值为 int[] 
  但是int[] 还没有赋值 就是null
  因为默认值是什么取决于这个数组对应元素的类型

  --- 栈结构 ---          --- 堆结构 ---

                          首地址值: 0x1234
                          ---------
                          int[] -- null
                          ---------
                          int[] -- null   → 
                          ---------
                          int[] -- null
                          ---------
                          int[] -- null
  arr:0x1234              ---------


  arr[1] = new int[]{1, 2, 3}
  通过 arr[1] 索引 找到了第2行的元素
  new int[]{1, 2, 3} 给它赋了一个数组 这时候的默认值就是 int - 0

                        首地址值: 0x7788
  ---------             ---------
  0x7788        →       0 0 0    --  1 2 3
  ---------             ---------
 -->


> 练习1
- 声明: int[] x, y[] 在给x y变量赋值以后 以下选项允许通过编译的是
<!-- 
  x是一维数组
  y是二维数组   相当于

  int[] x;
  int[][] y;
  int[] y[];
 -->

- a. x[0] = y
<!-- 
  x是一个一维数组 
  x[0] 是一维数组中的一个数字

  y是一个二维数组

  数字 和 二维数组的类型不一样 在java中不能赋值
  int num = 1
  int[] arr = {1, 2, 3}
  num = arr; 

  // 不適合な型: int[]をintに変換できません:
  类型不符 且不能自动类型提升
 -->

- b. y[0] = x
<!-- 
  二维数组的元素是一维的 x也是一维的 类型相同可以赋值
 -->

- c. y[0][0] = x
<!-- 
    y[0][0] 它是int型的一个数字
    x是一个数组

    类型不同 不行
 -->

- d. x[0][0] = y

- e. y[0][0] = x[0]
<!-- 
  双方都是int型的数字 类型相同 可以赋值
 -->

- f. x = y
<!-- 
  类型不同 因为 一个一维数组 一个二维数组 类型不同 不能赋值
  int[]

  int[][]

  java在定义变量的时候就给变量确定的类型 赋值的时候 只有同类型的才能相互赋值
 -->

- 要点：
- 赋值的时候 同类型之间的才能赋值
<!-- 
  比如 flase 只能赋值给 布尔值
  比如 1.1 只能赋值给 浮点型
 -->

- 能不能通过编译 就看 满足不满足 赋值的规则


> 练习2
- 使用二维数组打印一个 10行的 杨辉三角

- 提示
- 第一行有一个元素 第n行有n个元素
- 第一行的第一个元素 和 最后一个元素都是1
- 从第三行开始 对于非第一个元素 和 最后一个元素的即


- 杨辉三角
- 随便找一个数字 这个数字上面的数字 和 上面数字左面的数字的和 等于随便找的这个数字
- 用代码翻译的话 就是

-   随便找的数字    上行数字的左侧数字      上行数字
- yanghui[i][j] = yanghui[i-1][j-1] + yanghui[i-1][j]

<!-- 
      1
      1 1
      1 2 1
      1 3 3 1
      1 4 6 4 1
      1 5 10 10 5 1
 -->

- 每行除了第一个 和 最后一个数字 其余的数字都按照这个规律来就是杨辉三角

- 思路：
- 我们造一个二维数组 然后给这个二维数组赋值 在赋值的时候满足这个规律就可以了
































----------------------------

### 创建工程的流程
> 1. 先创建 package
<!-- 
  包名: 小写
  作用: 包相当于一个班级 每一个java文件相当于一个同学

  包名规范:
    公司域名倒叙.项目功能名
    com.atguigu.contact

  网上说创建一个包 就是创建一个文件夹 但是文件夹中不能出现.
  所以创建包的时候 com/demo
 -->


> vs code中的包
- vscode中是根据打开的文件夹来选定包名 也就是说 文件夹就是包
- 1. 如果 .java 文件处于打开的文件夹的根目录下 就不会被要求输入包名
- 2. 如果 .java 文件处于打开文件夹的子文件夹中 .java文件会全部被要求在文件头处输入 package 语句

> package 文件夹名;
- 上面就是如果 .java 文件处于子文件夹中 就要求该文件在开头出 写上这样的语句
  

> 2. 在创建好的包下 右键创建class 就会生成一个java文件
<!-- 这是在老师讲的es编辑器中是这么操作的 -->

- https://blog.csdn.net/weixin_39777637/article/details/110474775



> 有 包 的情况下的 命令行 方式
- package src.com;
- java_exer
  - com
    Demo.java

- 1. 注意包名结构 返回 最开的src的上一层目录
- 执行命令: javac -d . src/包名(文件夹名)/文件名.java
- 执行命令: java src.包名.类名 (执行这个包下的指定类)
<!-- 
  javac -d . src/com/Demo.java
  java src.com.Demo

  注意:
  - 1. 返回src的上一层执行命令
  - 2. 路径都是从src开始的
 -->

> 命令解析:
- 指定编译生成的class文件存放路径 javac -d
- -d 指明 类层次的根目录
- . 就是当前目录


> 包名的命名规范
- https://www.cnblogs.com/luckforefforts/p/13642694.html


### Java基础教程所需软件下载地址：
- 链接: 
- https://pan.baidu.com/s/10P6JbKN6TG7wW-QXV8ANdQ 提取码: nkbv


### 基础扩展部分

### 命令
- java
  执行java文件时 使用的命令

- javac
  编译的时候 使用的命令
  编译成面都是些语法层面的问题

- javadoc
  生成一个以网页形式的文档


> Java当中的多环境切换
<!-- 
  "java.configuration.runtimes": [
      {
          "name": "JavaSE-1.8",
          "path": "D:\\soft\\Java\\jdk1.8.0_231",
          "default": true
      },
      {
          "name": "JavaSE-11",
          "path": "D:\\soft\\Java\\jdk-11.0.2",
      },
  ],
 -->


### Oracle密码
- Xl5467426/
https://login.oracle.com/mysso/signon.jsp


/Library/Java/JavaVirtualMachines/jdk-11.0.13.jdk/Contents/Home/
/Library/Java/JavaVirtualMachines/jdk1.8.0_311.jdk/Contents/Home/


/Library/Java/JavaVirtualMachines/jdk-11.0.13.jdk/Contents/Home


> 环境变量
JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_311.jdk/Contents/Home/
PATH=$JAVA_HOME/bin:$PATH:
CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.
export JAVA_HOME
export PATH
export CLASSPATH


- 多版本jdk切换
<!-- 
  export JAVA_8_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_311.jdk/Contents/Home
  export JAVA_11_HOME=/Library/Java/JavaVirtualMachines/jdk-11.0.13.jdk/Contents/Home

  export JAVA_HOME=$JAVA_8_HOME

  alias jdk8="export JAVA_HOME=$JAVA_8_HOME"
  alias jdk11="export JAVA_HOME=$JAVA_11_HOME"

  export PATH=$PATH:$JAVA_HOME/bin:$GRADLE_HOME/bin
 -->

- sudo -i vi /etc/.bash_profile
- source /etc/.bash_profile

- source ~/.bash_profile



### 环境搭建

> JDK
- 它是提供给java开发人员使用的 其中包含了java的开发工具 也包括了JRE
- 安装了JDK 就不用单独安装JRE了
- JDK里面包含了两个部分

- JRE java运行环境
- 开发工具： 编译工具 javac.exe  打包工具 jar.exe等


> JRE java运行环境
- 包括java虚拟机和java程序所需的核心类库(java se)等
- 如果想要运行一个开发好的java程序 计算机中只需要安装JRE即可

- 简单而言 使用 JDK 的开发工具完成的java程序 交给JRE去运行


> JRD
- JRD = JVM + Java核心类库


> 环境变量中的 JAVA_HOME
- 它里面存的是bin的上一层目录
<!-- path = %JAVA_HOME%\bin   //这是window里面的 -->


> JDK的安装地址
- www.oracle.com
- java.sun.com


### Java
- java基础是学习javaEE 大数据 android开发的基石

- 常用语法
- C C++ Java PHP Kotlin Python Scala等
<!-- 
  Kotlin 谷歌出的语言 用来开发安卓的
  python 快速开发效率高 适合处理数据 跟java比起来小巫见大巫
  Oc 苹果的开发语言
  Go 具有java的开发效率 和 C的执行效率
 -->

- Java语言的应用可以应用在3个不同的领域当中

>  Java SE 标准版
- 支持面向桌面级应用的Java平台 提供了完整的Java核心API 此版本以前成为J2EE
<!-- QQ 360 -->

>  Java EE 企业版
- 为企业环境下的应用程序提供的一套解决方案 该技术体系中包含的技术如 Servlet Jsp等 主要针对Web应用程序开发 版本以前成为 J2EE
<!-- Web后台 -->

>  Java ME 小型版
- 支持Java程勋运行在移动端上的平台 对Java API有所精简 并加入了针对移动端的支持 此版本以前成J2ME

>  现在 Java 应用的领域
- 1. 企业级应用
  后台开发
  主要指复杂的大企业的软件系统 各种类型的网站 java的安全机制以及它的跨平台的优势 使它在分布式系统领域开发中有广泛应用 应用领域包括金融 电信 电子商务

- 2. Android平台应用
  安卓应用程序使用java语言编写 安卓开发水平的高低很大程度上取决于java语言核心能力是否扎实

- 3. 大数据平台开发
  大数据都提供给java接口


>  java语言的特点
- 跨平台性
- 我们java的应用程序实际上是跑在JVM上面的 JVM装在了不同的操作系统上 因为有了JVM 同一个Java程序在三个不同的操作系统中都可以执行 这样实现的java程序的跨平台性

- 不同操作系统的jvm不同
<!-- 
  window linux mac
 -->


> JVM 虚拟机
- jvm是一个虚拟的计算机 具有指令集并使用不同的存储区域 负责执行指令 管理数据 内存 寄存器

- 对于不同的平台 有不同的虚拟机
- 只有某平台踢动了对应的java虚拟机 java程序才可以在此平台运行
- java虚拟机机制屏蔽了底层运行平台的差别 实现了 一次编译 到处运行


### 人机交互方式
- 图形化界面 GUI
- 命令行方式 CLI
- 需要有一个控制台 输入特定的指令 让计算机完成一些操作


### 中央处理器
- CPU是计算机的大脑，它从内存中获取指令 然后执行这些指令

- 包括：
- 控制单元 和 算术/逻辑单元

- 控制单元：
- 用于控制和协调其他组件的动作

- 算术/逻辑单元：
- 用于完成数值运算 + - * / 和逻辑运算比较

- 每台计算机中都有一个内部时钟 该时钟以固定速度发射电子脉冲 时钟速度越快 在给定的时间段内执行的指令就越多
- 速度的计量单位是Hz 1Hz相当于每秒一个脉冲 随着cpu速度不断的提供 目前以千兆赫GHz来表述
<!-- 
  买电脑看GHz

  1khz = 1024hz
  1mhz = 1024khz
  1ghz = 1024mhz
 -->

- 最初一个cpu只有一个核core， 核是处理器中实现指令读取和执行的部分
- 一个多核cpu是一个具有两个或者更多独立核的组件 可提高cpu的处理能力

--------------------------------

### 计算机的硬件介绍
<!-- 
  输入设备 -- > 存   储   器 -- > 输出设备

             ↑ ↓       影↓ ↑虚

      -------------------------------
            运算器      控制器
      -------------CPU---------------


            实体箭头 - 数据流
            影体箭头 - 指令流
            虚线箭头 - 控制流
 -->

--------------------------------

### IT定律之计算机行业发展规律
- 摩尔定律
- 安迪-比尔定律
- 反摩尔定律

--------------------------------

### 计算机硬件介绍
- 内存中的信息在断电的时候会丢失 那么我们可以考虑将程序和数据永久的保存在存储设备上
- 当计算机确定需要这些数据的时候 再移入内存 因为从内存中读取比从存储设备读取要快得多

- 存储设备主要有以下三种

> 磁盘驱动器
- 每台计算机至少有一个硬盘驱动器 硬盘用于永久的保存数据和程序

> 光盘驱动器 CD DVD
- CD的容量可达700mb
- DVD的容量可达4.7gb

> USB闪存驱动器
- 通用串行总线 可以使用usb打印机 数码相机 鼠标 外部硬盘驱动器连接到计算机上
- usb闪存驱动器很小 可用于存储和传输数据的设备


> 比特bit 和 字节byte
- 在讨论内存前 先清除数据是如何存储在计算机中的

- 计算机就是一系列的电路开关 每个开关存在两种状态：
- 关 和 开
- 如果电路是开的 它的值就是1
- 如果电路是关的 它的值就是0

- 一个0 或者 一个1存储为一个比特bit 是计算机中最小的存储单位
- 计算机中最基本的存储单元是字节 byte 每个字节由8个比特构成 从存储数据的角度来看字节才是最小的单位

- 计算机的存储能力是以字节和多字节来衡量的如下

  千字节    kb = 1024b
  兆字节    mb = 1024kb
  千兆字节  gb = 1024mb
  万亿字节  tb = 1024gb

- 后面还有pb eb zb yb等单位


> 内存 RAM
- 由一个有序的字节序列组成 用于存储程序以及程序需要的数据
- 一个程序和他的数据在被cpu执行前必须移动计算机的内存中

- 每个字节都有一个唯一的地址 使用这个地址确定字节的位置 以便于存储和获取数据
<!-- 
  2000    01000011
  2001    01110010
 -->

- 一个计算机具有的ram越多 它的运行速度就越快 但是此规律是有限制的
- 内存与cpu一样 也构建在表面嵌有数百万晶体管的硅半导体芯片上 但内存芯片更简单 更低速 更便宜

<!-- 
      CPU         内存         硬盘

                              美女.jpg    二进制文件

  怎么将图片显示在屏幕上是要做运算的 并不是从硬盘直接到cpu 
  要想要cpu使用硬盘的数据 必须要将数据加载到 内存中

  cpu 只跟内存 进行交互 cpu的数据都是从内存中来来回回的读 再写到内存当中

  硬盘中的数据必须也要先加载到内存里面 
 -->

- 实测发现：
- 内存的读取数据的速度是硬盘读取速度的10倍 在某些环境里 硬盘和内存之间的速度差距可能会更大 而cpu的速度比内存不知道还要快多少倍

- 当我们把程序从硬盘放到内存以后 cpu就直接在内存运行程序 这样比cpu直接在硬盘运行程序要快很多

- 内存解决了一部分cpu运行过快 而硬盘数据存取太慢的问题 提供了我们电脑的运行速度 内存就如同一条高速车道 数据由传输速度较慢的硬盘通过这高速车道传送至cpu进行处理

- 但内存是带电存储的一旦断电数据就会消失 而且容量有限 所以要长时间存储程序或数据就需要使用硬盘

- 内存在这里起了两个作用
- 1. 保存硬盘读取的数据 提供给cpu使用
- 2. 保存cpu的一些临时执行结果 以便cpu下次使用或保存到硬盘

--------------------------------

### 输入与输出设备
- 常见的输入设备
  键盘 和 鼠标

- 常见的输出设备
  显示器 和 打印机

- 显示器屏幕分辨率：
  是指显示设备水平和垂直方向上显示的像素 px 
  分辨率可以手工设置
  分辨率越高 图像越锐化 越清晰

--------------------------------

### 万维网 因特网 互联网
- 关系
- 互联网 > 因特网 > 万维网
<!-- 
  万维网是无数个网络站点和网页的集合 他们在一起构成了因特网最主要的部分
  它实际上是多媒体的集合 是由超级链接连接而成的 我们通常通过网络浏览器上网观看的 就是万维网的内容

  万维网只是因特网最主要的一个部分 这里只说了 web客户端和web服务端
  因特网实际上还包含了 电子邮件 usenet以及新闻组

  互联网是最大的一个概念
 -->

--------------------------------

### 字符集
- 在计算机的底层都是2进制的 所有的汉字代码在底层存的时候 都是010101
- 比如
  一个 a 它是97
  一个 b 它是98
  一个 c 它是99

  我们将 97 98 99 用二进制去表示 传递给计算机底层
  当我们打开某个文件的时候 再通过某种字符集的方式再还原回去a b c

  我们如何将 a 对应成 2进制 再还原回来 中间的对应关系 就叫做字符集
  <!-- 
    Unicode 编码

    - 乱码
    - 世界上存在着多种编码方式 同一个二进制数字可以被解释成不同的符号 因此 要想打开一个文本文件 就必须知道它的编码方式 否则用错误的编码方式解读 就会出现乱码


    - unicode
    - 一种编码 将世界上所有的符号都纳入其中 每一个符号都给予一个独一无二的编码 使用 unicode没有乱码的问题


    - unicode的缺点
    - unicode只规定了符号的二进制代码 却没有规定这个二进制代码应该如何存储 无法区别unicode和asc2 

    - 计算机无法区分三个字节表示一个符号还是分别表示三个符号 另外我们知道 英文字母只用一个字节表示就够了 如果unicode统一规定 每个符号用三个或者四个字节表示 那么每个英文字母前必然有2到3个字节是0 这对存储空间来说是极大的浪费



    真正落地实施的是 utf-8
    它是unicode是一种实现方式 也是更大的一种字符集 它是一种边长的编码方式 它可以使用1-6个字节表示一个符号 根据不同的符号而变化字节的长度

    - utf-8的编码规则
    - 对于单字节的utf-8编码 该字节的最高位为0 其余7位用来对字符进行编码
    - 对于多字节的utf-8编码 如果编码包含n个字节 那么第一个字节的前n位为1
    - 第一个字节的n + 1位为0 该字节的剩余各位用来对字符进行编码 在第一个字节之后的所有字节 都是最高两位为 10 其余6位用来对字符进行编码
   -->


### 数据结构
- 1. 数据 与 数据 之间的逻辑关系: 比如
- 集合 一对一 一对多 多对多
- 一对一 - 类似链表
- 一对多 - 树形结构(DOM树 顶层为html)
<!-- 
    一对2 就是 2叉树
    一对3 就是 3叉树

      a
    ↙   ↘
  □      □
-->

- 多对多
- 典型的就是社交网络 每一个人都是一个节点 这个节点可以延伸出很多别的好友 别的好友也有可能是你 也就是说 你可以发散出去 别人也可以发散到你这里来
<!-- 
    □     □
      ↖ ↗
       □
      ↙ ↘
    □     □
-->

- 2. 数据的存储结构
- 数据之间的关系我们知道了后 我们需要将数据在内存层面 或者 硬盘层面存储起来 我们怎么通过实际的存储结构去刻画 上面说的关系呢？

- 线性表: 主要刻画的是 一对第一 的关系
    - 1. 顺序表（典型的实现就是数组）
    - 2. 链表（它就不是连续的了 依靠的是指针）
    - 3. 栈结构（先进后出 从顶层弹出）
    - 4. 队列（队列是有两个口的 左进右出 谁先进来 谁先出去）


- 树形结构: 主要刻画的是 一对多 的关系
    - 1. 二叉树


- 图形结构: 主要刻画的是 多对多


> 算法
- 排序算法
- 搜索算法