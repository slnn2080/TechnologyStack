### java学习路线
- java基础
  - javaweb
    - 常用框架技术
      - 微服务开发
        - 分布式高级
          - 项目实战

- 这个视频下方的链接里面 有完整的学习视频 
- https://www.bilibili.com/video/BV1Rq4y1G7WL?from=search&seid=12422859657765526209&spm_id_from=333.337.0.0

- 视频的学习路线
- https://www.bilibili.com/read/cv5216534?spm_id_from=333.788.b_636f6d6d656e74.7


- javascript 数据结构与算法
- https://www.bilibili.com/video/BV1x7411L7Q7?from=search&seid=12134091894926563791&spm_id_from=333.337.0.0

- java 数据结构与算法
- https://www.bilibili.com/video/BV1E4411H73v?from=search&seid=5591420206587441709&spm_id_from=333.337.0.0


- 1. java基础部分
  - 宋红康视频

  - mysql
  - 宋红康视频 只有基础部分
  - https://www.bilibili.com/video/BV1iq4y1u7vj?from=search&seid=5669396497179590778&spm_id_from=333.337.0.0

  - 李老师视频 基础部分和高级部分 比较全
  - https://www.bilibili.com/video/BV12b411K7Zu?from=search&seid=5669396497179590778&spm_id_from=333.337.0.0

  - jdbc

- 2. javaweb部分
  - https://www.bilibili.com/video/BV1Y7411K7zz

  - 在这个部分我们需要懂如下的核心
  - servlet
  - filter
  - listener
  - cookie&session原理
  

- 3. 常用框架
  - maven   怎么把项目搭建 架构出来 1天

  - spring5
  - https://www.bilibili.com/video/BV1Vf4y127N5 5天

  - springMVC 开发网页应用的
  - https://www.bilibili.com/video/BV1Ry4y1574R 3天

  - mybaits3  操作数据库的 4天 原理扩展等视频可以跳过
  - mybaits plus

  - ssm整合
  - https://www.bilibili.com/video/BV17W411g7zP

- 4. 微服务开发
  - linux
  - https://www.bilibili.com/video/BV11W411T7jR

  - redis6最新版
  - redis经典版
  - springBoot2 原理先不用听 我们要用起来后才知道原理 场景整合先不用管
  - https://www.bilibili.com/video/BV19K4y1L7MT
  <!-- 
    我们在学完常用创建之后做SSM整合项目的时候会很麻烦 要写一堆配置的东西
    springBoot2 可以帮我们完成这些配置的自动化 它是对常用框架的总结

    老师推荐好好听 花上10天的时间
   -->

  - springCould 只听入门
  - 尚筹网

- 5. 分布式高级(为了面试长见识)
  - git gitee github
  - zookeeper
  - docker
  - elasticSearch
  - 谷粒学院

- 6. 项目实战
  - 谷粒商城 大型分布式电商项目 40天

--- 上面是初学者25k应该掌握的东西 ---

- 1. 大数据 运维 前端了解
- 2. docker k8s云平台熟悉
- 3. 各种技术深入理解
- 4. 掌握多门语言更佳

----------------------------

### java版的hello world
- 1. 将 java 代码编写到扩展名为 .java 的文件中
- 2. 通过 javac 命令对象该文件进行编译

> javac Java文件名
- 将文件编译为字节码文件
- 语法不对就会编译不通过
<!-- 
  javac demo.java
  .java文件会被编译成 字节码文件(.class文件)
 -->

> java 字节码文件名(类名) -- 不要.class后缀
- 执行字节码文件
- 3. 通过 java 命令对生成的class文件进行运行
- 这里注意 我们使用 java 运行字节码文件的时候不要加.class后缀
<!-- 
  java HelloChina
 -->

- 完整的步骤
<!-- 
  class HelloChina {
    public static void main(String[] args) {
      System.out.println("Hello, world");
    }
  }

  javac demo.java
  java HelloChina     // 这里没有后缀名 .class
 -->  


> 注意：
- 1. classpath的问题
  - 当我们使用 java HelloChina 去执行这个.class字节码文件的时候 可能会提示操作 找不到或无法加载主类 HelloChina

  - 这可能是我们配置过classpath 我们可能在网上看过 除了配置path环境变量之外还要配置classpath

  - 不用配置classpath， classpath就是.class字节码文件的path 如果我们配置了classpath就意味着 我们写 java HelloChina 的时候 会去classpath里面找 而实际上我们的字节码文件可能在别的位置上 所以会报错

  - 默认会在当前路径下找 .class 文件

- 2. java文件里面单词严格区别大小写
- 3. java文件里面执行语句后都要有分号
<!-- 
  System.out.println("Hello, world");
 -->

- 4. 一个源文件中是可以声明多个class类的 但是只能最多有一个类可以被声明为 public的
<!-- 
  public 用来修改这个类的权限大小
  同时 
  public关键字 只能加在和文件名同名的类前 类名和源文件名必须相同
  文件名为demo 那么public只能加在 demo类前 public class demo { }
 -->

- 5. 程序的入口是main()方法  格式是固定的
<!-- 
  class Hello {
    // main()方法
    public static void main(String[] args) {

    }
  }
 -->

- 6. 输出语句
> System.out.println("")
- 该语法会在语句输出后 换行  先输出后换行
<!-- 
  System.out.println()    // 里面什么也不写的话 就是代表换行
 -->

> System.out.print("")
- 该语法不会换行

- 7. 每一条执行语句都以分号结尾
<!-- 
  技巧:
  从右往左看 除了 } 结尾的 剩下的都要以分号结尾
 -->

> System.currentTimeMillis()
- 它的返回值是 long型 的毫秒数
- 跟 console.time 一样可以用来测试程序的性能
<!-- 
  long start = System.currentTimeMillis();
 -->


> 编译过程
- 编译以后 会生成一个或多个字节码文件 有几个类就会有几个字节码文件
- 字节码文件的文件名与java源文件中的类名相同


> 特性
- 面向对象性：
  两个要素: 类 对象
  三个特征: 封装 继承 多态

- 健壮性:
- 去除了c语言中的指针 有了自动的垃圾回收机制

- 跨平台性
- 功劳归功于 jvm 我们现在使用的虚拟机是 hotspot

----------------------------

### 注释
- 用于注解说明解释程序的文字就是注释
- java中的注释类型

> 单行注释  //

> 多行注释  /* */

> 文档注释(java特有)
- 语法：
  /**

  */

- 注释内容可以被JDK提供的工具 javadoc 所解析 生成一套以网页文件形式体现的该程序的说明文档

- javadoc 解析的类 类前要加上 public
- javadoc 只能解析 文档注释标记起来的内容
<!-- 
  /** 
    文档注释
    @author: sam
    @version: v1.0
    
    这是我的第一个程序
  */
  public class Demo { ... }
 -->

> 执行命令
- javac -d 文件名字 -author -version 文件名.java
- 生成的文件夹会在当前目录
- -author -version对应着@author @version

----------------------------

### 关键字 和 保留字

> 关键字
- 定义:
- 被java语言赋予了特殊的含义 用作专门用途的字符串

- 特点
- 关键字中所有字母都为小写

- 网址
- https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keyword.html

<!-- 
  用于定义数据类型的关键字

    class     interface     enum      byte      short
    int       long          float     double   char
    boolean   void



  用于定义流程控制的关键字

    if      else    switch    case    default
    while   do      for       break   continue
    return



  用于定义访问权限修饰符的关键字

    private   protected   public



  用于定义类 函数 变量修饰符的关键字

    abstract    final   static    synchronized


  
  用于定义类与类之间关系的关键字

    extends   implements


  
  用于定义建立实例及引用实例 判断实例的关键字

    new     this      super     instanceof



  用于包的关键字

    package   import



  其他修饰符关键字

    native    strictfp    transjent   volatile    assert



  用于定义数据类型值的字面值    下面的三个不算关键字 但还可以当做关注字

    true    false   null
 -->


> 保留字
- 现有java版本尚未使用 但以后版本可能会作为关键字使用 自己命名标识符时要避免使用这些保留字
<!-- goto const 等 -->

----------------------------

### 标识符
- java对各种变量 方法 和 类等要素命名时使用的 字符序列(单词) 被称为标识符
- 总的来说 凡事自己可以起名字的地方都叫做标识符

> 定义合法标识符规则
- 26个英文字母大小写 0-9 _ $ 组成
- 数字不可以开头
- 不可以使用关键字和保留字 但能包含关键字和保留字
- java中严格区分大小写 长度无限制
- 标识符不能包含空格


> 命名规范
- 包名
- 多单词组成时所有字母都小写 xxxyyyzzz

- 类名 接口名 大驼峰
- 多单词组成时 第一个单词首字母小写 第二个单词开始每个单词首字母大写 XxxYyyZzz

- 变量名 方法名 小驼峰
- 多单词组成时 第一个单词首字母小写 第二个单词开始每个单词首字母大写 xxxYyyZzz

- 常量名
- 所有字母都大写，多单词时每个单词用下划线连接 XXX_YYY_ZZZ

**注意：**
- 如果不遵守如上的规则 编译可以通过 编译能通过 运行也没有问题 但建议遵守
 
----------------------------

### 变量

> 变量的概念
- 内存中的一个存储区域
- 该区域的数据可以在**同一类型范围内**不断变化
<!-- 
  只能在同类型的值之间进行相互的赋值
 -->

- 变量是程序中最基本的存储单元 包含变量类型 变量名 存储的值


> 变量的作用
- 用在内存中保存数据


> 使用变量的注意
- 1. java中每个变量必须**先声明 后使用**
- 2. 使用变量名来访问这块区域的数据

- 3. 变量的作用域：
    其定义所在的一对{ }内

- 4. 变量只有在其作用域内才有效
- 5. 同一个作用域内 不能定义重名的变量


> 数据类型 变量名 = 变量值
- java定义变量的格式
<!-- 
  // 整型
    int myNum = 666;
    
  // 或者还可以这么写
    int myAge;
    myAge = 18;
 -->

**注意：**
- 1. 变量必须要赋初始值
- 2. 变量必须先声明后使用 注意书写顺序
- 3. 变量有作用域 在作用域内有效
- 4. 同一个作用域内 不能声明同名变量
<!-- 
  int myAge;
  System.out.println(myAge);    // 错误: 可能尚未初始化变量myAge
 -->


> 变量的类型 --- 按照类型区分
- 数据类型分为两类
- 1. 基本数据类型
    - 数值型
        - 整数类型(byte, short, int, long)  百特
        <!-- 存储空间是从小到大来的 -->

        - 浮点类型(float, double)

    - 字符型(char)

    - 布尔型(boolean)


- 2. 引用数据类型
    - 类(class)
    - java里字符串String是一个 类 的类型 也就是引用类型
    <!-- 
      同时我们存大量的字符的时候 好像也没有办法使用char 
      因为老师这意思char里只能装一个字符
     -->

    - 接口(interface)
    - 数组([])


> 变量的类型 --- 在类中声明的位置(面向对象的时候会详细讲)
- 成员变量
- 局部变量

- 补充知识：
- 在方法体外 类体内 声明的变量成为 成员变量
- 在方法体内       声明的变量成为 局部变量
<!--          
                      实例变量 -- 不以static修饰
            成员变量
                      类变量   -- 以static修饰
  所有变量

                      形参(方法 构造器中定义的变量)
            局部变量   方法局部变量 (在方法内定义)   
                      代码块局部变量 (在代码块内定义)

  注意：
  两者在初始化值方面的异同

  同：都有生命周期
  异：局部变量除形参外 需显示初始化
 -->

    
> 基本数据类型的使用 -- 整型
- 表示整数的 正负都可以 java中定义了4中整型 区别就是它们占用的空间不一样
- java各整数类型有固定的表数范围和字段长度 不受具体os的影响 以保证java程序的可移植性

- java的整型常量默认为int型 

- 声明long型常量必须加  l 或 L
<!-- 
  在使用long型的时候 必须以小写l 或者 大写L结尾
  long num = 345223L;  
  输出结果不会带有L
 -->

- java程序中变量通常声明为int 除非不足以表示较大的数 才用long


- 类型        占用存储空间      表数范围
- byte        1字节=8bit位    -128 ~ 127
- short       2字节           -2^15 ~ 2^15-1
- int         4字节           -2^31 ~ 2^31-1(约21亿)
- long        8字节           -2^63 ~ 2^63-1

- byte：
<!-- 
  从存储上讲是最小的单位 1字节=8bit 一个bit存0或者存1 两种情况 一共8个 所以byte一共有多少种组合方式 2^8=256 

  所以一个byte能表示256个数 0~255，但是这么表示就没有负数了 所以就是-128~127 加起来就是256
 -->

- short:
<!-- 
  它是byte的两倍 也就是 2^16 
  那我们也分一半 就变成了 -2^15 ~ 2^15-1  因为还有一个0
 -->

- int   是 short 的2倍
- long  是 int 的2倍

<!-- 
  byte b1 = 12;
  byte b2 = -128;
  // b2 = 128;     编译不通过 超出范围了 -128 ~ 127

  // 声明long型变量 必须以"l" or "L"结尾
  long b3 = 234234234L;     // 234234234

  System.out.println(b1);
  System.out.println(b2);
  System.out.println(b3);
 -->

----------------

> 基本数据类型的使用 -- 浮点型
- 通俗的讲就是带有小数点
- 与整数类型类似 java浮点类型也有固定的表数范围和字段长度 不受具体操作系统的影响

- 浮点型常量有两种表示形式

    - 十进制数形式: 
        - 5.12    512.0f    .512(必须有小数点)

    - 科学计数法形式:
        - 5.12e2  512E2   100E-2

- float:  单精度 尾数可以精确到7位有效数字 很多情况下精度很难满足需求
<!-- 
  float存储数据量不仅少 精度也有限
  float表示数值的范围比long还大
 -->

- double: 双精度 精度是float的两倍 通常采用此类型
<!-- 
  double存储数据量不仅多 精度也高
 -->

- 通常定义浮点型变量时 使用 double型
- 声明 float型 常量 结尾必须加 "f" 或 "F"


- 类型            占用存储空间      表数范围
- 单精度 float     4字节            -3.403E38 ~ 3.403E38
- 双精度 double    8字节            -1.798E308 ~ 1.798E308

- 这里的E指的是10 - E38 -> 10^38

<!-- 
  double b4 = 11.03;

  // 定义float型时  变量要以 F 结尾
  float d5 = 12.4F;
 -->

----------------

> 基本数据类型的使用 -- 字符类型(只能声明一个字符)
- char型数据用来表示通常意义上的 1字符(2字节)
- 用处：
- 声明一个字符

- 1个字符 = 2个字节
- char会占用16个bit

- 通过 char型 定义的变量 只能定义一个字符
<!-- 
  char c1 = 'a'
  c1 = 'AB'   // 这里不能写两个 因为这相当于两个字符

  比如我们要是想定义 “张三” 这时候就不能使用char型 而是要使用字符串型
 -->

- java中的所有字符都使用unicode编码 故一个字符可以存储一个字母 一个汉字 或者其它书面语的一个字符

- 字符型 变量的三种表现形式


> char型的使用方式 
- 单引号('')括起来的单个字符 但是内部有且只能放一个少了多了都不行 
- char型里面必须要有值 为空报错
<!-- 
  char a = '';     报错
  char a = ' ';    这可以
 -->

- 比如：
  char c1 = 'a';
  char c2 = '中';
  char c3 = '9';

- java中还允许使用转义字符 “\” 来将其后的字符转变为特殊字符型变量
- 例如
  char c4 = '\n';    \n表示换行符 \t制表符

- 直接使用 Unicode 值来表示字符型常量
- 比如
  char c5 = '\u0043'
  代表一个十六进制整数 底层输出一个数的时候 也对应一个字符

**char类型是可以进行运算的 因为它都对应有 Unicode 码**

- 这里注意：
- 命令行默认是使用系统的编码格式解析的 比如我们中国电脑的系统默认格式为gbk
- 当我们将编码格式改为utf-8的时候 打印中文的时候可能会出现乱码
- 我们要保证 写入 和 读取 时候的字符集是同一个

----------------

> 基本数据类型的使用 -- 布尔型
- 布尔型只能有两个值

  boolean b1 = true;

- 我们常常在条件判断 循环结构中使用
<!-- 
  boolean b1 = true
  if(b1) {
    System.out.println("你就不能参\'单身派对\'了")
  } else {
    System.out.println("你有女朋友了")
  }
 -->

----------------------------

### 基本数据类型转换
- 我们下面说的运算包括 运算 和 赋值， 也就是说赋值也是运算的一种情况

> 自动类型提升:
- 容量小的类型 自动转换为 容量大的数据类型
- 数据类型按容量大小排序为
<!-- 
  byte
  char    -- int -- long -- float -- double
  short
 -->

**注意:**
- byte, char, short 相互之间做运算的话 结果的类型都应该取 int
- 那是不是说只要是这三种类型参与运算 结果都是 int 呢


> 定义：
- 有多种类型的数据混合运算时 系统首先自动将所有数据转换成容量最大的那种数据类型 然后在进行计算

- 当表数范围小 和 表数范围大 的变量进行运算的时候 结果自动提升为表数范围大的类型(比如一个byte 一个int 那么计算结果要取int 或 以上)
<!-- 
  表数范围小: byte 一个字节 8bit
  表数范围大: int  四个字节 32bit

  当它们进行运算的时候 res 的类型就是int 因为类型会自动提升到 表数范围大的类型上

  byte b1 = 2;
  int i1 = 13;

  int res = b1 + i1;
  System.out.println(res);  // 15

  也就是 在取两个类型结果的时候 我们要定义什么类型去接收这个结果(res)

  我们也可以定义 long 来接收
  long res = b1 + i1;     // 15

  我们也可以定义 float 来接收
  float res = b1 + i1;    // 15.0  结果会补个0
 -->

- 一个表数范围小的类型 赋值给 表数范围大的类型 也没有问题
<!-- 
  short num = 1;
  double number = num;
 -->

- 说明
- 此时的容量大指的是 表示数的范围的大和小 不是指占用的内存空间
- 比如 float容量要大于long容量 我么看的是这个类型占了几个字节

----------------

> char型运算
- char型时可以做运算的 
<!-- 
  // char型的变量 对应着 unicode 码
  char str = 'a';  // 97
  int num = 8;

  int res = str + num;

  System.out.println(res);    // 105
 -->


> 总结
- 强制类型转换 是 自动类型提升 的逆过程
<!-- 
  其中 boolean 不能与其它类型进行运算 因为它只有true 和 false
  java中
  true 就是 true 
  false 就是 false 

  不能像js那样 0 1
  所以下面中 我们所提到的 自动类型提升 不包括 布尔型

  byte short int long 可以做运算因为它们是数值
  char 能做运算 因为它的unicode对应着一个编码 比如 a 对应 97 97可以做运算
 -->
      

**注意:**
- byte short char 之间不会相互转换 他们三者在计算时首先转换为int类型
<!-- 
  byte    ↘
  short     →   int
  char    ↗
 -->

**boolean类型不能与其它数据类型运算**
- 当把任何基本数据类型的值 和 字符串(String)进行连接运算时(+) 基本数据类型的值将自动转化为字符串(String)类型

**注意:**
- boolean类型不可以转换为其它的数据类型

----------------

> 强制类型转换
- 自动类型提升的逆运算，将容量大的数据类型转换为容量小的数据类型
<!-- 
  正常来说两个基本类型变量间运算的时候 容量小的会自动提升为容量大的数据类型
  但是我们有的时候就希望
  运算后的结果的类型是容量小的那个类型
 -->

- 场景：
<!-- 
  比如数据库中会存放很多的表有一张用户的表中的数据有10万条 
  我们使sql查询这个表有多少条记录 它会返回一个值 默认情况下 我们查询这个表的数据有多少 它会返回一个long型的结果(它怕int装不下)

  但是我们在java里面就想拿int去接收这个数 这时候就需要将long型强制转换为int型 这时候我们就需要使用强转符
 -->

 ----------------

> 强制转换符: ()
> 使用方式: 要使用哪种类型接收 变量 = (指定要转成哪种类型)变量
<!-- 
  // 目标 我们定义一个double类型的变量 就用int来接收
  double num = 12.3;

  // 使用强转符 内部指定要强制转换为什么类型
  int number = (int)num;

  // 我们使用的是int来接收 int是整型 所以是12 即使num是12.9 接收后也是12
  这种现象叫做截断
  System.out.println(number);    // 12


  还有一种情况 下面这种情况也算精度损失 至于为什么是-128等到2进制的时候我们再来看
  int i = 128;
  byte b = (byte)i

  System.out.println(b)   // -128
 -->

- 上面我们能看到本身这个数据是12.9但是转换后精度降低变成12了 这种现象叫做损失精度


> 扩展:
- 通常 字符串不能直接转换为基本类型 但通过基本类型对应的包装类则可以实现把字符串转换为基本类型
<!-- 
  String a = "43"; 
  int i = Integet.parseInt(a);
 -->


> 变量运算规则的两种特殊情况
- 1. 上面说了定义 long型 变量 数值的后面要加上L
- 但是有的时候 我们在编译 long型 变量的时候 后面不加L 能编译也不报错
<!-- 
  long i = 123333;    
      结尾没加L 这是这个123333就会被认为是 int 型
      int型赋值给long 相当于自动类型提升了

  当 123333这个部分要是超出int的表数范围就会报错 这时候我们就要加上L
  int是4个字节
  long是8个字节
 -->

- float型一定要加F 不然编译都会不通过x
<!-- 
  float f = 12.3;   
    这里不加F的话 12.3会默认为double 这时double转为float就会报错了
    上面是 int 转为 long 属于自动提升
 -->

- 2. 我们看下下面的情况
<!-- 
  定义一个byte
  byte num = 12
  byte res = num + 1    报错

  我们定义了一个byte 然后让它 + 1  然后我们试着用byte型变量去接收 就会提示错误

  上面的1我们看做是一个常量 不像是变量可以不断的变化值 对于整型的常量来将默认的是int型
 -->

> 总结:
- 1. 对于整型常量   默认为 int 型
- 2. 对于浮点型常量 默认为 double 型

----------------------------

### 字符串类型: String 引用类型的变量
- String不是基本数据类型 属于引用数据类型 
- String定义的数值使用""包裹 不是单引号 这里要跟char型区分开
<!-- 
  我的天啊 在js里 字符串是基本数据类型 但是这里竟然是引用数据类型
 -->

> 使用方式:
- String 变量 = “值”
- 使用方式 与 基本数据类型一致
<!-- 
  // 下面的情况都可以
  String str = "hello";
  String str = "a";
  String str = "";

  System.out.println(str);
      这里要注意 System.out.println("hello"); 这里相当于输出的是一个常量
 -->

 ----------------

> String 和 8种基本数据类型之间的运算
- String可以 和 8种基本数据类型做运算(包括 boolean) 且运算只能是 + (连接运算)
- 相当于跟其它类型的结果拼接成字符串(拼接的结果的类型也是 String )
<!-- 
  String str = "学号";
  int num = 1001;

  // 只能是连接运算 同时接受变量的类型也是 String
  String info = str + num;

  System.out.println(info);
 -->

**是不是说每一种变量都要指定类型？**

- 我们在程序中怎么判断+是字符串的连接还是 运算的+ 
- 我们就看 + 的前后有没有String

----------------

> 练习
- 要点: 
- char型做运算的时候会对应 asn2码 所以会是正常的数字
<!-- 
  // 终端输出 * *
  System.out.println("* *");              // * *
  System.out.println('*' + '\t' + '*');   // 93  char对应asn2码 会做运算
  System.out.println('*' + "\t" + '*');   // * *  
  System.out.println('*' + ('\t' + "*")); // * *
  System.out.println('*' + '\t' + "*");   // 51*
 -->


- 判断
- 要点
- 3.5f 在做字符串拼接的时候 f也是没有的
<!-- 
  String str1 = 4           // 不对  因为String要想使用的时候必须用“”引起来
  
  String str2 = 3.5f + ""   // "3.5"
  
 -->

----------------------------

### 不同进制表示的方式
- 所有数字在计算机底层都以 二进制 形式存在
- java整数常量默认是int类型
- 二进制默认占64位 第64位是符号位

- 二进制的整数有如下的三种形式


> 原码
- 直接将一个数值 换成二进制数 最高位是符号位


> 负数的反码
- 是对原码按位取反 只是最高位(符号位)确定为1


> 负数的补码
- 起反码加1


**总结**
- 计算机以二进制补码的形式保存所有的整数
- 正数的原码 反码 补码都相同
- 负数的补码是反码+1

----------------

> 对于整数 有四种表示方式
- 1. 二进制(binary): 0, 1
    满2进1， 以0b 或 0B 开头

- 2. 十进制(decimal): 0-9
    满10进1

- 3. 八进制(octal): 0-7
    满8进1 以数字0开头表示

- 4. 十六进制(hex): 0-9 and A-F
    满16进1 以0x或0X开头表示
    此处的A-F不区分大小写 如: 0x21AF + 1 = 0X21B0

<!-- 
  打印结果都是10进制
  int num1 = 0b110;     // 0b开头  是2进制    6
  int num2 = 110;       //                  110
  int num3 = 0127;      // 0开头   是8进制    87
  int num4 = 0x110A;    // 0x开头  是16进制   4362

  System.out.println("num1 = " + num1);
  System.out.println("num2 = " + num2);
  System.out.println("num3 = " + num3);
  System.out.println("num4 = " + num4);
 -->

----------------

> 符号位
- 一个2进制的数的最高位(最左侧的位数) 称之为符号位
- 该符号位 如果是0 就表示正数
- 该符号位 如果是1 就表示负数
<!-- 
  0 0 0 0 1 1 1 0     byte - 正数   因为左侧的符号位为0

  1 0 0 0 1 1 1 0   - 负数
 -->

----------------

> 2进制 转换为 10进制
- 正数的原码 补码 反码是一样的 所以 一个正数的二进制数 你叫做原码 补码 反码都可以
- 三码合一

- 演示：
<!-- 
    我们定义一个byte --- 为一个bit

    --- --- --- --- --- --- --- --- 
    0   0   0   0   0   1   1   0       = 6

    从右往左看 第一位是第0位 第二位是第1位
 -->

----------------

> 正数的 2进制转为10进制的 技巧：
- 1000 = 8
- 每一位就是 2^几次幂 比如第0位就是 2^0
- 然后我们看看当前位是0 还是 1 
- 如果是1 就是 1*2^0
- 如果是0 就是 0*2^0

- 最后我们进行累加
- 1110 = 1*2^3 + 1*2^2 + 1*2^1 + 0*2^0 = 14(10进制的14)
<!-- 
  0 1 1 0 1 1 1 0
  2^6 + 2^5 + 2^3 + 2^2 + 2^1  
 -->

----------------

> 二进制中的负数
- 我们拿到负数的时候 首先要关心我们拿到的是负数的原码 负数的反码 还是 负数的补码

- 负数的原码:
- 将正数的最高位改成1 就是该负数的原码
<!-- 
  00001110 是正数 上面我们计算的结果是 14
  10001110 是负数 我们可以叫他 -14 的原码
 -->

- 反码
- 我们拿到了负数的原码后 除了符号位 各个位取反 结果就是反码
<!-- 
  00001110    正数 14
  10001110    负数 -14 的原码

  11110001    负数 -14 的反码
 -->

- 补码
- 我们拿到了反码 在反码的基础上加1
<!-- 不是每一位+1 就是最右侧的位数加1 -->
<!-- 
  11110001  负数-14的反码

  11110001 + 1 
  11110010  负数-14的补码
 -->

- 计算机的底层都以补码的方式存储数据 不管是正数还是负数
- 为了得到补码才需要原码和反码 之后就可以不要它们了

<!-- 
  10111011 这是10进制的几？
  首先这一定是补码 默认就是补码 其它两码没有用

  10111011 - 1 = 10111010(反码) = 11000101(原码) = 69

  ---

  正127 byte类型最大8bit 01111111

  +127  01111111
  -127  11111111  原码
  -127  10000000  反码
  -127  10000001  补码  底层-127 就是这样

  -128长啥样
  10000001 - 1 = 10000000 底层-128
 -->

- 上面我们接触过一个案例 我们将int类型的数据 强制转换为 byte类型的数据的时候 会发现原来的128 竟然变成了 -128 这是为什么?
<!-- 
  int i = 128;
  byte b = (byte)i;

  System.out.println(b)   // -128


  int是32位的 我们强制转换为byte后就剩 1000 0000了 然后这个输出后就是-128

  1000 0000在int里面1不是符号位 而转换为byte后就变成符号位了
 -->

----------------------------

### 10进制如何转为2进制
- 技巧:
- 除2取余的逆

- 案例
- 13的2进制是多少？
<!-- 
  13 / 2 = 商6余1
  商6 / 2 = 商3余0
  商3 / 2 = 商1余1
  商1 / 2 = 商0余1
  商0 / 2 = 商0余0    从下往上看 0不算 取逆 1101
 -->

- 总结：
- 这个数除以2 看余数商继续除以2 递归 结果从下往上看 就是 2进制


> 那2 8 10 16进制之间怎么转换？
- 进制的基本转换

----------------

> 十进制 二进制互转
- 二进制转成十进制 乘以2的基数
- 十进制转成二进制 除以2取余数

----------------

> 二进制 和 八进制 十六进制
- 因为八进制恰好是二进制的三次幂 十六进制是二进制的四次幂
- 所以

> 2进制 -> 8 16进制
<!-- 
  000 000 011 101 001

          3    5    1

  八进制就是0351
  因为8是2的3次幂 所以我们将2进制中每3位算出一个数字


  十六进制就是每4位算出一个数字
  1110 1001
     E    9

  十六进制就是 0xE9
-->

----------------

> 8 16进制 -> 2进制
- 08进制就拿出每一位数字 拆成3位 01组成的
- 16进制就拿出每一位数字 拆成4位 01组成的


- 思路
- 上面我们了解了 二进制和十进制之间的转换 那我们再知道二进制和八进制 和 十六进制之间如何转换
- 我们再在这几个进制之间转换的时候 就可以通过二进制过渡下再得到结果 

----------------------------

### 运算符
- 运算符是一种特殊的符号 用以表示数据的运算 赋值 和 比较等
- 1. 算术运算符
- 2. 赋值运算符
- 3. 比较运算符 或者叫 关系运算符
- 4. 逻辑运算符
- 5. 位运算符(开发的时候用的比较少)
- 6. 三元运算符


### 算术运算符
- 这个部分很常见 我们下面先拿除法来举例子

> 除法
- 12 / 5  --- 除法简单说理解就是将一个数分成几份
<!-- 
  1. int型在除不尽的时候 小数部分会省略
  int num1 = 12;
  int num2 = 5;

  int res = num1 / num2;          // 2
  int res = num1 / num2 * num2;   // 10

  --------

  2. 
  - 思考：
  - 12 / 5 我们就想得到比较精确地结果应该怎么做？

  - 方法1:
  - 我们定义一个double型 接收 两个int型的结果可以么? -- 不行！！
  - 因为num1 / num2先是int的结果已经是2了 然后赋值给double 所以是2.0
    double res = num1 / num2;     // 2.0


  - 方法2:
  - 先利用 + 将num2的结果转为浮点型结果 然后num1 与 浮点型进行运算结果会类型提升到double型
  - double res = num1 / (num2 + 0.0);   // 2.4


  - 方法3:
  - 利用强制类型转换 得到我们想要得结果
  - double res = (double)num1 / num2;

 -->

----------------

> 取模 %
- 结论:
- 结果的符号(是+ 还是-) 跟被模数(n % m, n就是被模数)的符号相同
<!-- 
  int m = -12
  int n = 5

  int res = m % n     // -2
 -->

**技巧**
- a % b 的结果是 0 到 b - 1
- 比如 12 % 5 结果不会超过5 为 0 到 4
<!-- 
  a % 1 的结果肯定是0 
  1. 因为不可能超过1 
  2. 任何数/1都会除尽
 -->

----------------

> ++n, 先运算后取值  - 先自增1 然后再运算
> n++, 先取值后运算  - 先运算  然后再自增1
- 不管是++n 还是 n++ 都表示变量自增1
- 区别是 它们在涉及到运算的时候 是先自增 还是先运算

> 注意： 自增1 不会改变它原本变量的数据类型
<!-- 
  int a = 10;
  int b = ++a;

  System.out.println("a = " + a + ", b = " + b);     // 11 11

-----

  int a1 = 10;
  int b1 = a1++;

  System.out.println("a1 = " + a1 + ", b1 = " + b1); // 11 10

-----

  对于a来讲 不管是++n 还是n++ 都是自增1

-----

  int a = 10;
  a++;  or  ++a;    这里都自增1了
  int b = a;

  System.out.println("a = " + a + "b = " + b);   // b： 11
-->

**注意：**
- 我们在使用的时候可能会出现这种情况
- 定义一个short型变量10 然后让它变成11
<!-- 
  short a = 10;
  a = a + 1;

  编译报错:
  常量1会被当成整型int 这样运算会类型自动提升为int 再将结果赋值给原先的 short型的a 就会编译报错
 -->

- 那应该怎么解决？
- 强转就是截断
<!-- 
  a = (short)(a + 1);
 -->

- 或者让数字自增1 自增运算不会改变原本数据的数据类型

- 假如我们定义一个byte 127 让这个变量自增 结果会怎么样
<!-- 
  byte a = 127;
  a++;

  System.out.println(a);    -128

  01111111...   127 正数 除了符号位是0 其余位是1 然后 +1  进位
  10000000...   符号位为1 其余是0 就是 -128 呗
 -->

----------------

> 练习:
- 随意给出一个整数 打印显示它的个位数 十位数 百位数的值
- 格式：
- 数字 xxx 的情况如下
- 个位数: 
- 十位数: 
- 百位数: 

- 例如
- 数字 153 的情况如下:
- 个位数: 3
- 十位数: 5
- 百位数: 1
<!-- 
  int num = 187;

  int bai = num / 100;

  int shi = num % 100 / 10;     方式1
  int shi = num / 10 % 10;      方式2

  int ge = num % 10;


  百位逻辑:
  187 / 100 = 1.87 int 取整 1

  十位逻辑:
  187 % 100 = 87  --  87 / 10 int 取整 8

  个位逻辑
  187 % 10 = 7

  System.out.println("百位为: " + bai);
  System.out.println("十位为: " + shi);
  System.out.println("个位为: " + ge);
 -->

----------------

> 符号 = 
- 当 = 两则数据类型不一致的时候可以使用自动类型转换 或 使用强制类型转换原则进行处理


- 支持连续赋值
<!-- 
  先分别定义 再连续赋值
  int num, num1;
  num = num1 = 10;


   同时定义多个变量(共用一个类型)
   int num = 10, num2 = 20;
 -->

----------------

> 扩展赋值运算符:
- += -= *= /= %=
- 要点:
- 利用这样的形式 去运算不会改变该变量的类型
<!-- 
  int num = 10;
  num += 2;   // num = num + 2  // 12
  num %= 2;   // num = num % 2  // 0

  -----

  之前我们知道 如果这样写的话会 编译不通过
  short num = 10;
  num = num + 2;    因为2被看成一个int
      解决方式 或者用int接收 或者 强转为short

  我们还可以这样:
  short num = 10;
  num += 2;       这样编译可以通过结果正常 因为这样写不会改变原类型
 -->


- 在开发中 如果希望变量实现+2的操作 有几种方法 int = 10;
- 1. num = num + 2;
- 2. num += 2; (推荐 因为不会改变数据类型)
<!-- 
  int的时候感觉不出来 当不是int类型的时候 一定是这种方式是最好的
 -->


> 练习：
- 1. 
<!-- 
  int i = 1;
  i *= 0.1;     // *=不会改变原变量的类型 所以还是int 结果是0
  System.out.println(i);
 -->

- 2. 
<!-- 
  int n = 2;
  int m = 3;
  n *= m++;

  System.out.println(n)   // 6
  System.out.println(m)   // 4
 -->

- 3. 
<!-- 
  int n = 10;
  n += (n++) + (++n);
  System.out.println(n);  // 32

  解析：
  n = n + (n++) + (++n)
      10 + 10(原值) + 12(前面n自加了一次是11， 然后++n是新值就为12)
 -->

----------------

### 比较运算符
- 比较运算符的结果都是boolean型 也就是要么是true 要么是false

> == != < > <= >= instanceof

> instanceof
- 检查是否是类的对象
<!-- 
  "hello" instanceof String    // true
 -->

----------------------------

### 逻辑运算符
- 逻辑运算符只适用布尔类型的变量
- 在高一的时候 都会将集合的概念 或 且 非
<!-- 
  或: 都行的意思 
  且: 必须都满足 取交集的意思
  非: 就是取补集的意思
 -->

- &    逻辑与
- &&   短路与

- |    逻辑或
- ||   短路或

- ！    逻辑非
- ^    逻辑异或

- 理解方式:
- 我希望a b它们是异(不一样) 当不一样的结果的时候 运算结果就是true
<!-- 
  当 a 和 b 相同的时候 结果是 false
  当 a 和 b 不同的时候 结果是 true

  a = true
  b = true
  a ^ b    // false
 -->

 > 短路的概念
 - 这里扩展一下高中的物理概念
 <!-- 

    ---- x -----
    |           |
    ------。↗ ---
    - 当我们合上开关的时候 小灯泡会亮


      ↗ → → ↘
    -↗-- x --↘--
    |           |
    ------。↗ ---
    - 这种情况下 即使我们合上开关 小灯泡也不会亮 因为线路绕过小灯泡了

  - 结合上面的知识点 我们再看看 false && true
  - 如果第一个值为false 相当于绕过了第二个值
  -->

> &&
- 只有前后都是true的时候结果才是true
<!-- 
  boolean b = false;
  int num = 10;
  if(b && (num++ > 0)) { ... }


  如果 b 是false 那么条件2 就不重要了 因为短路了
  如果 b 是true  要需要看条件2的值

  结合js中的知识点 && 中 如果条件1为true 会检查条件2
 -->


> & and &&
- 例子：
- 下面的例子主要观察 & 和 &&

- js中没有&
- 它们都是代表逻辑 区别在于
- 当条件1为false的时候
- &  会执行    条件2
- && 不会执行  条件2
<!-- 
  boolean b = true;
  b = false;
  int num = 10;
  if(b & (num++ > 0)) {
    System.out.println("我现在在北京");
  } else {
    System.out.println("我现在在南京");
  }

  boolean b1 = true;
  b1 = false;
  int num1 = 10;
  if(b1 && (num1++ > 0)) {
    System.out.println("我现在在北京");
  } else {
    System.out.println("我现在在南京");
  }
 -->

- 总结：
- 相同点
- 我们不管使用的是单& 还是双&& 运算结果都是相同的 都是只有条件1 条件2都满足的时候才会是true
- 1. & 与 && 的运算结果相同
- 2. 当符号左边是true的时候, 二者都会执行符号右边的运算


- 不同点:
- 当符号左边是false的时候, 单&会继续执行右边条件2的运算, 双&就不再执行符号右边条件2的运算了


> | && ||
<!-- 
  boolean b = false;
  int num = 10;
  if(b | (num++ > 0)) 
  if(b1 || (num++ > 0)) 

    b 和 b1 都是false 所以整体结果是什么 都要看条件2的



  boolean b = true;
  int num = 10;
  if(b | (num++ > 0)) 
  if(b1 || (num++ > 0)) 

    b 和 b1 都是true | 还会看条件2的 但是短路|| 就不会看条件2了 因为已经是true了
 -->

 - 结论
- 相同点:
- 1. | 与 || 的运算结果相同
- 2. 当符号左边是false的时候, 二者都会执行符号右边的运算


- 不同点:
- 当符号左边是true的时候, 单|会继续执行右边条件2的运算, 双||就不再执行符号右边条件2的运算了
<!-- 
  参考js资料:
    - 如果第一个表达式的值为真, 则返回表达式1
    - 如果第一个表达式的值为假, 则返回表达式2
 -->


> 总结
- 上面的单 还是 双都没有区别 但是在开发的时候 我们选择单还是双呢？
- 我们在开发的时候 优先使用短路的 也就是 双&& ||

----------------

> 练习：
- 1. 
- 要点:
- if(条件这里是否会运行 或者说 是否会影响到结果)
- 虽然是条件 但是程序还是运行这里了 所以相应在输出的时候 值也会发生变化
- 只是走不走大括号里面的逻辑 是要看条件是否成立
<!-- 
  int x = 1;
  int y = 1;

  if(x++ == 2 & ++y ==2) {
    x = 7;
  }

  System.out.println(x + ", " +  y);    // 2 2
 -->


- 2. 
- 要点:
- if(条件里面的运算是会运行的 会影响到其它的变量)
<!-- 
  boolean x = true;
  boolean y = false;
  short z = 42;
  if((z++ == 42) && (y = true)) z++;
  if((x = false) || (++z == 45)) z++;

  System.out.println("z= " + z);

  解析：
  if((z++ == 42) && (y = true)) z++;
  z++是旧值是42   --  true
  y被修改为       --  true
  所以 z++ 也会执行 这里 z++包括条件里面的 一共是2次 到这里z为44


  if((x = false) || (++z == 45)) z++;
  x为false会看条件2 ++z是新值 45 条件2里等式成立 会运行最后的z++ 

   所以结果是46
 -->

----------------

> 位运算符
- 我们看到这里的时候先不用看注释的部分 先看下面 回头在看注释里总结的部分

- <<      左移        3 << 2 = 12  -- 3*2*2 = 12
<!-- 
  空位补0， 被移除的高位丢弃 空缺位补0
 -->

- >>      右移        3 >> 1 = 1   -- 3 / 2 = 1
<!-- 
  被移位的二进制最高位是0 右移后 空缺位补0
  最高位是1 空缺位补1
 -->

- >>>     无符号右移   3 >>> 1 = 1  -- 3 /2 = 1
<!-- 
  被移位二进制最高位无论是0 或者 1 空缺位都用0补
 -->

- &       与运算      6 & 3 = 2
<!-- 
  二进制位进行 & 运算 只有 1&1时 结果是1  否则是0
 -->

- |       或运算      6 | 3 = 7
<!-- 
  二进制位进行 | 运算 只有 0|0时 结果是0 否则是1
 -->

- ^       异或运算    6 ^ 3 = 5
<!-- 
  相同二进制位进行 ^ 运算 结果是0  1^1=0    0^0=0
  不相同二进制位进行 ^ 运算 结果是 1^0=1    0^1=1
 -->

- ~       取反运算    ~6 = -7
<!--  
  正数取反 各二进制码按补码各位取反
  负数取反 各二进制码按补码各位取反
 -->

- 位运算是直接对 整数 的二进制进行的运算
- 位运算操作的都是数值 而其结果也是一个数值
<!-- 
  这里注意是对 整数 的二进制
  没有对小数 也就是浮点型的数字进行左右移动的
 -->

- 但是用的频率比较低

> << 左移
- 例子： 
- int num = 21；
<!-- 
  0000 0000 0000 0000 0000 0000 0001 0101

  num << 2    左移两位
  相当于左边出去两位 右边就需要补2位 拿0补
    0000 0000 0000 0000 0000 0000 0001 0101
  0000 0000 0000 0000 0000 0000 0001 010100

  原先：
  10101     对应着  2^4  2^2  2^0  它们相加为21

  现在
  1010100   对应着  2^6  2^4  2^2

  首先我们会发现规律：
  1. 左移两位 幂发生了变化 幂数 + 2了
  2. 实际上相当于原先的结果( 2^4  2^2  2^0 ) 21 再乘以 2^2

  也就是说 21 * 4 = 84


  - 那要是向左移3位呢？ num << 3 ? 
  - 那是不是说 21 * 2^3 = 168   对
 -->

> << 左移 结论
- 每向左移动一位 相当于在原来的基础上 乘以2
- 每向左移动几位 相当于用原来的数 乘以 2的几次幂


> >> 右移
- 每向右移动一位 相当于再原来的基础上 除以2
- 每向右移动几位 相当于用原来的数 除以 2的几次幂
- 貌似的规律貌似的规律都是原数减一半 但是也是在一定的范围内

- 注意：
- 当我们进行右移的时候 需要拿数补位
- 当原数为正数的时候 空位我们全部拿 0 补
- 当原数为负数的时候 空位我们全部拿 1 补

<!-- 
  int num = 21;
  num << 2;   21 * 2 * 2
  num <<< 3;  21 * 2 * 2 * 2
  num <<< 4;  21 * 2 * 2 * 2 * 2
 -->

<!-- 
  int num = 80;
  int res = num >> 3;   80 / 8 = 10

  num >> 1;   // 40
  num >> 2;   // 20
  num >> 3;   // 10
 -->

**注意**
- 1. 位运算符操作的都是整型的数据
- 2. << 在一定范围内 每向左移1位相当于 * 2    原数加一倍
- 3. >> 在一定范围内 每向右移1位相当于 / 2    原数减一半
  - 那是不是说当整型数字 减少一半的时候 或者 增加一倍的时候 我们就可以对这个数字进行 >> << 的操作呢？ 哈哈

- 4. 负数也适用于这个规律
<!-- 
  什么叫在一定范围内呢？ 我们现在是依次左移 但是假如移动到最高位也就是符号位由原来的0变为1了 也就是说由原来的正数变为负数了 那就有问题了
 -->

- 5. 注意 负数 右移补位的问题 正数拿0补 负数拿1补
<!-- 
  右移两位
  100000010011
    100000010011

  我们要拿数补位 因为原本就是负数 所以这时候我们补位要拿1补
  100000010011
  11100000010011
 -->


> 面试题
- 最高效的计算 2 * 8 
- 答案:
- 1. 2 向左移动 3位
- 2. 8 向左移动 1位
<!-- 
  int num = 2;
  int res = num << 3;

  第一种想法：
  单独去想 8 是 2的几次幂   因为左移就是在用数值 * 2的几次幂

  第二种想法：
  2会被扩大几倍 扩大了8倍 但不能直接用2 * 2^8 
  而是我们这种想法要考虑 2分几次翻倍了
  翻一次会是 4
  翻二次会是 8
  翻三次会是 16

  岂不是又到想法1了
 -->
 

> >>> 无符号右移
- 不管这个数原来是正数 还是 负数 补位的时候都拿0来补
<!-- 
  也就是 原本的数 如果是负数 往右 无符号移动一位 瞬间就变成正数了
  使用无符号右移的时候根本就不是想进行 /2 的操作了

  在求集合 和 哈希值原码的时候 底层会用到这个符号 先不讲了
 -->


> &
- n = 12; m = 5;  n & m 结果为4
- 我们要将数值转换为二进制 然后每一位进行 &运算判断

- 技巧：
  我们把0当成false 把1当成true 我们将false 和 true进行 & 逻辑运算
  所以只有 true true结果才是true 其它的结果都是0

- 也就是说 1 和 1 才是1 其它都是0

> 要点： 11为1 找true

<!-- 
  12的底层2进制为   00001100
  5的底层2进制为    00000101    它们进行 & 运算

  
  0 0 0 0 1 1 0 0   &
  0 0 0 0 0 1 0 1
  0 0 0 0 0 1 0 0

  2^2 结果为 4
 -->


> |
- 技巧
- 1看成true 0看成false 然后进行同位 | 运算 
- 只有都是false的时候 才是false 其它的都是true

- 0 和 0 才是0 其它都是1

> 要点： 00为0 找false
<!-- 
  0 0 0 0 1 1 0 0   |
  0 0 0 0 0 1 0 1
  0 0 0 0 1 1 0 1

  2^3 2^2 2^0 = 13
 -->


> ^ 异或
- 技巧
- 1看成true 0看成false 然后进行同位 ^ 运算 
- ^ 异或 我们希望看到的结果是不一样 所以 不一样就是true 对应1
- 其余的情况都是0

> 要点： 一样为0
<!-- 
  0 0 0 0 1 1 0 0   ^
  0 0 0 0 0 1 0 1
  0 0 0 0 1 0 0 1

  2^3 2^0 = 9
 -->


> ~ 取反
- 包括符号位在内 所有的数值0变1 1变0
- int num = 6; ~num;
<!-- 
  0000 0000 0000 0000 0000 0000 0110
  1111 1111 1111 1111 1111 1111 1001  

  结果是 -7 

  6 进行 ~6 是 -7 那 ~-7 是多少？ 是6 
 -->


> 练习：
- int num1 = 10; int num2 = 20;
- 交换两个变量的值

- 场景：
- 1. 购买火车票的时候 我们点击按钮可以互换地址
<!-- 
  北京 -- 唐山
  唐山 -- 北京
 -->

- 2. 数字排序 1 5 4 2 3 排成 1 2 3 4 5
<!-- 
  这里少不了交换变量位置的值 比如5 和 3交换一下
 -->

- 上述的场景中都少不了交换两个变量的值


> 方式1
- 定义一个临时变量

- 技巧
- 每一行最后一个变量 是下一行的开头
<!-- 
  int temp = num1;
  num1 = num2;
  num2 = temp;
 -->


> 方式2
- 相加操作
- 理解举例：
- 有两个岛分别站了一个人 甲乙 ， 岛周围全是水水里有鳄鱼， 甲乙要交换地方
- 做法 甲 跳到 乙的脖子上 让乙跳到甲的位置上 然后甲再蹦到乙的位置上
- 用代码来实现乙蹦到甲的脖子上就是 两个数相加
<!-- 
  // 乙跳到了甲的脖子上 num1为30了 两个人一起的重量 
  并且两个人在同一个岛上 为了交互位置 甲带着乙跳到了 乙所在的岛上 
  接下来开始卸货
  num1 = num1 + num2;   

  // num1为两个人的重量 我们要减去其中的一个人的重量 并赋值给这个人 
  这时候为了交换我们要减去另一个人的重量 不要减自己 (减自己等于没换)
  num2 = num1 - num2;   // num2 = 10 这时候num1还是30

  // 这步就是为了交换值
  num1 = num1 - num2;   // 30 - 10 = 20  num1 = 20
 -->

- 好处： 不用定义临时变量
- 弊端： 两数相加超过本身变量的存储范围 对于数值型的可以用 非数值型的不好用 也就是说有数据类型的限制


> 方式3
- 要点:
- 两个数之间进行异或运算再进行异或运算其中的一个数 结果是另一个数
- a ^ b 如果再 ^ a 结果就是 b
- a ^ b 如果再 ^ b 结果就是 a

<!-- 
  0000 1101    m = 13
  0000 0101    n = 5     ^
  0000 1000    ^运算的结果为8

  0000 0101   n = 5 再跟上面的结果进行^运算
  0000 1101   ^ 2次^运算的结果是13


  1. n ^ m 的结果为k 等于 8
  2. 让k再继续异或其中的一个数 比如我们用k ^ n 结果就变成m了
  m = k^n = (m^n)^n

  n ^ m 得到的结果 ^ n 得到的结果就是 m
  就是两个数异或运算再异或一个数结果就是另一个数 (变过去异或再变回来)
 -->

- 具体实现步骤
<!-- 
  // 实现 交换两个变量的值
  int num1 = 10;
  int num2 = 20;

  // 1. 我们将第一次的异或运算的结果保存
  num1 = num1^num2;

  // 2. 将保存的结果 再次异或其中的一个数值 结果会是另一个数值
  这里num1^num2 结果会是num1的值 但是我们为了交换将这个值给num2
  num2 = num1^num2;

  // 3. 这时候num1还是我们上面保存的结果 我们再次异或num2 
  这里注意经过上面的步骤num2的值已经是num1的值了 也就是说 我们得到的结果会是num2的值 为了交换 我们将结果赋值给num1
  num1 = num1^num2;
 -->

----------------

> 三元运算符
> 格式：
- (条件表达式) ? 表达式1 : 表达式2
- 当条件表达式为true的时候  运算结果是表达式1
- 当条件表达式为false的时候 运算结果是表达式2

**注意：**
- 接收三元运算符的变量类型必须是能够统一 表达式1 和 表达式2 的类型
- 1. 表达式1 和 表达式2 为同种类型 这样接收结果的类型也跟它们一样
<!-- 
  int m = 12;
  int n = 5;
  int max = (m > n) ? m : n;

  n m 都是int 接收它们结果的类型也是int
 -->

- 2. 接收结果为能统一它们的类型
<!-- 
  double num = (m > n) ? 2 : 1.0

  因为num要么就是int 要么就是double 我们要将num定义成能够接收它们两个的类型

  下面的情况就不行 这样怎么定义类型接收呢？ 没办法统一
  (m > n) ? "n大" : 2
 -->


> 三元运算符 与 if-else的联系 与 区别
- 1. 三元运算符可简化if-else语句
- 2. 三元运算符要求必须返回一个结果
- 3. if后的代码块可以有多个语句

<!-- 
  // 获取两个整数的最大值
  int m = 12;
  int n = 5;
  int max = (m > n) ? m : n;
 -->


> 三元表达式的嵌套
- 第二个结构要加上 ( )
- String max = (m > n) ? "m大" : ((m == n) ? "m n相等" : "n")


> 练习
- 获取三个数的最大值
<!-- 
  // 获取两个整数的最大值
  int n1 = 12;
  int n2 = 5;
  int n3 = -43;

  int max = (n1 > n2) 
              ? ((n1 > n3) ? n1 : n3) 
              : ((n2 > n3) ? n2 : n3);
 -->

- 注意：
- 开发的时候这样不好 觉得很帅 但不是真的帅 以后改哪都不敢下手
- 代码帅的定义
- 1. 效率高 这点是基于算法的改良
- 2. 上面的3行代码整成一行了 感觉帅了 但是是让可读性变差了 效率并没有提高 大家还看不懂


> 结论
- 凡是可以使用三元运算符的地方都可以改写成if else
<!-- 
  if(m > n) {
    System.out.println(m)
  } else {
    System.out.println(n)
  }
 -->

- 能用if else的一定能改成三元么？ 不是
- 三元运算符的结构简单 接收变量的类型还有限制 if else比较灵活

- 如果程序既可以使用三元运算符 又可以使用if-eles 那么优先选择三元运算符 原因 简洁 执行效率高
<!-- 
  三元运算符的效率高 毕竟它只是个运算符 而if else是比较复杂的流程控制语句 
-->

----------------------------

### 运算符的优先级
- 运算符有不同的优先级 所谓优先级就是表达式运算中的运算顺序
- 如下表 上一行运算符总是优先于下一行

- 只有单目运算符 三元运算符 赋值运算符是从右向左运算的
<!-- 
  0.  . () {} ; ,
  1.  ++ == ~ ()
  2.  * / %
  3.  + -
  4.  << >> >>>
  5.  < > <= >= instanceof
  6.  == !=
  7.  &
  8.  ^
  9.  |
  10. &&
  11. ||
  12. ? :
  13. =  *=  /=  %=  +=  -=  <<=  >>=  >>>=  &=  ^=  =
-->

- 85集讲刚毕业就业

----------------------------

### 复习
> & && 异同
- 从使用来讲 它们用哪个都是可以的 都表示& 从结果上看都用它们两个谁都是一样的
- 当前面结构为false的时候 &&右侧是不执行的


> String类型的数据之间不能比较大小
- > < >== <== 只能使用在数值类型的数据之间
- == 不仅可以使用在数值类型的数据之间 还可以使用在是他的引用类型之间
<!-- 
  // 1000 2000 是余额
  Account acct1 = new Account(1000)
  Account acct2 = new Account(2000)

  acct1 == acct2;   // 这时候比较的是 两个账户是不是同一个账户
 -->


> 使用程序求一个 0-255 范围内的整数的十六进制
- 该题利用了 
- 1. & 运算
- 2. >>> 无符号右移
- 3. char型与数值的计算

- &运算要点
- 1. 11得1(true true是true) 其余都是0
- 2. (技巧)拿到末4位的值 可以让该数与 15二进制进行&运算
<!-- 
  15的二进制末4位是1111 其余都是0
 -->

- >>> 无符号右移
- 当右移的时候我们不关注/2 目的只是为了取2进制数 拿0补位 就用无符号右移

- char型与数值的计算
- 这题里面利用了三元表达式 当x > 9的时候 做逻辑处理
- 所有将结果确定位char型 x > 9 那么就可能是10 11 12 ...
<!-- 
  A是65
  (i2-10+'A')
  当 i2 为 10 的时候 就是 0 + A = 0 + 65 = 65 = A
  当 i2 为 11 的时候 就是 1 + A = 1 + 65 = 66 = B
 -->

> 具体逻辑
- 核心思路：
- 2进制 转为 16进制，可以将每4位01进行累加算出一个结果
- 0011 1100   60的二进制
- 3    C
<!-- 
  但问题是怎么才能将 1100 单独的从2进制中取出来？

  为了将 末尾4位单独拿出来 
  可以让i1和15进行 &运算 因为15的未4位是1111 其余28位为0
  int i2 = i1 & 15;

  1100
  1111  &
  1100

  我们可以看到和15进行&运算后的结果就是 我们想取出60的2进制的未4位本身


  int i1 = 60;

  // 15的二进制末4位是1111 其余是0 就能够得到60的2进制的末四位
  int i2 = i1 & 15;

  // 这里是 算出 C 的逻辑 利用了 char型变量的相加
  String j = (i2 > 9) ? (char)(i2-10+'A') + "" : i2 + "";  // c

  上面是将0011 1100最低4位取出来了 接下来怎么取0011这四位?
  我们将i1 整体的右移四位 0011 就成为了最低的4位
  只有当我们关心右移是代表/2的时候 才用>> 只是想右移拿0补 目的只是为了取数 那就>>>
  int temp = i1 >>> 4;
  i2 = temp & 15;
  String k = (i2>9) ? (char)(i2-10+'A') + "" : i2 + "";  // 3

  System.out.println(k+""+j);
-->

----------------------------

### 程序流程控制
- 流程控制语句是用来控制程序中各语句执行顺序的语句 可以把语句组合成能完成一定功能的小逻辑模块

- 其流程控制方式采用结构化程序设计中规定的三种基本流程结构
- 1. 顺序结构
- 2. 分支结构
- 3. 循环结构 

> 顺序结构
- 程序从上到下逐行的执行 中间没有任何判断和跳转


> 分支结构
- 根据条件 选择性的执行某段代码
- 有 if else 和 switch case 两种分支语句


> 循环结构
- 根据循环条件 重复性的执行某段代码
- 有 while do for 三种循环语句
<!-- JDK提供了forEach循环 方便的遍历集合 数组元素 -->

------------------

> 分支结构 if else
- 这个语法分成了3种情况用于应对需求
- 条件判断结构

> 1. if(条件表达式) { ... }
- 如果条件表达式为true 则执行 花括号内部的代码逻辑
- 如果条件表达式为false 则跳过 花括号内部的代码逻辑 往下执行(不考虑大括号内部代码)
<!-- 
        条件表达式  ↘
          true    faflse
            ↓        ↓
        执行代码块    ↓
            ↓     ↙
            ↓   ↙
 -->        

<!-- 
  // 举例1 体检
  int heartBeats = 78;
  if(heartBeats <60 || heartBeats > 100) {
    System.out.println("您需要做进一步的检查");
  }

  System.out.println("检查结束");
 -->


> 2. if(条件表达式) { ... } else { ... }
- 二选一
- 如果条件表达式为true 则执行if后的逻辑 
- 如果条件表达式为false 则执行else后的逻辑
- 一条分支执行完毕后 接下来顺序往下执行

- 改分支语句一定会在两个条件中选择一个执行
<!-- 
        条件表达式
      ↙          ↘
    true        false
      ↓           ↓
      ↓           ↓
      ↓  →  ↓  ←  ↓
            ↓
 -->

<!-- 
  2选一 一定会执行下面条件中的一个

  // 举例2 
  int age = 18;
  if(age < 18) {
    System.out.println("你还可以看动画片");
  } else {
    System.out.println("你要工作了");
  }
 -->


> 3. if(条件表达式1) { ... } else if(条件表达式2) { ... } else{}
- 多选一 
- 选择符合条件的其中一条执行大括号内部的语句 然后接着往下执行
- 匹配一个条件执行完毕后 直接会跳出分支结构

<!-- 
  // 举例3
  int age = 18;
  if(age < 0) {
    System.out.println("您输入的数据非法");
  } else if(age < 18) {
    System.out.println("青少年时期");
  } else {
    System.out.println("您该工作了");
  }
 -->


> if-else 使用的说明
- 条件表达式必须是布尔表达式(关系表达式 或 逻辑表达式) 布尔变量
- 语句块只有一条执行语句的时候 一对{}可以省略 但建议保留
- if else语句结构 根据需要可以嵌套使用

- 当if else结构是 多选一 的时候 最后的else是可选的 根据需要可以省略
- 当多个条件是 互斥 关系的时候   条件判断语句以及执行语句间顺序无所谓
- 当多个条件是 包含 关系的时候   ”小上大下 / 子上父下“

> Scanner的应用
- 使用该语法 控制台会要求用户输入值 我们拿scanner中对应的方法获取对应的值

> 通过键盘输入 拿到值
- 该问题 需要新知识 这里只是简单的了解下
- 通过键盘获取不同类型的变量(值) 需要使用 Scanner 类
- 该类用于通过键盘获取值

- 具体的使用方式
- 1. 导包
- 我们想在代码中使用 Scanner 类 这个类在另外一个包下 我们需要将这个类导进来
- 导包操作要写在 Demo类声明的上方

- 2. Scanner的实例化 相当于创建Scanner对象
- Scanner scan = new Scanner(System.in);
<!-- 
  该操作在main方法内部 main()是一个入口 我希望一上来就执行所以放在了这里面
  System.in 键盘输入 上面整体是将Scanner实例化
 -->

- 3. 调用 Scanner 类的相关方法 来获取指定类型的变量
- 在Scanner类下有很多的功能 也就是方法 其中有一个方法叫做 nextInt() 读取一个int型的值
<!-- 
  // 导包
  import java.util.Scanner;

  class Demo {
    public static void main(String[] args) {

      Scanner scan = new Scanner(System.in);
      int num = scan.nextInt();
      System.out.println(num);
      
    }
  }
-->

- 我们还可以获取别的类型的值 也是需要查看 Scanner 类中对应的方法

> next() or nextLine()
- 获取String型数据

> nextByte()
> nextBoolean()
> nextDouble()
> nextFloat()
> nextLong()

<!-- 
  // 导包
  import java.util.Scanner;

  class Demo {
    public static void main(String[] args) {

      Scanner scan = new Scanner(System.in);

      System.out.println("请输入你的姓名: ");
      String name = scan.next();
      System.out.println(name);

      System.out.println("请输入你的年龄: ");
      int age = scan.nextInt();
      System.out.println(age);

      System.out.println("请输入你的体重: ");
      double weight = scan.nextDouble();
      System.out.println(weight);

      System.out.println("你是否相中我了呢?(true/false): ");
      boolean isLove = scan.nextBoolean();
      System.out.println(isLove);

      // 对于char型的获取 Scanner 没有提供相关的方法 只能够获取一个字符串  假如我们就想定义一个char型变量

      可以使用字符串提供的 charAt() 方法 提取指定位置的字符
      char genderChar = gender.charAt(0)
    }
  }

  当用户输入和我们定义接收的类型不相符的时候就会报错
  程序过程当中一旦出现异常就会终止
 -->


**注意**
- 需要根据相应的方法 来输入指定类型的值 如果输入的数据类型与要求的类型不匹配的时候 会报异常 "inputMisMatchException" 导致程序终止


> 练习
- 岳小鹏参加java考试 他和父亲岳不群达成承诺 如果
- 成绩为100 奖励一辆bmw
- 成绩为(80, 99]时 奖励一台iphone
<!-- 
  左开右闭 不包括80 包括99
 -->

- 成绩为[60, 80]时 奖励一个ipad
- 其它时 什么奖励也没有 请从键盘输入岳小鹏的期末成绩 并加以判断
<!-- 
  import java.util.Scanner; 
  class Demo {
    public static void main(String[] args) {

      Scanner scan = new Scanner(System.in);
      System.out.println("请输入岳小鹏的期末成绩: (0-100)");
      int score = scan.nextInt();

      if(score == 100) {
        System.out.println("奖励一辆BMW");
      } else if(score > 88 && score <= 99) {
        System.out.println("奖励一台iphone");
      } else if(score >= 60 && score <= 80) {
        System.out.println("奖励一个ipad");
      } else {
        System.out.println("什么也没有");
      }
    }
  }
 -->

- 总结:
- 1. else的逻辑是可选的 可以不写
- 2. if else if 只要有一个逻辑匹配上了 就会跳出整个结构
- 3. 
- 如果多个条件表达式之间没有交集的关系时 哪个判断和执行语句声明在上面还是下面 无所谓

- 如果多个条件表达式之间有交集的关系时 需要根据实际情况考虑清楚应该将哪个结构声明在上面

- 如果多个条件表达式之间有包含的关系时 通常情况下 需要将范围小的声明在范围大的上面 否则范围小的就没有机会执行了


> 练习2
- 编写程序: 由键盘输入三个正数分别存入变量num1 num2 num3中 并对它们进行排序(使用if else) 并且从小到大输出
<!-- 
  import java.util.Scanner; 
  class Demo {
    public static void main(String[] args) {

      Scanner scan = new Scanner(System.in);
      System.out.println("请输入第一个整数: ");
      int num1 = scan.nextInt();
      System.out.println("请输入第二个整数: ");
      int num2 = scan.nextInt();
      System.out.println("请输入第三个整数: ");
      int num3 = scan.nextInt();

      if(num1 > num2) {

        // 比较num3是否比大的还要大
        if(num3 > num1) {
          System.out.println(num2 + " > " + num1 + " > " + num3);

          // 比较num3是否比小的还要小
        } else if (num3 < num2) {
          System.out.println(num3 + " > " + num2 + " > " + num1);

          // 剩下的情况就是在中间了
        } else {
          System.out.println(num2 + " > " + num3 + " > " + num1);
        }

        // 现在就是num2大的情况 我们再拿num3来进行比较
      } else {
        if(num3 > num2) {
          System.out.println(num1 + " > " + num2 + " > " + num3);
        } else if(num3 < num1) {
          System.out.println(num3 + " > " + num1 + " > " + num2);
        } else {
          System.out.println(num1 + " > " + num3 + " > " + num2);
        }
      }
    }
  }
 -->

**注意：**
- else也有就近原则 当配对关系不明确的时候 else就会和最近的if进行配对
<!-- 
  if(x > 2) 
    if(y > 2)   下面的 else 会和这个if配对
      System.out.println()  

  else {
    这个else和谁配对? 最外围的if没有 { }
  }
 -->


> 练习3
- 我家狗狗5岁了 5岁的狗相当于人类多大呢？
- 狗的前两年 每一年相当于人类的10.5岁 之后每增加一年就增加4岁
- 那么5岁的狗相当于人类多少年龄呢？

- 应该是 10.5 + 10.5 + 4 + 4 + 4 = 33岁

- 编写一个程序 获取用户输入的狗的年龄 通过程序显示其相当于人类的年龄
- 如果用户输入负数 请显一个提示信息
<!-- 
  import java.util.Scanner; 
  class Demo {
    public static void main(String[] args) {

      Scanner scan = new Scanner(System.in);
      int age = scan.nextInt();

      if(age < 0) {
        System.out.println("请输入正确的年龄");
      } else {
        if(age > 0 && age <= 2) {
          System.out.println("狗狗的年龄为: " + age * 10.5 + "岁");
        } else {
          System.out.println("狗狗的年龄为: " + (2*10.5 + (age - 2) * 4) + "岁");
        }
      }
    }
}
 -->


> 练习4
- 假设你想开发一个玩彩票的游戏 程序随机地产生一个两位数的彩票 提示用户输入一个两位数 然后按照下面的规则判定用户是否能赢

- 1. 如果用户输入的数匹配彩票的实际顺序 奖金10000
- 2. 如果用户输入的所有数字匹配彩票的所有数字 但顺序不一致 奖金3000
- 3. 如果用户输入一个数字仅满足顺序情况下匹配彩票的一个数字 奖金1000
- 4. 如果用户输入一个数字仅满足非顺序情况下匹配彩票的一个数字 奖金500
- 5. 如果用户输入的数字没有匹配任何一个数字 则彩票作废


> 随机数 Math.random()
- 它会获得一个double型的数据
- 该方法会返回 >= 0.0 <=1.0 之间的数
<!-- 
  如果 Math.random() * 100 那就变成 [0.0 - 100.0)
 -->

- 上面的题里要求的是2位数 所以我们不能乘以100 我们乘以90 再加上10
<!-- 
  Math.random()*90  [0.0, 90.0)

  然后+10 就会变成[10.0, 100.0)
 -->

- (int)(Math.random() * 90 + 10)

> 公式：
- [a, b]: (int)(Math.random() * (b - a + 1) + a)

<!-- 
  public static void main(String[] args) {
    int value = (int)(Math.random() * 90 + 10);
    System.out.println(value);
  }
 -->

---------------------------- 

### 分支语句2 switch case 结构
> 结构
- 1. break 关键字不是必须写的 为可选 根据实际情况
<!-- 
  一旦执行到此关键字就跳出当前结构
 -->

- 2. switch后的 (表达式) 不是条件表达式
<!-- 
  条件表达式代表它是布尔类型的 switch后面的表达式不是条件表达式
  这个表达式的类型只能是如下6中数据类型之一

   - 1. byte
   - 2. short
   - 3. char
   - 4. int
   - 5. 枚举类型    (jdk5.0新增)
   - 6. String类型 (jdk7.0新增)
 -->

- switch后面的表达式的值会依次跟case后面的值进行==匹配
<!-- 
  switch(表达式) {    // 该表达式不是条件表达式

    case 常量1:       // 只能声明常量 不能声明范围 num > 10 这样不行
      语句；
      break;

    case 常量2:
      语句；
      break;

      ...

    // 类似 else 上面的都没有匹配上的话 我们会执行default
    default:
      语句；
      break；
  }
 -->

- 3. default关键字的位置不是固定的 它可以放到任意位置
- 就是说default后面最好也有break 如果default的位置在其他位置的情况下
<!-- 
  int num = 3

  default: 
    System.out.println("zero");
  case 1:
    System.out.println("zero");
    break;

  进入执行程序后还是先看case有没有匹配上的 没有的话走default
  但是default后面没有break 所以还会执行 case1后面的语句 case后面的语句有break 停止
 -->

> 要点：
- 1. 和 if else 不一样的地方是 一旦if else匹配上其中的一个都 就会跳出整个结构
- 2. switch case 当没有break的时候 一旦匹配上条件后并不会跳出 而是会接着执行其它case结构中的执行语句 直到遇到break关键字 或者 到程序结束为止

- 3. 当多个case后的执行语句一样的时候我们可以考虑合并操作
<!-- 
  case 0:
  case 1:
  case 2:
  case 3:
    System.out.println("不及格");
    break;
 -->

**注意：**
- 一旦匹配上其中的一个条件后 会不进行判断就执行下面的语句

<!-- 
  class Demo {
    public static void main(String[] args) {
      
      switch后面的表达式对数据类型有要求 
      1. 不能放浮点型
      2. 不能放布尔型
      int num = 0;    

      switch(num) {
        case 0:
          System.out.println("zero");
        case 1:
          System.out.println("one");
        default:
          System.out.println("default");
      }
    }
  }

  要想执行多选一的话 我们要加上break关键字
 -->


> 练习：
- 1. 使用 switch 把小写类型的 char型转为大写 只转换 a b c d e 其他的输出 other
- 提示： 
  String word = scan.next();
  char c = word.charAt(0);
  switch(c) { ... }

- 2. 对学生成绩大于60分的 输出合格 低于60分的输出 不合格
<!-- 
  class Demo {
    public static void main(String[] args) {
      int score = 78;
      switch(score/10) {        // 让情况减少  
        我们还可以除以60 结果为0就是不及格 为1就是及格

        case 0:
          System.out.println("不及格");
          break;
        case 1:
          System.out.println("不及格");
          break;
      }
    }
  }
 -->

- 3. 编写程序 从键盘上输入2019年的 month 和 day 要求通过程序输出输入的日期为2019年的第几天
- 思路：
  比如 2月 15日 那就1月的31 + 15呗
<!-- 
  import java.util.Scanner;
  class Demo {
    public static void main(String[] args) {
      Scanner scan = new Scanner(System.in);
      System.out.println("请输入2019年的月份: ");
      int month = scan.nextInt();

      System.out.println("请输入该月的某一天: ");
      int day = scan.nextInt();

      // 定义一个变量 保存总天数
      int num = 0;
      switch(month) {

        // 我们倒着写 从12月份开始写 然后不写break 然后程序就会执行下面的逻辑 把 = 改成 +=
        case 3:
          num += 28;
        case 2:
          num += 31;
        case 1:
          num += day;
      }
    }
  }
-->


> 总结
- 1. 凡是可以使用switch case的结构都可以转换为if-else 反之不成立
<!-- 
  因为switch的表达式有要求
 -->

- 2. 当我们写分支结构时 既可以用if else又可以用switch case 优先使用switch case情况过多除外
<!-- 
  switch的实行效率稍高
 -->

----------------------------

### 循环结构 和 for循环的理解
- 在某些条件满足的情况下 反复执行特定代码的功能

- 循环语句分类
- for
- while
- do while

> 循环语句的四个组成部分
- 1. 初始化部分
- 2. 循环条件部分   -- 是boolean类型
- 3. 循环体部分
- 4. 迭代部分
<!-- 
  1. 先是初始化的部分 -- 再对循环条件进行判断 看它是否满足进入循环的条件 -- 如果不满足直接退出循环结构

  2. 如果满足循环条件 则进入循环体部分执行循环逻辑 -- 进入迭代部分(i++) -- 然后判断这次变化是否满足循环条件 -- 如果还满足则循环执行循环体内部逻辑

  3. 如果不满足循环条件则退出循环结构
 -->

> for循环的结构
  for(①; ②; ④) { ③ }

> 示例： 
<!-- 
  class Demo {
    public static void main(String[] args) {
      for(int i=0; i<5; i++) { 
        System.out.println("输出for结构");
      }

      for(int i=0; i<5; i++) { 
        System.out.println("输出for结构");
      }
    }
  }
 -->

- 思考:
- 上面有两个for循环结构 同时都使用了 i 冲突么？
- 不冲突 因为它们有各自的作用域 属于定义在了 循环体中 在for循环外部 访问不到 i


> 练习：
- 要点：
- 1. 初始化部分放在了外面
- 2. 1;2;3 这三个部分中都可以假如其它的语句 其它语句同时也会得到执行
- 3. 如果 3 中有多条语句的话 中间要使用,分割
<!-- 
  int n = 1;
  for(System.out.println("A"); n < 3; System.out.println("C"), n++) {
    System.out.println(" B");
  }

  输出结果 ABCBCBC
 -->

- 总结：
- for循环的条件部分和if条件部分一样都能够得到执行 所以当中也能写逻辑


> 练习2：
- 遍历100以内的偶数 输出所有偶数的和 输出偶数的个数
<!-- 
  class Demo {
    public static void main(String[] args) {

      int num = 0;
      int odd = 0;

      for(int i=0; i<100; i++) {
        if(i % 2 == 0) {
          System.out.println(i);

          num += i;
          odd = i;    // 或者让 ood+ 额 我基础真差
          odd++;      // or
        }
      }

      // 整个循环结束以后 告诉我结果是多少
      System.out.println(num);
      System.out.println("偶数的个数为： " + odd);
    }
  }
 -->


> 练习3：
- 编写程序从1循环到150 并在每行打印一个值 另外在每个3的倍数行上打印出 “foo”， 在每个5的倍数行上打印“biz” 在每个7的倍数航上打印输出“baz”
<!-- 
  1
  2
  3 foo
  4
  5 biz
  6
  7 baz
 -->

- 错误的思路:
- 这里我使用了else if的结构 因为else if是多选一 当次i的结果只会进入其中的一个分支判断结构
- 我们的例子中 有些数字既能被3整除 又能被 5 7 整除 所以我们要是使用else if的话 当有符合多个情况的数字的时候 只能打印出一种
<!-- 
  if(i % 3 == 0) {
    System.out.println(i + " foo");
  } else if(i % 5 == 0) {
    System.out.println(i + " biz");
  } else if(i % 7 == 0) {
    System.out.println(i + " baz");
  } else if(i % 3 == 0 || i % 5 == 0 || i % 7 == 0) {
    System.out.println(i + " foo biz baz");
  } else {
    System.out.println(i);
  }
 -->

- 所以我们要使用if 独立判断 当次的循环逻辑 会依次的进入到 其它的if中

- 要点：
- 1. 我们要使用 System.out.print 当次循环的最后再使用 System.out.println来换行

- 2. 比如当次是x 先是print输出 x 然后进入其它if判断 符合输出 foo
- 这时当次一行的结果就是 x foo
- 然后进入其它的if判断 如果符合if 当次当行输出 biz
- 这时当次一行的结果就是 x foo biz 因为我们使用的是print
- 最后的时候我们要使用 println 换行

<!-- 
  for(int i=1; i<=150; i++) {
    // 1. 先输出 i 
    System.out.print(i + "  ");
    
    // 2. 如果当次循环符合其它情况就输出 if 中的语句
    if(i % 3 == 0) {
      System.out.print("foo ");
    }

    if(i % 5 == 0) {
      System.out.print("biz ");
    }

    if(i % 7 == 0) {
      System.out.print("baz ");
    }

    System.out.println();
  }
 -->


> 练习4
- 题目： 
- 输入两个正整数m n 求其最大公约数 和 最小公倍数
- 比如 12 和 20的最大公约数是4 最小公倍数是60

- 前置理解:
- 约数: 
- 比目标数小 能被目标数除尽的数 叫约数 
- 12的约数有1 2 3 4 6 12

- 倍数:
- 比目标数大 除以目标数能除尽的
- 12的倍数有12 24 36

- 公约数:
- 即是你的也是我的就叫做公约数
- 12 20的公约数 既能被12除尽 又能被20除尽的数 1 2 4


- 思路：
- 约数代码上的体现: m 除以一个数(i)等于 0 这个数就是约数
- 倍数代码上的体现: i 除以 m 等于0 这个i就是m的倍数

- 公约数和公倍数就是 && m % i == 0 && n % i == 0

> 公约数
- i的取值范围：
- 约数：
- 约数不能比n m当中最小的数还大 我们拿到n m当中最小的数
- 比如 12 的约数 1 2 3 4 6 12 约数不会比12本身还要大
- 
- i的取值范围就应该是1 - 12

- 怎么求最大的公约数
- 上面 i 的取值范围知道了是1 - 12 那么我们从12开始往前 依次拿每一个数当做n m的除数 看看能否除尽一旦除以 它就是n m的最大公约数 

- 要点： 要加break 因为我们是从后往前去匹配 第一个匹配到的就是最大的公约数 所以要break下


> 公倍数
- i的取值范围
- 公倍数(i) 肯定不能比 12 20(n, m)还小 所以肯定大于20
- 20 ~ ？
- 
- ？ 是多少呢 我们定为 n x m 虽然肯定不是最大公倍数 但是它一定能保证是n 和 m的倍数

- 所以i的取值范围就是 12 ~ 12 X 20
- 然后我们开始进行判断

<!-- 
  import java.util.Scanner;
  class Demo {
    public static void main(String[] args) {

      Scanner scan = new Scanner(System.in);
      System.out.println("请输入第一个正整数: ");
      int m = scan.nextInt();
      System.out.println("请输入第二个正整数: ");
      int n = scan.nextInt();


/*
  公约数
  1. 
    m % i == 0 && n % i == 0 这个条件只能保证 i 是约数 
    但是不能保证这个i是最大的约数

  2. 怎么保证 约数i是最大的公约数
    约数的范围是12 那我就拿着 1 - 12 这个范围的数字 依次去除n m
    12 11 10 从后往前的除 一旦发现一个能除尽就说明这个数是最大的公约数

  3. i的范围是多少呢
    约数不能比这个数本身还大 公约数不能比12 20这个12还要大
    i的范围就是 i不能超过12 
    i的范围就是 1 - 12

-----

  公倍数
  1. 公倍数肯定不能比12 20小 所以肯定是>=20 所以i的值就是从两个数中的较大的数开始 
  开始的数是20 那结束的数是多少？  12 x 20 两个数相乘肯定是这两个数的倍数 但肯定不是最小公倍数 这样i的范围就能确定下来
  20 - 12x20

  2. 范围确定了 那就从20开始循环判断 只要i能除尽n m i就是最小公倍数
*/

  // 获取两个数中最小的数
  int min = (m > n) ? n : m;

  // 方法1： 定义一个最大公约数
  int maxY = 0;

  // 因为我们要从12依次往前去判断 所以初始值是12 每次要-- 循环条件是什么？ 到什么时候停 正常我们循环5次的话是 i<5 现在是倒着的 我们要到1停 那就是 i >= 1呗

  for(int i=min; i >= 1; i--) {
    if(m % i == 0 && n % i == 0) {
      // 找到的是所有的约数
      // System.out.println(i);

--
      // 方式2： 直接使用break关键字 因为我们是从后往前去输出 匹配到的第一个一定是最大的公约数 所以匹配到一个就使用break
      // break;
--

      // 方法1： 使用外部变量进行判断赋值
      if(i > maxY) {
        maxY = i;
      }
    }
  }
  System.out.println("最大公约数为: " + maxY);

-- 公倍数：
  int max = (n > m) ? n : m;
  for(int i = max; i < n * m; i++) {
    if(i % n == 0 && i % m == 0) {
      System.out.println("最小公倍数为: " + i);
      break;
    }
  }
}}
 -->


----------------------------

### while循环
- 循环结构的四要素
- 1. 初始化条件
- 2. 循环条件     -- boolean类型
- 3. 循环体
- 4. 迭代条件

- 通常情况下 循环结束都是因为 2 中循环条件返回false了


> while结构
  ①
  while(②) {
    ③
    ④
  }

**注意:**
- 写while循环千万不要丢了迭代条件 一旦丢了 就可能导致死循环


> 执行过程: ① -- ② --　③ --　④　　-- ② --　③ --　④ ...

<!-- 
  // 遍历100以内的所有偶数

  class Demo {
    public static void main(String[] args) {
      int num = 0;
      while(num < 100) {
        if(num % 2 == 0) {
          System.out.println(num);
        }
        num++;
      }
    }
  }
 -->


> for while 区别
- for循环和while循环是可以相互转换的
- 初始化条件的位置不同 for循环的时候是局部变量 while循环的时候是全局变量

----------------------------

### do while 循环
- 循环结构的四要素
- 1. 初始化条件
- 2. 循环条件     -- boolean类型
- 3. 循环体
- 4. 迭代条件

> do while 结构

  ①
  do {
    ③     至少也会执行依次循环体
    ④
  }while(②)


> 执行过程: ① --　③ --　④ -- ② -- ③ --　④ ...
- 上来先走依次逻辑 然后再判断条件
<!-- 
  class Demo {
    public static void main(String[] args) {
      // 遍历100以内的偶数
      int num = 1; 
      do {
        System.out.println(num);
        num++;
      } while (num < 100);
    }
  }
 -->

----------------------------

> 练习:
- 从键盘读入个数不确定的整数 并判断读入的正数和负数的个数 输入为0时结束程序
<!-- 
  一般涉及到循环就要知道 循环结构中的4个部分

  循环次数： 这道题我们判断不出来要循环多少次
  循环终止的条件: 输入 0 的时候
 -->

> 技巧
- 最简单 无限 循环格式: while(true) for(;;)
- 无限循环存在的原因是并不知道循环多少次 需要根据循环体内部某些条件来控制循环的结束

<!-- 
  import java.util.Scanner;
  class Demo {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);

        // 定义正数 和 负数
        int z = 0;
        int f = 0;

        while(true) {
          // 这步相当于初始化条件
          int num = scan.nextInt();
          
          if(num > 0) {
            z++;
          } else if(num < 0) {
            f++;
          } else {    // 一旦是0的时候 执行break 跳出循环
            break;
          }
        }

        // 跳出循环后 输出 正负数的个数
        System.out.println(z);
        System.out.println(f);
    }
  }
 -->


> 总结
- 结束循环有几种方式
- 1. 循环条件部分返回false
- 2. 在循环体中 执行break

----------------------------

### 嵌套循环
- 将一个循环结构A声明在另一个循环结构B的循环体中，就是嵌套循环
- 在开发中嵌套循环一般不会超出3层

- 外层循环： B
- 内层循环： A

> 要点：
- 1. 内层循环结构遍历一遍 只相当于外层循环 循环体执行了一次
<!-- 
  假设外层循环需要执行m次 内层循环需要执行n次 此时内层循环的循环体一共执行了 n * m 次
 -->

- 2. 外层循环控制行数 内层循环控制列数

<!-- 
  class Demo {
    public static void main(String[] args) {
      // 输出6个星
      // for(int i=0; i<6; i++) {
      //   System.out.print("*");
      // }

      // 输出4行6个星
      for(int i=0; i<4; i++) {
        
        for(int j=0; j<6; j++) {
          System.out.print("*");
        }
        System.out.println();
      }

      /*
        外层控制行数
        内层控制每行的星星

        for(int j=0; j<6; j++) {
          System.out.print("*");
        }
        System.out.println();

        for(int j=0; j<6; j++) {
          System.out.print("*");
        }
        System.out.println();

        for(int j=0; j<6; j++) {
          System.out.print("*");
        }
        System.out.println();

        for(int j=0; j<6; j++) {
          System.out.print("*");
        }
        System.out.println();

        既然要输出4行6颗星 那是不是说就可以把上面的代码重复写4次
        那500行呢？
        所以我们可以把这重复的代码 放到 另一个循环结构中

        - 要点：
        - 先考虑一行怎么输出 然后把实现一行输出的逻辑放入另一个循环中
        - 有一些像 抽离公共部分
      */
    }
  }
 -->


> 打印 正三角形
<!-- 
  *
  **
  ***
  ****
  *****
 -->

- 我的思路
- 外层循环是控制行数的 那么i=0 i<5
- 内层是用来控制输出*的 那每行输出多少呢？ 我们发现第一行i为0 输出1个* 第二行i为1 输出2个星 那就是<j+1
<!-- 还有一种理解方式 j的个数就等于行号 -->

<!-- 
  for(int i=1; i<=5; i++) {
    for(int j=1; j<=i; j++) {
      System.out.print("*");
    }
    System.out.println();
  }

  // or

  for(int i=0; i<5; i++) {
    for(int j=0; j<i+1; j++) {
      System.out.print("*");
    }
    System.out.println();
  }
 -->  


> 打印 倒三角形
- 技巧:
- 在找规律的时候 我们可以将两个数相加 然后用总和减去其中的一个变量

- 技巧:
- 还可以用两个变量相乘得到一个范围(这是突然想起上面的求最小公倍数的案例了)
<!-- 
  *****   0  5    规律 i + j = 5 换句话说 j = 5 - i
  ****    1  4
  ***     2  3
  **      3  2  
  *       4  1
 -->

<!-- 
  for(int i=0; i<5; i++) {
    for(int j=0; j<5-i; j++) {
      System.out.print("*");
    }
    System.out.println();
  }
 -->


> 打印 菱形
<!-- 
          *
         * *
        * * * 
       * * * *
      * * * * *
       * * * *
        * * *
         * *
          *
 -->

- 思路:
- 分成两段打印 先打印 ***** 上面的部分 因为上下两部分的规律不一样
- 外层for循环是控制行数
- 内层1for控制 空格
- 内层2for控制 *

<!-- 
  // 上半部分
  for(int i=0; i<5; i++) {

    // 输出空格
    for(int j=0; j<4 - i; j++) {
      System.out.print(" ");
    }

    // 输出星号
    for(int k=0; k<i + 1; k++) {
      System.out.print("* ");
    }

    System.out.println();
  }

  // 下半部分 偏左平行四边形
  for(int i=0; i<4; i++) {

    // 输出空格
    for(int j=0; j<i+1; j++) {
      System.out.print(" ");
    }

    // 输出星号
    for(int k=0; k<4 - i; k++) {
      System.out.print("* ");
    }

    System.out.println();
  }
 -->


> 100以内的所有质数
- 质数：
- 只能被1和自身整除的自然数（约数里面只有1和它本身 比如7 约数为1，7）
- 质数在很多地方都有使用 因为质数的特性就是不能再分了

- 取值范围
- 除了1 和 这个数本身的数 跟n相除 看看余数 有没有除尽的
- 所以取值范围就是 2 ~ n - 1

> 方式1: 
- 要点:
- flag变量放在外面 做为全局变量使用 这时候 每一次内层循环结束后 都要讲flag设置为初始值
<!-- 
  // 标识i是否被j除尽过 一旦除尽 就修改其值
  boolean flag = true;

  for(int i = 2; i <= 100; i++) { // 遍历100以内的自然数
    for(int j = 2; j < i; j++) {  // j被i去除

      // 如果 i % j == 0 说明这个数一定不是一个质数 因为我们的取值范围就是 2 ~ n-1 如果这里还有==0能除尽的 那就说明它一定不是质数

      // i % j != 0 这个数是质数么？ 得除完 也就是 i 得把所有的j 都除一遍 才能确定是不是一个质数 一次搞不定
      if(i % j == 0) {
        flag = false;
      }
    }

    if(flag == true) {
      System.out.println("质数为: " + i);
    }

    // 重置 flag 因为到4的时候 flag为false flag再就没有被修改回初始值 然后 4 之后就不会再被打印
    flag = true;
  }
}
 -->


> 方式2
- 要点:
- flag变量放在外层循环的里面 这样每一次循环的时候 都会有自己的flag
<!-- 
  for(int i = 2; i <= 100; i++) {
    for(int j = 2; j < i; j++) {

      // 放在内层循环的里面
      boolean flag = true;

      if(i % j == 0) {
        flag = false;
      }
    }

    if(flag == true) {
      System.out.println("质数为: " + i);
    }

    flag = true;
  }
}
 -->


> 方式3
- 当 i % j == 0 的时候 我们直接开始下一轮 看看3 是不是质数
<!-- 
  label:for(int i = 2; i <= 10000; i++) {
    for(int j = 2; j <= Math.sqrt(i); j++) {
      if(i % j == 0) {
        continue label;
      }
    }

    // 能执行到此步骤的都是质数
    System...
  }
 -->


> 优化
- 1. break
- 只对本身是非质数的自然数是有效的

> System.currentTimeMillis()
- long end = System.currentTimeMillis();
<!-- 
  if(i % j == 0) {
    flag = false;
    break;
  }


  long start = System.currentTimeMillis();

  for(int i = 2; i <= 100000; i++) {
    boolean flag = true;
    for(int j = 2; j < i; j++) {
      if(i % j == 0) {
        flag = false;
        break;
      }
    }

    if(flag == true) {
      System.out.println("质数为: " + i);
    }
    flag = true;
  }

  long end = System.currentTimeMillis();
  System.out.println(end - start);
 -->

- 2. 开方
- 对本身是质数的自然数是有效的
- 注意要加上等于 j <=
<!-- 
  for(int j = 2; j <= Math.sqrt(i); j++)
 -->

- 3. 偶数肯定不是质数 我们可以把偶数抽离出来 只去判断奇数


> 完数
- 一个数如果恰好等于它的因子之和 这个数就成为完数
- 例如：
- 6 = 1 + 2 + 3

- 编程找出1000以内的所有完数 (因子: 除去这个数本身的其它约束)
<!-- 
  public static void main(String[] args) {

    int factor = 0;

    for(int i = 1; i <= 1000; i++) {
      for(int j = 1; j < i; j++) {      还可以是 j<=i/2
        // 进去下面的条件就说明它是因子
        if(i % j == 0) {
          factor += j;
        }
      }

      if(i == factor) {
        System.out.println(i);
      }

      // 重置 factor
      factor = 0;
    }

  }
 -->

----------------------------

### 特殊关键字的使用
> break
- 使用在switch case 和 循环结构中

- 作用:
- 结束当前循环


> continue
- 只使用在循环结构中

- 作用
- 结束当次循环

**注意:**
- 1. break 和 continue 的后面不能加其它的执行语句
- 2. break默认情况下 会跳出包裹此关键字最近的一层循环
<!-- 
  for(int i=1: i<=4; i++) {
    for(int j=1: j<=10; j++) {
      if(j % 4 == 0) {
        break;
      }
      System.out.print(j)
    }
    System.out.println()
  }

  // 123
  // 123
  // 123

  因为到4的时候就会结束内层循环 所以每次都是打印到123
 -->

- 3. continue也是跳出包裹此关键字的当次循环


> 如何让break 和 coutinue 跳出指定的for循环
- 在for循环的前面 打一个标记 标记: -- break 标记;
<!-- 
  label: for(int i=1: i<=4; i++) {
    for(int j=1: j<=10; j++) {
      if(j % 4 == 0) {
        break label;
      }
      System.out.print(j)
    }
    System.out.println()
  }
 -->

----------------------------

### 家庭记账软件
- 模拟实现一个基于文本界面的 家庭记账软件
- 主要设计以下的知识点
- 1. 变量的定义
- 2. 基本数据类型的使用
- 3. 循环语句
- 4. 分支语句
- 5. 方法声明 调用 和 返回值的接收
- 6. 简单的屏幕输出格式控制

<!-- 
  运行项目后显示的用户界面

  1. 收支明细
  2. 登记收入
  3. 登记支出
  4. 退出

  请选择(1-4): 
 -->

- 需求说明
- 假设家庭其实的生活基本金为10000元
- 每次登记收入后 收入的金额应累加到基本金上 并记录本次收入明细 以便后续的查询

- 每次登记支出后 支出的金额应从基本金中扣除 并记录本次支出明细 以便后续的查询

- 查询收支明细时 将显示所有的收入 支出明细列表

- 这里等到学完后面再回来看吧 有些不是技术性的问题

----------------------------

### 数组
- 数组是多个相同类型的数据 按一定顺序排列的集合 并使用一个名字命名
- 并通过编号的方式对这些数据进行统一的管理

- 数组的常见概念:
- 数组名
- 下标
- 元素
- 数组的长度

- 数组本身是**引用数据类型** 而数组中的元素可以是任何数据类型 包括基本数据类型 和 引用数据类型

- 创建数组对象会在内存中开辟**一整块** **连续的空间** 而数组名中引用的是这块连续空间的首地址
<!-- 
  数组中一块连续的空间 不会有断开的地方
  不连续的叫做链表 通过地址找到下一个表
 -->

- 数组的长度一旦确定 就不能修改
<!-- 
  长度一旦确定 就不能修改
  比如我做着做着发现还想在数组中增加的元素 在后面补补 不行补不了
 -->

- 我们可以直接通过下标的方式调用指定位置的元素 速度很快

- 数组的分类：
- 1. 按照维度
    一维数组 二维数组 ...

- 2. 按照元素的数据类型分: 
    基本数据类型元素的数组 引用数据类型元素的数组(即对象数组)



### 一维数组的初始化

> 一维数组的声明和初始化
- 数组的初始化 分为**静态初始化** 和 **动态初始化** 
- 数组是引用类型的数据 在创建数组的时候 需要使用 new 关键字


> 静态初始化
- 解析:
- 数组的初始化和数组元素的赋值操作同时进行

- 语法:
    - 数组类型[] 数组名 = new 数组类型[]{指定元素, 指定元素...}
    - int[] ids = new int[]{1, 2, 3};


> 动态初始化
- 解析:
- 数组的初始化和数组元素的赋值操作分开进行

- 语法:
    - 数组类型[] 数组名 = new 数组类型[指定数组长度]
    - String[] names = new String[5]

**注意:**
- 不管是静态初始化 还是 动态初始化 一旦数组初始化完成 数组的长度就确定了
- 长度一旦确定就不能修改
<!-- 
  也就是说 我们创建了一个长度为5的数组 然后我们要存7个数据
  那没有办法 只能再创建一个长度为7的数组 然后把数据一个个的复制进来
 -->


> 如何调用数组的指定位置的元素
- java中通过**索引**来给数组的元素赋值 或者 调用元素
<!-- 
  String[] names = new String[5];
  names[0] = "sam";
  names[1] = "erin";
  names[2] = "nn";
  
  我们这里只添加了3个元素
 -->  

**注意:**
- 这里注意 我们只能写到0 - 4 再给下标5添加数据的时候 在java中是不行的
- 数组的长度是5 但是我们只添加了3个元素 那么其余的两个元素为**null**
<!-- 
  这里跟js不一样 js中是undefined
 -->  


> 如何获取数组的长度
- 数组的下标是从0开始 到数组的长度-1结束

- 属性:
- length
<!-- 
  System.out.println(ids.length);
 -->


> 如何遍历数组
<!-- 
  String[] names = new String[5];

  for(int i=0; i<names.length; i++) {
    System.out.println(names[i]);
  }
 -->


> 数组元素的默认初始化值
- 我们没有给数组的元素指定值 但是该元素会有默认值
- 该初始化值是系统在给我们分配空间的时候自动指定的值

<!-- 
  // 该数组 我们并没有给元素指定 值
  int[] arr = new int[6];

  for(int i=0; i<arr.length; i++) {
    System.out.println(arr[i]);     // 0 int类型的数组的默认值
  }
 -->

> 数组的默认初始化值:
- 1. 所有数组的元素是整型的时候 它的初始化值都一样为: 0
<!-- 
  - int[]     初始化值为 0
  - byte[]    0
  - short[]   0
  - long[]    0

  long[] arr = new long[6]
 -->

- 2. 数组元素的类型为 浮点型 的时候 它的初始化值为: 0.0
<!-- 
  float[] arr = new float[6]
 -->

- 3. 数组元素的类型为 char 型 它的初始化值为: 0(asc2码的0) 
<!-- 
  控制台会显示不出来 像是空格
  但它不是真正的空格 它就是一个 asc2码的值
 -->

- 4. 数组元素的类型为 boolean 型 它的初始化值为: false
<!-- 
  因为在底层 false 就是0
  boolean[] arr = new boolean[6];
 -->

- 5. 数组元素的类型为 String 型 它的初始化值为: null
<!-- 
  String[] arr = new String[6]
-->

- 6. 所有的引用类型的初始值都为 null
<!-- 
  引用类型的变量 要么就是null 要么就是地址值
 -->


> 数组的内存解析
- 数组在内存中是怎么分配结构的

- 内存的简化结构:
- 先说下常用的结构 栈(stack) 和 堆(heap) 和 方法区(methodarea)
<!-- 
  stack栈
  栈是一个从下至上的结构 线性的放数据

  stack中存放着一般是局部变量(一般方法中的变量都是局部变量)
  后添加的在上面 当整个方法结束后 会释放变量 变量依次从栈顶弹出
  --------        
  | 数据4 |
  | 数据3 |
  | 数据2 |
  | 数据1 |
  --------


  heap堆
  堆中存放的数据是new出来的结构  比如 对象 和 数组
  ----------------------
  |                     |
  |                     |
  |                     |
  |                     |
  ----------------------


  methodarea
  静态域里存放着静态的变量
  方法区里面除了常量池 和 静态域之外 还有类加载的信息
  ----------------------------------
  |    常量池         静态域         |
  |   --------      -------------  |
  |   |       |     |           |  |
  |   |       |     |           |  |
  |   |       |     |           |  |
  |   --------      -------------  |
  |                                |
  ----------------------------------

  后面介绍的字符串就放在了 常量池
  static就放在了静态域中
 -->


> 示例： 一维数组的内存解析
- 通过代码我们看看下列的两种情况在内存中是如何分配 和 解析的
<!-- 
  int[] arr = new int[] {1, 2, 3};

  1. 放在main方法中的变量都是局部变量 局部变量都会在 栈结构 中 
      我们在栈结构中 放入arr变量

  2. new int[]{1,2,3} 只要是new出来的都是在 堆结构 中
      而且这个数组的长度是3 所以在堆结构中创建一个 长度为3且连续的存储的结构 并赋上元素的初始值

  3. 堆结构中的 □-□-□ 会有一个 首地址值(第一个元素的地址值)
      首地址值通常是用一个16进制的数(0x开头)来表示 我们会把这个地址值赋值给 栈空间 中的arr

  4. 栈空间中的arr变量 通过地址值 就能找到堆空间中的数组了

  5. 然后开始对堆空间中的数组进行赋值 将默认值替换掉

  --- 栈空间 ---        --- 堆空间 ---

  arr:0x34ab           □-□-□ (第一个元素会有一个首地址值: 0x34ab)

------

  String[] arr = new String[4];
  arr[1] = "刘德华";
  arr[2] = "张学友";
  arr = new String[3];

  1. String[] arr -- 该arr会在 栈空间中声明一个变量 arr
  2. new String[4]; -- 然后会在堆空间中开启一个长度为4且连续的数组
  3. 堆空间中的数组会有一个首地址值 将首地址值赋值给栈空间中的arr
  4. arr通过首地址值指向堆空间中数组的实体 并赋元素初始值

  5. 通过下标的找到堆空间的数组中的 第2 3个元素进行赋值
  6. arr又指向了一个新的数组

  原本的数组会触发垃圾回收(垃圾回收使用了 引用技术算法)

  // 引用技术算法
  - 判断下堆空间中的数组是否还有栈空间的引用指过来 现在发现栈空间没有引用指向这个数组 就意味着它不会再次被调用了 那就会被当做是垃圾 然后被回收 该垃圾会在一个不确定的时间被回收掉


  // 最后 整个main方法执行完毕后 局部变量都会没有了 依次会从栈顶弹出
  变量弹出后 堆空间中的数组没有变量指向它 它也会被当做垃圾被回收掉

  // 所以main方法执行完后 栈 和 堆 都会被清空掉
 -->

> 练习
- 升景坊单间短期出租4个月 550一个月(水电煤公摊 网费35) 空调 卫生间 厨房齐全
- 屋内均是it行业人士 喜欢安静 所以要求出租者最好是同行 或者 刚毕业的年轻人 爱干净 安静
<!-- 
  package src.com;
  public class Demo {
    public static void main(String[] args) {
      
      int[] arr = new int[]{8, 2, 1, 0, 3};
      int[] index = new int[]{2, 0, 3, 2, 4, 0, 1, 3, 2, 3, 3};
      String tel = "";
      for(int i=0; i<index.length; i++) {
        tel += arr[index[i]];
      }
      System.out.println("联系方式: " + tel);
    }
  }

  联系方式: 18013820100
 -->


> 练习2:
- 从键盘读入学生成绩 找出最高分 并输出学生成绩等级
- 成绩 >= 最高分 - 10  -- 等级为A
- 成绩 >= 最高分 - 20  -- 等级为B
- 成绩 >= 最高分 - 30  -- 等级为C
- 其余 等级为D

- 提示 先读入学生人数 根据人数创建 int数组 存放学生成绩

- 要点:
- 1. Scanner效果是让用户输入数据 在控制台中 然后我们用变量来接收数据
- 2. if else if 范围大的放在下面 范围小的放在上面
<!-- 
  package src.com;

  import java.util.Scanner;
  public class Demo {
    public static void main(String[] args) {

      int max = 0;
      Scanner scan = new Scanner(System.in);

      System.out.println("请输入学生人数");
      // 用户与控制台交互效果 让用户输入数据
      int count = scan.nextInt();

      // 根据学生个数创建数组
      int[] arr = new int[count];

      // 给数组的元素赋值
      System.out.println("请依次输入"+count+"名学生的成绩");
      for(int i=0; i<arr.length; i++) {
        arr[i] = scan.nextInt();
        if(arr[i] > max) {
          max = arr[i];
        }
      }

      for(int i=0; i<arr.length; i++) {
        // 范围小的放在上面 范围大的放在下面
        if(arr[i] >= max - 10) {
          System.out.println("成绩为" + arr[i] + " -- 对应等级是: A");
        } else if(arr[i] >= max - 20) {
          System.out.println("成绩为" + arr[i] + " -- 对应等级是: B");
        } else if(arr[i] >= max - 30) {
          System.out.println("成绩为" + arr[i] + " -- 对应等级是: C");
        } else {
          System.out.println("成绩为" + arr[i] + " -- 对应等级是: D");
        }
      }
    }
  }
 -->

----------------------------

### 多维数组的使用
- 数组属于引用数据类型 数组的元素也可以是引用数据类型

- java语言里提供了支持多维数组的语法
- 如果说可以把一维数组当成几何中的线性图形 那么二维数组就相当于一个表格 像右图excel中的表格一样
<!-- 
  姓名    联系电话
  sam    18698712060
 -->

- 对于二维数组的理解：
- 我们可以看成是一维数组arr1又作为另一个一维数组arr2的元素而存在
<!-- 
  是不是说 一维数组相当于flex 二维数组就是grid
  下面有说
 -->

> 应用场景
- 既然老师说二维数组就是像excel表格那样 姓名 和 电话 一一对应 而姓名和电话又各自是一个数组
- 然后我们就能用同一个index 获取对应位置的一组数据了
<!-- 
  name    tel
  sam     186

  name[0] : tel[0]
 -->

- 其实从数组底层的运行机制来看 其实没有多维数组
<!-- 
    --- 栈结构 ---      --- 堆结构 ---
                         □-□ □-□ □-□   
                        ↗ ↗ ↗
    arr        →       □-□-□

    本质上看arr还是一个一维数组 只不过arr中的每一个元素又是一个一维数组
 -->


> 二维数组的声明和初始化
- 和一维数组类似
<!-- 
  回顾一维数组
  int[] arr = new int[]{1,2,3}
 -->

> 二维数组静态初始化
- 语法:
- int[][] arr = new int[][]{{1,2,3}, {4,5,6}}
<!-- 
  [[1,2,3], [4,5,6]]
 -->

> 二维数组动态初始化
- new String[3][2] 
<!-- 
  -------------
  |     |     |   第一行  每行里面有两个元素 [?, ?]
  -------------
  |     |     |   第二行  每行里面有两个元素 [?, ?]
  -------------
  |     |     |   第三行  每行里面有两个元素 [?, ?]
  -------------

  [3]可以看做是3行
  [2]可以看做每行的两个元素  [?, ?]
 -->

- 语法:
- String[][] arr = new String[3][2]
- String[][] arr = new String[3][]
<!-- 
  String[][] arr = new String[3][2]
  先是3个元素构成的一个数组 内部的每一个元素又是一个数组 这个数组的长度为2
  [[1,2], [2,3], [4,5]]

  String[][] arr = new String[3][]
  [[], [], []]    里面还不知道是长度为几的数组
 -->


- 应用场景: 
- 1. String[][] arr = new String[3][2]
- 2. String[][] arr = new String[3][]

- 1的应用场景:
- 当我们 ”行“ ”列“ 都固定的情况下 我们使用 1

- 2的应用场景:
- 当我们 ”行“ 确定 但是 ”列“ 不确定是长度为几的数组的时候 我们可以先不指定 之后用到的时候再指定
<!-- 
  new String[3][]

  -------
  new Sting[3]    我们可以动态指定内层元素数组的长度
  -------
  new Sting[7]
  -------
  new Sting[10]
  -------
 -->


- 这样写也行
<!-- 
  int arr[] = new int[]{1, 2, 3}
  int arr[][] = new int[]{{1, 2, 3}, {4, 5, 6}}

  int[] arr[] = new int[]{{1, 2, 3}, {4, 5, 6}}
 -->


> 数组的简写形式 (类型推断)
- 只针对于静态数组的创建方式 
<!-- 
  其实就是 let arr = [1,2,3] 和 let arr = new Array(1,2,3) 一样
 -->

- 语法：
- int[] arr = {1,2,3}

- 语法:
- int[][] arr = {{1,2,3}, {1,2,3}}


**注意：**
- 简写方式的时候 静态数组的 创建和初始化是在一行的可以简写
- int[] arr = {1,2,3}   // ok

- int[] arr;
- arr = {1,2,3}         // error

- int[] arr;
- arr = new int[]{1, 2, 3}    // ok


> 如何调用数组的指定位置的元素
- 静态初始化的二维数组 的指定位置的元素
- int[][] arr = new int[][]{{1,2,3}, {4,5}};    // 输出2
- System.out.println(arr[0][1]);

- 动态初始化的二维数组 的指定位置的元素
- String[][] arr2 = new String[3][2];   // 输出null
- System.out.println(arr2[1][1]);

> 有点难的地方
- String[][] arr3 = new String[3][];    // 报错
- System.out.println(arr3[1][0]);
<!-- 
  java.lang.NullPointerException
  空指针 的报错信息

  new String[3][]
        --  显示创建了 3行 但是每一行的位置是空的
        -- 每一行的位置应该存的是 另一个一维数组的地址值
        -- 现在没有创建另一个一维数组 就没有地址值 就是空指针
      

  new String[3][]
      这只是有了3行元素 但是每个元素上还没有东西
      我们要是想输出System.out.println
      就要赋值
 -->

- new String[3][]  --  arr3[1][0]
- 上面说了假如我们直接输出的话 会报错
- 因为每一行的元素 还没有值 我们假如想打印第2行的第一个元素 就必须先赋值
- 怎么赋值呢？
- arr3[1] 是第二行元素
- arr3[1] = new String[3]
- 既然每一个元素还是一个一维数组 那我就给它设置为一维数组 长度为3 这样它就又默认值了
<!-- 
  String[][] arr3 = new String[3][];
  // System.out.println(arr3[1][0]);  报空指针的错
  arr3[1] = new String[3];
  System.out.println(arr3[1][0]);

  输出2维数组中的一个元素
  这个元素是一个长度为3的一维数组 
  输出这个一维数组的第0个值
 -->

- 如果定义的是3维数组 那就是3个 String[][][] arr = new ...


> 如何获取数组的长度
- 只要是数组就应该有 length 属性

- int[][] arr = new int[][]{{1,2,3}, {4,5}, {6,7,8}};
- System.out.println(arr.length);   // 3
<!-- 
  上面这样是打印 arr 这个数组的长度 跟它每一个元素（又是一个一维数组)没有关系

  arr[1].length  查看的是 内部第2个元素对应的数组的长度
-->


> 如何遍历二维数组
- 需要双层for循环
- 3维数组就是3层for循环
<!-- 
  int[][] arr = new int[][]{{1,2,3}, {4,5}, {6,7,8}};
  System.out.println(arr.length);   // 3

  for(int i=0; i<arr.length; i++) {
    // 输出二维数组的外层所有元素;
    System.out.println("@整体数组的每个元素为" + arr[i]); 

    for(int j=0; j<arr[i].length; j++) {

      // 输出二维数组的每一个元素对应的数组
      System.out.println("#内层每一个元素中的一维数组的元素为" + arr[i][j]);

    }
  }
 -->


> 数组元素的默认值初始化值
- 规定：
- 二维数组分为外层数组的元素 和 内层数组的元素
<!-- 
  int[] arr = new int[4][3]
  外层元素:
    arr[0], arr[1], arr[2], arr[3], 

  内层元素:
    arr[0][0], arr[0][1], arr[0][2], 
 -->

- 外层数组：
- 因为外层数组的每一个元素就是一个一维数组 这时候我们输出的 就会是这个一维数组的地址值
<!-- 
  因为变量里面保存的就是地址值
  而外层数组的每一个元素位保存的就是 另一个一维数组的地址值
 -->

<!-- 
  // 只有动态创建的数组 才能够看出来 默认值
  // 外层元素的默认值
  System.out.println(arr[0]);     // [I@626b2d4a地址值

  // 内层元素的默认值
  System.out.println(arr[0][0]);  // 0
 -->

> 地址值解析 [I@626b2d4a
- [ -- 一维数组
<!-- 
  [   一维
  [[  二维
 -->  

- I        -- int型
- F        -- float型
- Ljava.lang.String;@5e265ba4  -- string
- @        -- 在什么位置
- 626b2d4a -- 真正的地址值 16进制标识的


- int[][] arr1 = new int[4][];
- System.out.println(arr1[3]);     // null
- System.out.println(arr1[3][1]);  // 报错


> 总结
- 针对于初始化方式一: int[][] arr1 = new int[4][2]
    - 外层元素的初始化值为: 地址值
    - 内层元素的初始化值为: 与一维数组初始化情况相同

- 针对于初始化方式二: int[][] arr1 = new int[4][]
    - 外层元素的初始化值为: null
    - 内层元素的初始化值为: 报错 不能调用 空指针异常


> 二维数组的内存解析
<!-- 
  int[][] arr = new int[4][];
  arr[1] = new int[]{1, 2, 3}
  arr[2] = new int[4]
  arr[2][1] = 30



  int[][] arr = new int[4][];
  因为是[4][] 所以arr的每一个元素的默认值为 int[] 
  但是int[] 还没有赋值 就是null
  因为默认值是什么取决于这个数组对应元素的类型

  --- 栈结构 ---          --- 堆结构 ---

                          首地址值: 0x1234
                          ---------
                          int[] -- null
                          ---------
                          int[] -- null   → 
                          ---------
                          int[] -- null
                          ---------
                          int[] -- null
  arr:0x1234              ---------


  arr[1] = new int[]{1, 2, 3}
  通过 arr[1] 索引 找到了第2行的元素
  new int[]{1, 2, 3} 给它赋了一个数组 这时候的默认值就是 int - 0

                        首地址值: 0x7788
  ---------             ---------
  0x7788        →       0 0 0    --  1 2 3
  ---------             ---------
 -->


> 练习1
- 声明: int[] x, y[] 在给x y变量赋值以后 以下选项允许通过编译的是
<!-- 
  x是一维数组
  y是二维数组   相当于

  int[] x;
  int[][] y;
  int[] y[];
 -->

- a. x[0] = y
<!-- 
  x是一个一维数组 
  x[0] 是一维数组中的一个数字

  y是一个二维数组

  数字 和 二维数组的类型不一样 在java中不能赋值
  int num = 1
  int[] arr = {1, 2, 3}
  num = arr; 

  // 不適合な型: int[]をintに変換できません:
  类型不符 且不能自动类型提升
 -->

- b. y[0] = x
<!-- 
  二维数组的元素是一维的 x也是一维的 类型相同可以赋值
 -->

- c. y[0][0] = x
<!-- 
    y[0][0] 它是int型的一个数字
    x是一个数组

    类型不同 不行
 -->

- d. x[0][0] = y

- e. y[0][0] = x[0]
<!-- 
  双方都是int型的数字 类型相同 可以赋值
 -->

- f. x = y
<!-- 
  类型不同 因为 一个一维数组 一个二维数组 类型不同 不能赋值
  int[]

  int[][]

  java在定义变量的时候就给变量确定的类型 赋值的时候 只有同类型的才能相互赋值

  但是 x y 存储的不都是地址值么 按照这么来说 为什么会报错呢？
  它们其实存储的不光是地址值 我们在打印的数组的时候 不光有地址值 还有该数组的类型
  [
  [[
  赋值的时候 先是类型匹配 然后才要求地址值也匹配 因为xy的类型不一样 所以不行
 -->

- 要点：
- 赋值的时候 同类型之间的才能赋值
<!-- 
  比如 flase 只能赋值给 布尔值
  比如 1.1 只能赋值给 浮点型
 -->

- 能不能通过编译 就看 满足不满足 赋值的规则


> 练习2
- 使用二维数组打印一个 10行的 杨辉三角

- 提示
- 第一行有一个元素 第n行有n个元素
- 第一行的第一个元素 和 最后一个元素都是1
- 从第三行开始 对于非第一个元素 和 最后一个元素的即


- 杨辉三角
- 随便找一个数字 这个数字上面的数字 和 上面数字左面的数字的和 等于随便找的这个数字
- 用代码翻译的话 就是

-   随便找的数字    上行数字的左侧数字      上行数字
- yanghui[i][j] = yanghui[i-1][j-1] + yanghui[i-1][j]

<!-- 
      1
      1 1
      1 2 1
      1 3 3 1
      1 4 6 4 1
      1 5 10 10 5 1
 -->

- 每行除了第一个 和 最后一个数字 其余的数字都按照这个规律来就是杨辉三角

- 思路：
- 我们造一个二维数组 然后给这个二维数组赋值 在赋值的时候满足这个规律就可以了

- https://www.bilibili.com/video/BV1Kb411W75N?p=160&spm_id_from=pageDriver
- 没看 这个链接的上一集 没事的时候可以看看



### 数组中涉及到的常见的算法
> 扩展练习
- 1. 数组元素的赋值(杨辉三角, 回形数等)
- 2. 求数值型 数组中元素的最大值 最小值 平均数 总和等
- 3. 数组的复制 反转 查找(线性查找， 二分法查找)
- 4. 数组元素的排序算法


> 1. 数组元素的赋值
- 创建一个长度为6的int型数组 要求数组元素的值都在1-30之间 且是随机赋值
- 同时 要求元素的值各不相同  (难点就是在这 怎么保证元素的值不相同)

- 思路:
1. 创建动态数组
2. 赋值 当赋值给0索引的时候没有问题 当赋值给1索引的时候 要比较下前面的 看看是不是重复的 一样的就要重新赋值 重新赋值后还要对比 直到跟前面的元素不一样了 再下一个

3. 每写入一个数字都要和前面的数字进行对比 看看一样不一样 一样可以 不一样还要重新赋值 并继续对比
<!-- 
  int[] arr = new int[6]
  for(int i=0; i<arr.length; i++) {
    arr[i] = (int)(Math.random()*30) + 1;

    boolean flag = false;
    while(true) {
      for(int j=0; j<i; j++){
        if(arr[i] == arr[j]) {
          flag = true;
          break;
        }
      }

      if(flag) {
        arr[i] = (int)(Math.random()*30) + 1);
        flag = false;
        continue;
      }
      break;
    }
  }

  for(int i=0; i<arr.length; i++) {
    System.out.println(arr[i])
  }

------------------

  方式2:
  这个可以呀
  int[] arr = new int[6];
  for(int i=0; i<arr.length; i++) {
    arr[i] = (int)(Math.random()*30) + 1;
    for(int j=0; j<i; j++) {
      if(arr[i] == arr[j]) {
        i--;
        break;
      }
    }
  }

  for(int i=0; i<arr.length; i++) {
    System.out.print(" " + arr[i]);
  }
 -->


> 算法题
- 如果我输入一个数字3 希望在控制台打印出如下形式的数据 矩阵赋值的时候是回形数
<!-- 
  1 2 3
  8 9 4
  7 6 5
 -->

<!-- 
  // 方式1
  int len = scanner.nextInt();

  创建一个动态数组 用来承接这些数字
  int[][] arr = new int[len][len];

  int s = len * len
  // k = 1 : 向右
  // k = 2 : 向下
  // k = 3 : 向左
  // k = 4 : 向上

  int k = 1;
  int i = 0, j = 0;

  for(int m = 1; m <= s; m++) {
    if(k == 1) {
      if(j<len && ar[i][j] == 0) {
        arr[i][j] = m;
      } else {
        k = 2;
        i++;
        j--;
        m--;
      }
    } else if(k == 2) {
      if(i<len && arr[i][j] == 0) {
        arr[i++][j] = m;
      } else {
        k = 3;
        i--;
        j--;
        m--;
      }
    } else if(k == 3) {
      if(j>=0 && arr[i][j] == 0) {
        arr[i][j--] = m;
      } else {
        k = 4;
        i--;
        j++;
        m--;
      }
    } else if(k == 4) {
      if(j==0 && arr[i][j] == 0) {
        arr[i--][j] = m;
      } else {
        k = 1;
        i++;
        j++;
        m--;
      }
    }
  }

  for(int m = 0; m <arr.length; m++) {
    for(int n=0; n<arr[m].length; n++) {
      System.out.print(arr[m][n] + "\t");
    }
    System.out.println();
  }

  还有种做法 自己看看吧
 -->


> 2. 求数值型 数组中元素的最大值 最小值 平均数 总和等
- 定义一个int型的一维数组 包含10个元素 分别赋一些随机整数
- 然后求出所有元素的最大值 最小值 和值 平均值 并输出出来

- 要求:
- 所有随机数都是两位数

- 提示：
- [0, 1) * 90 -- [0, 90) + 10 -- [10, 100) -- [10, 99)
- (int)(Math.random()*90 + 10)

<!-- 
  // 生成随机的两位数 [10, 99]
  // 公式： (int)(Math.random() * (99 - 10 + 1) + 10)
  int[] arr = new int[10];

  // 给这个数组 赋上两位随机数 也就是赋值操作
  for(int i = 0; i < arr.length; i++) {
    arr[i] = (int)(Math.random() * (99 - 10 + 1) + 10);
  }

  // 遍历数组 看看啥样的
  for(int i = 0; i < arr.length; i++) {
    System.out.print(arr[i] + " ");
  }
  System.out.println();

  // 求数组元素的最大值
  int maxValue = 0;  // 还可以取数组中的第一个元素的值
  for(int i = 0; i<arr.length; i++) {
    if(arr[i] > maxValue) {
      maxValue = arr[i];
    }
  }
  System.out.println("最大值为: " + maxValue);
  

  // 求数组元素的最小值
  int minValue = arr[0];  // 还可以取数组中的第一个元素的值
  for(int i = 1; i<arr.length; i++) {
    if(arr[i] < minValue) {
      minValue = arr[i];
    }
  }
  System.out.println("最小值为: " + minValue);


  // 求数组元素的总和
  int sum = 0;
  for(int i = 0; i<arr.length; i++) {
    sum += arr[i];
  }
  System.out.println("总和: " + sum);


  // 求数组元素的平均数
  double avgValue = 0;
  avgValue = sum / arr.length;
  System.out.println("平均数为: " + avgValue);
 -->


> 3. 数组的复制 反转 查找(线性查找， 二分法查找)
- 使用简单数组
- 1. 定义arr1 和 arr2 两个变量 int类型的数组
- 2. 静态初始化数组 8个元素 2 3 5 7 11 13 17 19
- 3. 显示arr1的内容
- 4. 赋值arr2变量等于arr1 修改arr2中的偶数索引元素 使其等于索引值
- 5. 打印arr1

- 思考
- arr1 和 arr2什么关系

- 扩展
- 修改题目 实现arr2 对 arr1 数组的复制
<!-- 
  int[] arr1, arr2;

  arr1 = new int[] {2, 3, 5, 7, 11, 13, 17, 19};

  for(int i = 0; i < arr1.length; i++) {
    System.out.print(arr1[i] + " ");
  }
  System.out.println();

  // 赋值arr2变量等于arr1 修改arr2中的偶数索引元素 使其等于索引值
  arr2 = arr1;  
      // 该操作不能称作数组的复制 这相当于创建了一个快捷方式


  for(int i = 0; i < arr2.length; i++) {
    if(i % 2 == 0) {
      arr2[i] = i;
    }
  }

  // 分别看下 arr1 和 arr2
  for(int i = 0; i < arr1.length; i++) {
    System.out.print(arr1[i] + " ");
  }
  System.out.println();
  for(int i = 0; i < arr2.length; i++) {
    System.out.print(arr2[i] + " ");
  }
  System.out.println();

  // 我们修改的是arr2 但是arr1也发生了变化 为什么？
  // 因为我们是把arr1的地址值给了arr2 堆空间中只有一个数组 都指向了堆空间中唯一一个数组的实体

  // 或者 我们这么记 我们new一次堆中就有一个数组 我们上面new了一次 所以堆中只有一个数组


  // 实现复制arr1的逻辑
  // 上面我们直接 arr1 = arr2 这种做法相当于 创建了快捷方式 堆中还是一个数组
  arr2 = new int[arr1.length];  // new就相当于创建了一个数组
  for(int i = 0; i < arr1.length; i++) {
    arr2[i] = arr1[i];
    System.out.print(arr2[i]);
  }
  System.out.println();
 -->

- 要点：
- 要实现复制的话 我们就真的要重新 new 一个数组 这样才是在堆结构中创建了一个数组


> 复制
<!-- 
  String[] arr1 = new String[]{"jj", "dd", "mm"};

  // 数组的复制
  String[] arr2 = new String[arr1.length];
  for(int i=0; i<arr1.length; i++) {
    arr2[i] = arr1[i];
  }
 -->


> 反转
- 方式1：
- 思路:
- 我们定义 临时变量 然后1 和 最后一个 利用临时变量交换位置 2 和 倒数第二个交换位置 依次进行

- 要点:
- 既然数组是一对对的 那么我们只需要换一遍 比如 1 2 3 4 5 6 循环3遍就可以了
- 如果循环arr1.length 那就说明循环了6遍 相当于 又换回去了 因为循环3遍的时候 已经是 6 5 4 3 2 1 了

- 那 / 2 的话 会不会除尽 或者 i<arr1.length / 2 要不要 <= 呢
- 如果要是7个元素呢？ 其实7个元素 也/2就可以了 中间的不用换
<!-- 
  String[] arr1 = new String[]{"jj", "dd", "mm"};

  // 数组的反转
  for(int i=0; i<arr1.length / 2; i++) {

    // 将第一个元素给临时变量
    String temp = arr1[i];

    // 将最后一个元素给第一个元素
    arr1[i] = arr1[arr1.length - i - 1];

    // 将临时变量中保存的第一个元素 给 最后一个元素
    arr1[arr1.length - i - 1] = temp;
  }
 -->

- 方式2：
- 思路：
- 定义一个头的变量 再定义一个尾的变量 让i++ 让j--；
- 终止条件为 i<j
<!-- 
  i 是从前往后
  j 是从后往前

  i 和 j 不要碰头(要不反过来了) 所以当不满足 i < j 的时候停止
 -->

<!-- 
  // 方式2 定义一个头的变量 再定义一个尾的变量 让
  for(int i=0, j=arr1.length-1; i<j; i++, j--) {

    // 将第一个元素给临时变量
    String temp = arr1[i];

    // 将最后一个元素给第一个元素
    arr1[i] = arr1[j];

    // 将临时变量中保存的第一个元素 给 最后一个元素
    arr1[j] = temp;
  }
 -->


> 查找
- 在众多的数据当中查找一个数据看看存在与否
- 查找有很多的实现方式 这里只提出两种方式
- 1. 基本的 线性查找
- 2. 用的多 二分法查找

> 线性查找
- 从前往后依次查找 找到之后就停止
- 通过遍历的方式 一个一个的数据进行比较 查找
- 具有普遍的实用性

- 查找结果
- 1. 利用 true 和 false 来解决
- 2. 找到后告诉我位置 没找到告诉我没有

**注意：**
- 如果是判断是否相等的时候 如果是 int型 我们使用 ” == “
- 如果是判断是否相等的时候 如果是 String型  我们使用 字符串.equals(内容) 看看字符串中是否有给定的内容

> 字符串.equals(给定内容)
- 查看该字符串中是否包含给定内容

<!-- 
  String[] arr1 = new String[]{"jj", "dd", "mm"};

  // 查找 or 搜索 -- 线性查找(从前往后一个个找)
  // 1 定义一个查找的目标
  String desc = "ll";

  boolean flag = true;

  for(int i=0; i<arr1.length; i++) {

    // 当字符串做全等判断的时候 使用
    if(desc.equals(arr1[i])) {
      System.out.println("找到了指定的元素 位置为: " + i);
      flag = false;
      break;
    }
  }

  // 因为循环结束后才知道结果 所以在循环外打印
  if(flag) {
    System.out.println("没有找到哦");
  }
 -->


> 二分法查找
- 前提:
- 所要查找的数组必须有序 在有序的前提下 我们再进行查找
<!-- 
  String[] arr1 = new String[]{"jj", "dd", "mm"};
  上面的数组就看不到顺序

  int[] arr = new int[] {-98, -34, 2, 24, 55, 88, 988};
  上面的数组就有顺序 至于升序还是降序就无所谓
 -->

- 相对于线性查找的话 比较快 二分法查找也叫做 **折半查找**
- 上来我就定位到中间
<!--  
    1 2 3 4 5 6 7 8 9 10
    上来就从一半的位置开始
 -->

- 思路：
- 每次比较中间值 折半的方式检索
<!-- 
    1. 我们先拿 目标值 和 中间值 15 进行对比 如果 目标值 > 中间值 就对右侧部分再次进行对半分
                小          大
                      |
                      |
          2 5 6 8 10 1|5 18 20 22 25 28

    2. 再次对半 然后在看中间值 和 目标值的大小 然后再进行选择对哪个部分进行对半
                       |
                18 20 2|2 25 28
 -->

- 要想得到中间值(中间索引) 那就要 未 - 头 / 2

- 代码部分
<!-- 
  // 二分法查找 前提要查找的数组必须有序 降序还是升序无所谓
  int[] arr = new int[] {-98, -34, 2, 24, 55, 88, 988};

  // 定义目标值
  int dest = -34;

  // 求中间值
  // 定义 首索引
  int head = 0;
  
  // 定义 末位索引
  int end = arr.length - 1;

  boolean flag = true;

  // 循环终止的条件 head 不能超过 end 两个值相当的时候也要看一下 万一它就是我们想要得值呢？
  while(head <= end) {
    // 获取 中间值 因为是int所以除不尽的时候我们取的就是整数部分 正好
    int middle = (head + end) / 2;

    // 得到中间值后 就看看 目标值 和 中间值 进行比较
    // 如果 目标值 和 中间值相等 说明找到了
    if(dest == arr[middle]) {
      System.out.println("找到了指定的元素 索引位置为：" + middle);
      flag = false;
      break;

      // 进入以下判断说明我们的目标值应该在 左部分
    } else if(arr[middle] > dest) {
      // 那我们就让 end 为 middle 前面一个索引
      end = middle - 1;

      // 进入下面的循环代表我们的目标值应该在 右部分
    } else {
      head = middle + 1;
    }
  }

  if(flag) {
    System.out.println("没有找到哦");
  }
 -->


> 技巧
- 前提 数组有序 且 规律 我们可以不用从1半的位置开始查找 而是从 几分之几的位置开始
<!-- 
  目标值 - 第一个元素 / 最大的元素 - 第一个元素
 -->


> 排序算法
- 排序的操作在实际开发中用的也比较多 很多情况下都有排序的述求
- 必须评分高低 排序
- 距离远近 排序
- 价格 销量 评价等等

- 有的时候我们为了查找更快 也可以先对数组进行排序 比如二分法就会要求数组有序
- 先排序 后二分

- 排序定义：
- 假设含有n个记录的序列(r1, r2, ...rn) 其相应的关键字序列为(k1, k2, ...kn)
- 将这些记录重新排序为(ri1, ri2, ...rin)
- 使得相应的关键字值 满足条件(ki1, ki2, ...kin)这样的一种操作 成为排序

- 通常来说 排序的目的就是快速查找
<!-- 
  比如我们有一个数组 就是整型的数据 它的关键字就是我们数的本身 我们希望它是从小到大的

  我们在排序的时候 不一定是一个纯数字 比如 我们在淘宝上买水杯 会显示一个水杯的列表
  那一个水杯并不是一个 数字 是一个 对象了

  这些对象也是可以排序的 我们按照对象中的属性来排序 这些属性就可以理解为上面说的关键字
 -->

> 衡量排序算法的优劣
- 通常的算法主要是从时间和空间上 我们追求的是高效率和低存储
- 但是针对排序算法的话 我们又会多一个 稳定性的指标

- 1. 时间复杂度
- 分析关键字的比较次数 和 记录的移动次数

- 2. 空间复杂度
- 分析排序算法中需要多少辅助内存
<!-- 
  比如 反转 我们上面的例子中就 使用了中间变量 开辟了 一个temp空间
 -->

- 3. 稳定性
- 若两个记录a和b的关键字相等 但排序后 a b的先后次序保持不变 则称这种排序算法是稳定的
<!-- 
  比如 3 4 1 5 2 3 排序后 肯定是 1 2 3 3 4 5

  如果排序前 3 的位置 和 排序后的位置 没有发生变化 就是稳定的
  比如排序前 3[0] 3[1] 排序后还是 3[0] 3[1] 就是稳定的
 -->

- 稳定性的作用
<!-- 
  比如 商品 我们已经按照销量从高到低 排序的
  但是这些商品中可能有价格一样的

  这时候我们可能会有这样的场景 在指定销量从高到低排序的基础上 在指定价格从低到高排序

  这时候 如果两个商品的价格一样 我们就希望 销量高的在上方
  本身就是按照销量高 - 低排序的 我们再次按照价格排序的时候 不要改变 原本销量的顺序

  这就是稳定性
 -->


> 排序算法的分类
- 1. 内部排序
- 整个排序过程不需要借助于外部存储器(如磁盘) 所有排序操作都在内存中完成

- 2. 外部排序
- 参与排序的数据非常多 数据量非常大 计算机无法把整个排序过程放在内存中完成
- 必须借助于外部存储器 外部排序最常见的是多路归排序，可以认为外部排序是由多次内部排序组成
<!-- 
  比如2g的数据 但是内存只有1g
 -->


> 十种排序算法
- 1. 选择排序
  - 直接选择排序 堆排序

- 2. 交换排序
  - 冒泡排序 快速排序

- 3. 插入排序
  - 直接插入排序 折半插入排序 shell排序(希尔排序)

- 4. 归并排序

-- 上面比较常用 --

- 5. 桶式排序
- 6. 基数排序


> 算法的5大特征
- 1. 输入(input)
- 有 0 个或多个输入数据，这些输入必须有清楚的描述和定义
<!-- 
  算法要做点事儿必须要有原材料 输入点东西
 -->

- 2. 输出（Output)
- 至少有 1 个或多个输出结果，不可以没有输出结果
<!-- 
  算法算了半天要有输出的结果
 -->

- 3. 有穷性（有限性，Finiteness)
- 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成
<!-- 
  我们的算法要在有限的步骤内结束 每个步骤必须在可接受的时间内完成
 -->

- 4. 确定性（明确性，Definiteness)
- 算法中的每一步都有确定的含义，不会出现二义性

- 5. 可行性（有效性，Effectiveness)
- 算法的每一步都是清楚且可行的，能让用户用纸笔计算而求出答案
<!-- 
  不借助计算机也能算出来
 -->

- 说明：满足确定性的算法也称为：确定性算法。 现在人们也关注更广泛的概念 
- 例如考虑各种非确定性的算法 如并行算法、概率算法等。
- 另外 人们也关注并不要求终止的计算描述 这种描述有时被称为过程 procedure。


> 冒泡排序
- string类型也是可以排序的 按照abc 或者 unicode 的值 对象按照属性来排序

- 思想：
- 冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。

- 1. 比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。

- 2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
<!-- 
  每比较一轮都会产生一个最大值 每一大轮都是从头开始 同时每一轮要比较的数就减少了
 -->

- 3. 针对所有的元素重复以上的步骤，除了最后一个。
- 4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较为止 。
<!-- 
  8个元素 总共要比较7轮 最后一轮就是最小的数了
  每一轮都会产生一个最大值 放在依次放在最后面
 -->

- 代码部分:
<!-- 
  int[] arr = new int[] {43, 32, 76, -98, 0, 64, 33, -21, 32, 99};

  // 冒泡排序
  // 外层for是几大轮 arr.length-1 因为假如数组的长度为8 那我们就比较7轮 因为最后一轮就是最小的一个数
  for(int i=0; i<arr.length-1; i++) {

    // 当i=0的时候 我们比较7次 当i为1的时候我们比较6次 因为越来越少 所以arr.length-1-i
    for(int j=0; j<arr.length-1-i; j++) {
      // 如果前面的数 比 后面的数大 就交换位置 每次外层+1 内层就是-1 因为 j<arr.length-1-i
      if(arr[j] > arr[j+1]) {
        int temp = arr[j];
        arr[j] = arr[j+1];
        arr[j+1] = temp;
      }
    }
  }

  for(int i=0; i<arr.length; i++) {
    System.out.print(arr[i] + "\t");
  }
 -->


> 快速排序
- 介绍：
- 快速排序通常明显比同为O(nlogn) 的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。
- 可见掌握快排的重要性 。

- 快速排序（Quick Sort）由图灵奖获得者 Tony Hoare 发明，被列为 20 世纪十大算法之一 ，是迄今为止所有内排序算法中速度最快的一种。

- 冒泡排序的升级版，交换排序的一种。快速排序的时间复杂度为 O(nlog(n)) 。


- 排序思想:
- 1. 从数列中挑出一个元素，称为 基准 pivot
- 2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置这个称为分区（ partition ）操作。

- 3. 递归地（ recursive ）把小于基准值元素的子数列和大于基准值元素的子数列序。

- 4. 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代iteration ）中，它至少会把一个元素摆到它最后的位置去。

<!-- 
  比如

  keyword
  ↓
  5 2 9 3 8 4 0 1 6 7
    ↑               ↑
    low             high

  1. 首先我们定义一个keyword(keyword我们选择数组中的任意一个都可以) 这里取第一个

  2. 然后我们定义两个指针 low high
  这里注意 
  我们定义的  low指针   要比keyword要小
  我们定义的  high指针  要比keyword要大

  3. low指针不断的往右走 high指针不断的往左走

  4. low指针 high指针的停止条件 
  low指针首次出现比keyword大了
  high指针首次出现比keyword小了

  5. 出现上述的条件的时候 我们把 两个指针指向的元素对调一下
  (说白了我们定义一个keyword 想达到的效果就是想keyword为基准 左边是比keyword小的 右边是比keyword大的)

  6. 经过了一轮之后 就会以keyword为准 左边部分是比keyword小的 右边是比keyword大的

  7. 然后就相当于有了两个数组(左 右) 针对于左部分数组 我们再次的定义low high
 -->

- 代码部分:
<!-- 
  代码部分在资料里面自己看看 pdf
 -->

----------------------------

### Arrays工具类的使用
- import java.util.Arrays;

- java.util.Arrays类 即为操作数组的工具类 包含了用来操作数组(比如排序和搜索)的各种方法

- 再出现数组的问题的时候 我们要先考虑Arrays中是否有对应的结构供我们去调用

- 常见的方法:

> Arrays.equals(int[] a, int[] b)
- 判断两个数组是否相等
- 会返回一个布尔值 注意创建变量接收
<!-- 
  int[] arr = new int[] {1, 2, 3, 4};
  int[] arr2 = new int[] {1, 3, 2, 4};

  boolean res = Arrays.equals(arr, arr2);
  System.out.println(res);    // false

  // 数组是有顺序 arr 和 arr2 的顺序不一样 所以它们不向相等

  equals方法的原码
  - 1. 先去比较地址值 如果地址值一样代表 就是一个对象 不用比了
  if(arr = arr2) return true    // 这么比较的时候 比较的是地址值

  - 2. 然后再比较两个数组的长度 长度不一样 也是false
  - 3. 然后长度一样之后 看看里面的元素是否一样 就是一个个元素比较
 -->

> Arrays.toString(int[] a)
- 输出数组信息。相当于遍历给定的数组
- 结果是一个字符串 [元素1,元素2]
<!-- 
  System.out.println(Arrays.toString(arr));
  [1, 2, 3, 4]

  还可以输出数组指定元素的内容
  System.out.println(Arrays.toString(arr[1]));  // null
 -->

> void fill(int[] a, int val) 
- 将指定值填充到数组之中。
- 将原数组中的每一个元素 都替换成val
<!-- 
  Arrays.fill(arr, 10);
  System.out.println(Arrays.toString(arr));   [10,10,10,10]
 -->

> void sort(int[] a)
- 对数组进行排序。
- 对原数组有影响
<!-- 
  Arrays.sort(arr2);
  System.out.println(Arrays.toString(arr2));
 -->

> int binarySearch(int[] a,int key)
- 对排序后的数组进行二分法检索指定的值。
- 找到的话 返回 给定元素所在的索引
- 没找到的话 返回 负数
<!-- 
  int[] arr3 = new int[] {-98, -34, 2, 24, 54, 66, 79, 105};
  int index = Arrays.binarySearch(arr3, 79);
  System.out.println(index);
 -->

----------------------------

### 数组使用中的常见异常
- 一旦程序出现异常以后 后面的代码就不会执行了

- 1. 数组角标越界的异常
- ArrayIndexOutOfBoundsExcpetion
- System.out.pirntln(arr[-2])
<!-- 
  int[] arr = new int[] {1,2,3,4,5};

  i <= arr.length 循环的时候不小心写了一个 = 也会报错
  for(int i=0; i<arr.length; i++) {
    System.out.println(arr[i]);
  }
 -->

- 2. 空指针异常
- NullPointerException

- 情况1：
- arr变量 没有对应的地址值找不到堆空间的实体的时候就会报错
- 1维数组中出现该问题 就看看我们有没有造数组 然后看看赋值

- 情况2：
- 二维数组中的内存数组 如果是null的情况下 那么它就会报空指针异常错误
<!-- 
  int[][] arr = new int[4][]
  arr2[0]    // null

  arr2[0][0]  // 空指针异常
 -->

- 情况3：
- 当我们使用 toString() 方法输出指定数组的值的时候 当该值为null 
- 那么也会抛出空指针异常的错误
<!-- 
  String[] arr = new String[] {"aa", "bb"};
  arr[0] = null;
  System.out.println(arr[0].toString());
 -->

----------------------------

### 面向对象

> java面向对象学习的三条主线
- 对象也是由类派生的

- 1. java类 及 类的成员
<!-- 
  类的成员包括：
  1. 属性
  2. 方法
  3. 构造器
    ---
  4. 代码块
  5. 内部类
 -->


- 2. 面向对象的三大特征
<!-- 
  封装 继承 多态 (抽象性)
 -->


- 3. 其它关键字
<!-- 
  this super static final abstract interfact package import
 -->


**扩展**
> 何谓 面向对象 的编程思想
- 首先解释一下”思想“
- 先问你个问题 你想做个怎样的人
- 可能你会回答 我想做个好人 孝敬父母 尊重常备 关爱朋友
- 你看 这就是思想 这是你做人的思想 或者说 是你做人的原则
- 做人有做人的原则 编程也有编程的原则 这些编程的原则 就是 编程思想

- 编程思想：
- 包含: 类 对象 面向对象的三大特征


> 理解面向过程 和 面向对象
- 面向过程pop 与 面向对象oop
<!-- 
  面向对象: object oriented programming
  面向过程: procedure oriented programming
 -->

- 两者都是一种思想 面向对象是相对于面向过程而言的

- 面向过程： 
    强调的是功能行为 以函数为最小单位 **考虑怎么做**
    *强调的仅仅是功能*

- 面向对象：
    将功能封装进对象
    强调具备了功能的对象 以类 或者 对象为最小单位 **考虑谁来做**
    *强调的是功能的主体*

- 面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则
- 如抽象 分类 继承 聚合 多态等

<!-- 
  人把大象装进冰箱

  1. 面向过程
  - 下面的每一个过程都体现着功能和行为 用函数来进行刻画
      把冰箱门打开
      抬起大象 塞进冰箱
      把冰箱门关闭


  2. 面向对象
  - 在用面向对象的方式去思考这个过程的时候 我们首先要考虑的是主体都有什么
  - 人
  - 冰箱
  - 大象

  - 然后我们再考虑这个主体应该具备什么样的功能 把这个功能我们封装到主体(对象)里面去

  - 我们看下各自的主体应该具备什么样的功能(方法) 每一个主体就是一个类
  - 然后我们要考虑实现这个功能各自的类中需要什么对应的方法

    Ren {
      打开(冰箱) {
        冰箱.开门();
      }

      抬起(大象) {
        大象.进入（冰箱）；
      }

      关闭（冰箱） {
        冰箱.闭合（）；
      }
    }
    
    Bingxiang {
      开门() { ... };
      闭合() { ... };
    }

    Daxiang {
      进入(冰箱) { ... }
    }
 -->


> 面向对象中的两个概念： - 类和对象
- 类：
- 抽象的 概念上的内容

- 对象：
- 实实在在存在的一个个体
- 生活中的实实在在是一个摸得到的对象
- 代码中的实实在在是内存中有这个东西 在内存中创建了一个对象 占据了内存中的一定空间

- 两者关系：
- 对象是类的实例 是由类new出来的


- 对象是类的实例化 通过类来实例化对象 然后通过对象调用属性和方法
<!-- 
  js中对象其实就是new Object得到的
 -->

- 例子: 最好举我们开发中的场景


> 现象对象的思想概述
- 程序员从面向过程的执行者转化成了面向对象的指挥者


> 面向对象思想的体现
- 类 和 对象的创建和执行操作有哪三步
- 1. 创建类
- 2. 类的实例化
- 3. 通过调用对象的属性和方法


> 面向对象分析方法 分析问题的思路和步骤
- 1. 根据问题需要 选择问题所针对的现实世界中的实体
- 2. 从实体中寻找解决问题的相关属性和功能 这些属性和功能就形成了概念世界中的类
- 3. 把抽象的实体用计算机语言进行描述 形成计算机世界中类的定义 即借助某种程序语言 把类构造成计算机能够识别和处理的数据结构
- 4. 将类实例化成计算机世界中的对象 对象是计算机世界中解决问题的最终工具


> 练习：
- 我要开车去丽
- 上述这句话中包含的类有什么
<!-- 
  人 - 类
  车 - 类

  如果想描述丽江的信息非常的多 那么就将丽江也分装成一个类 
  如果只是调用了一下 就当做是一个普通的字符串就可以了
 -->


> 面向对象的三大特征
- 1. 封装
- 2. 继承
- 3. 多态

----------------------------

### 类 和 对象
- 类 class 和 对象 object 是面向对象的核心概念
- 类是对一类事物的描述 是抽象的 概念上的定义
- 对象是实际存在的该类事物的每个个体 因而也成为实例

- 万事万物皆对象

- 面向对象程序设计的重点是 **类的设计**
- **类的设计** 其实就是类的成员的设计


> 类的成员: 属性 和 方法
- 属性: 
- 对应类中的成员变量

- 行为:
- 对应类中的成员方法

<!-- 
  Field = 属性 = 成员变量
  Method = 成员方法 = 函数
 -->

<!-- 
  java中的各种项目 不管大小内部都是由一个个的类构成了 简单到一个helloworld也是由类构成的
 -->


> 接下来我们创建一个person类
- 我们可以看到 我们创建一个类 和 js中的方式很像
- 唯一不同的地方在于 在定义变量和方法的时候 有些像ts 要求定义变量和方法的时候更加的严谨
- 比如定义变量 我们要使用对应的关键字等
<!-- 
  class Person {
    // 属性
    String name;
    int age = 1;
    boolean isMale;

    // 方法(功能)
    public void eat() {
      System.out.println("人可以吃饭");
    }

    public void sleep() {
      System.out.println("人可以睡觉");
    }

    public void talk(String language) {
      System.out.println("人可以说话 使用的语言是: " + language);
    }
  }
 -->

> 类中属性的定义: 类型名 变量; 
- String name;
- String name = "sam";

- 非static属性都是通过实例化这个类的实例对象身上的
- 调用实例对象方法的对象 就是 name属性所在的对象 因为这些属性都是归具体的某一个对象所有的

- 每造一个对象 这些属性都会独立的有一份 抛开对象谈属性现阶段试没有意义的
- 因为这些属性都要归到某一个对象里面

- 掉调用实例对象的方法 方法中的属性就是方法所在的对象中的属性
<!-- 
  比如我们是通过 c1 实例对象调用的 show方法 
  show方法中的color属性就是c1实例对象中的
 -->


> 类中方法的定义: public 关键字 方法名() { ... }
- 
  public void sleep() {
    System.out.println("人可以睡觉");
  }

**注意:**
- 方法中不可以再定义方法 方法就是一个个独立的功能 彼此都不相关的
- 但是可以调用方法
<!-- 
  // 方法中再次定义方法是不行的 这点跟js不一样
  public void test() {
    System.out.println("test");
    
    public void test2() {
      System.out.println("test2");
    }
  }
 -->

> 创建类的对象 = 类的实例化 = 实例化类
> Person p1 = new Person();
- 跟js比较像 区别就在于 我们前面不是用var let const 来声明变量 而是使用指定的类名来声明创建类
<!-- 
  class Person { }

  // 类的实例化
  Person p1 = new Person();
 -->


> Person类的属性和方法的调用
- 面向对象思想落地的实现
<!-- 
  // 定义main方法作为程序的入口
  public static void main(String[] args) {


    // 创建Person类的对象 也叫类的实例化 类名 变量名 = new 类名() 这就是类的实例化
    Person p1 = new Person();

    // 调用对象的结构 调用属性 和 调用方法
    // 调用属性 对象.属性
    p1.name = "Tom";
    p1.isMale = true;


    System.out.println(p1);        // src.com.Person@5e91993f 地址值
    System.out.println(p1.name);   // Tom
    System.out.println(p1.isMale); // true

    // 调用方法
    p1.eat();
    p1.talk("中国语");
  }
 -->


> 思考:
- 上面我们通过 Person类 new了一个p1对象 然后我们通过 p1.name 赋值为 Tom
- 那么这时候 我们再new一个p2对象 这时候打印p2.name会是什么结果？ null
<!-- 
  我们想想在堆空间中有几个对象？ 两个！
  因为每new一次 相当于又造了一个对象 说明在堆空间中是有两个对象实体的

  Person p1 = new Person();
  Person p2 = new Person();

  每一份对象实体都一份独立的属性
  (我们是通过类的模板来创建的对象)
 -->

> 总结:
- 如果创建了一个类的多个对象 则每个对象都独立的拥有一套类的属性(非static 没有加static关键字)
- 如果我们修改一个对象的属性a 则不影响另外一个对象属性a的值

----------------------------

### 对象的内存解析
- 这节里我们看看对象在内存中的结构是什么样的
- 内存解析是在文件运行的时候才会涉及到的东西

- 内存解析网址：
- https://www.bilibili.com/video/BV1Kb411W75N?p=197&spm_id_from=pageDriver

<!-- 
  技巧：
    - 在画内存结构图的时候 我们直接从 main方法里面开始看 看 new Student 部分

    - 这样才能着手在堆空间中画图

    - 1. 声明 栈 和 堆
    - 2. 从new Student开始看 ...

    - 3. 非static属性都是在堆空间中
    (js中非static属性都是类的实例化对象的 所以在堆空间中)
    (js中static属性是类自己的属性)
 -->

- 流程:
- 编译完源代码以后 生成一个或多个字节码文件 我们使用jvm中的类的加载器和解释器对生成的字节码文件进行解释运行
<!-- 
  运行的时候意味着我们源代码中的变量 对象会被创建 在内存中运行
  将字节码文件对应的类加载到内存中 涉及到内存解析
 -->

> 堆heap 
- 此内存区域的唯一目的就是**存放对象实例** 几乎所有的对象实例都在这里分配内存
- 这一点在java虚拟机规范中的描述是：
    所有的对象实例以及数组都要再堆上分配

> 栈stack 
- 是指虚拟机栈
- 虚拟机栈用于**存储局部变量**等 局部变量表存放了编译期可知长度的各种基本数据类型(boolean byte char short int float long double)
- 对象引用(reference类型 它不等同于对象本身 是对象在堆内存的首地址)
- 方法执行完 自动释放

> 方法区method area
- 用于存储已被虚拟机加载的 **类信息 常量 静态变量 即时编译器编译后的代码** 等数据

<!-- 
  class文件    →      类装载器
                      ↑   ↓
                      内存区域

              方法区    虚拟机栈    本地方法栈
                                              →  垃圾收集器
              堆       程序计数器


  局部变量存储在    - 栈结构中
  new出来的结构在   - 堆空间中

  实例对象的属性在  - 堆空间中

  
  static属性会在方法区 非static会在堆空间中
  
  方法区： 
    - 方法区包括
    - 类的加载信息 常量池 静态域

  <<JVM规范>> 这是一本书 内部提到了内存结构 可以扩展看看
 -->


> 对象的内存解析
- Person p1 = new Person();
- p1.name = "Tom";
- p1.isMale = true;

- Person p2 = new Person();
- System.out.println(p2.name);

- Person p3 = p1;
- p3.age = 10;

- 目前我们没有用到方法区 主要是栈和堆的结构
<!-- 栈的特点是先进后出 -->

<!-- 
    栈                    堆

                          new Person();

                          0x12ab
    p1: 0x12ab   ↗        ---------
                          属性： 
                          （它们不同与栈中的局部变量 局部变量在栈里 属性属于对象的一部分在堆空间里面）
                          name;
                          age;
                          isMale;

------

                          new Person();

                          0x7788
    p2: 0x7788   ↗        ---------
                          属性： 
                          （它们不同与栈中的局部变量 局部变量在栈里 属性属于对象的一部分在堆空间里面）
                          name;
                          age;
                          isMale;
 -->


 **注意：**
- 引用类型的变量 只可能存储两类值
- 1. 空值
- 2. 地址值(地址值中也包含变量的类型)
<!-- 
  比如 我们创建了一个存放引用类型的元素的数组
  - 数组中每一个元素的位置 不是直接存放对 象 而是存放的地址值 该地址值指向堆空间中的一个对象的实体
 -->

----------------------------

### 类中的属性
- 在类中有属性和方法 那么下面我们主要研究下属性 和 方法

> 属性的使用:
- 属性也叫做成员变量 


> 成员变量 和 局部变量
\\ 不同点1:
- 主要是根据声明它们的位置不同才有这样的区分

- 属性:
- 直接定义在类的一对{ }内
<!-- 
  class Person {
  
    String name;
    int age = 1;
    boolean isMale;

  }
 -->

- 局部变量:
- 声明在 **方法内 方法形参 代码块内 构造器形参 构造器内部的变量** 都叫做局部变量
<!-- 
  局部变量 -- 形参
  public void talk(String language) {
    System.out.println("我们使用" + language + "进行交流");
  }


  局部变量 -- 方法内定义的变量
  public void eat() {
    String food = "烙饼";
    System.out.println("北方人喜欢吃" + food);
  }
 -->

\\ 相同点
- 1. 定义变量的格式一样 数据类型 变量名 = 变量值
- 2. 先声明 后使用
- 3. 变量都有其对应的作用域


\\ 不同点2：
> 属性 - 权限修饰符
- 对于属性来讲 可以在声明属性时 指明其权限 使用权限修饰符

- 常用的权限修饰符
- 1. private (出了定义它的类后 该属性就不能调用了)
- 2. public
- 3. 缺省
- 4. protected
<!-- 
  class Person {
    
    // 没有些权限修饰符的时候就是 缺省 状态
    String name;

    // 带权限修饰符
    private int age;
    public String name;

  }
 -->

- 作用：
- 权限修饰符是指该属性被调用时候可见性的大小
<!-- 
  在类的封装性的时候再讲 我们现阶段设置属性的时候 使用缺省就可以了
 -->

**局部变量不能使用权限修饰符**
- 还可以理解为局部变量的权限就被方法的权限代替了 因为方法是public那么该属性的权限也是public


\\ 不同点3: 
> 属性 - 默认初始化值(也是局部变量和属性的不同点)
- 对于类中的属性来讲是有默认初始化值的
- 对于属性来讲 它是可以直接使用的 即使没有赋值(因为有初始化值)

- 类的属性 根据其类型 有默认初始化值的
- 整型:   byte short int long  --  0
- 浮点型: float double  --  0.0
- 字符型: char --  0 或 \u0000
- 布尔型: false
- 引用数据类型: 类 数组 接口 都是 null


**局部变量没有初始化值**
- 这样意味着 我们在调用局部变量之前 一定要显式赋值
<!-- 
  下面有一个问题 就是因为 
  局部变量没有初始化值在使用局部变量之前一定要先赋值
  但是
  属性就有默认得初始化值
 -->

\\ 特别的
- 形参在调用时 赋值即可
- 我们声明了形参但是调用方法的时候如果没有传递实参就会报错 也就是说java中定义的形参必须要传递实参么？


> 属性 和 局部变量 在内存中加载的位置不一样
- 属性: 
       加载在堆空间中

- 局部变量:
       加载到栈空间


**回顾变量分类**
                ↗ 基本数据类型 : 数值型(byte short int long float..)
                               字符型(char)
                               布尔型(boolean)
- 1. 按照数据类型 
                ↘ 引用数据类型 : 类 接口 数组

          
- 2. 在类中声明的位置 
                   ↗ 实例变量(不以static修饰)
        ↗ *成员变量*  
                   ↘ 类变量(以static修饰)
所有变量
                   ↗ 形参(方法 构造器中定义的变量)
        ↘ *局部变量* →  方法局部变量(在方法内定义)
                   ↘ 代码块局部变量(在代码块内定义)
 
----------------------------

### 类中的方法
- 这节我们研究下类中的方法的声明和使用
<!-- 
  在类当中属性就属于我们定义的一些变量了 用来描述类中对象的特点
  方法是用来刻画我们类应该具有的功能 
  每一个方法用来做特定的事情 完成特定的功能
 -->


> 方法的作用
- 用来描述类应该具有的功能
- 方法就是功能 将功能封装到方法中


> 方法的声明
- 格式:
  权限修饰符 [关键字] 返回值类型 方法名(形参) { 方法体 }

  public void sleep(int hour) {
    System.out.println("客户睡了" + hour + "小时");
  }

- 部分1: 
- 权限修饰符
- private(私有) / public(公共) / 缺省 / protected
- 权限修饰符的作用就是方法被调用的时候的权限大小
<!-- 
  封装性的时候我们再说 权限修饰符 目前先用public
 --> 


- 部分2:
- 返回值类型
- 有返回值的情况:
- 如果方法有返回值 **则必须在方法声明时 指定返回值的类型 同时方法中需要使用 return关键字** 来返回指定类型的数据

- 没有返回值的情况:
- 如果方法没有返回值 **则方法声明时 使用 void 来表示**
- 通常没有返回值的方法中 不需要使用return 但是如果使用return的话
- 只能 **return;** 表示结束该方法
<!-- 
  public void eat() {
    System.out.println("客户吃饭");
    return；
  }
 -->


- 部分3:
- 方法名
- 方法名就是标识符 在写方法名的时候 要遵循标识符的规则和规范 要 见名知意


- 部分4:
- 形参
- 方法可以声明0个 1个或多个形参

- 格式:
- (数据类型 形参, 数据类型2 形参2)


- 部分5:
- 方法体
- 方法功能的体现


> return 关键字的使用
- 使用范围:
- 使用在方法体中

- 作用: 
- 1. 结束一个方法 类似break
- 2. 针对于有返回值类型的方法 使用 "return data" 返回指定的数据
- 3. return关键字后面不可以有任何语句


> 方法的返回值类型
- 处于方法名前

- void:
- 没有返回值

- String:
- 返回值的类型为字符串


> 方法的使用
- 类中方法内 可以调用当前类中的属性 和 方法
<!-- 
  递归方法：
  方法A中调用了方法A 就叫做递归方法
 -->

- 方法中不能定义别的方法
<!-- 
  错误的方式
  public void info() {
    public void swim() {

    }
  }
 -->


> 一个包文件夹中的一个.java文件可以调用另一个.java文字中的代码
<!-- 
  public class PersonTest { }
  public class Person { }

  上述的两个类在各自的两个.java文件中
  这两个java文件在一个包文件夹下

  PersonTest 类中 不用引入 Person文件 直接可以new Person 和 通过实例调用方法和属性
  public class PersonTest {
    // 不用在该文件中引入 Person.java 文件
    Person p1 = new Person();
  }
 -->


**java文件中的/** */注释 在别的java文件中调用的时候 起到了提示的作用*


> 练习1:
- 创建一个Person类 其定义如下:
- 要求:
- 1. 创建Person类的对象 设置该对象的name age sex属性 调用study方法 输出字符串“studying” 调用showAge方法显示age值 调用addAge方法给对象的age属性增加2岁

- 2. 创建第二个对象 执行上述的操作 体会同一个类的不同对象之间的关系

- 类图
<!-- 
  Person
  name: String
  age: int
  sex: int

  +study():void
  +showAge():void
  +addAge(int i):int
 -->

<!-- 
  package src.com;
  public class PersonTest {
    public static void main(String[] args) {
      Person p1 = new Person();
      p1.name = "Tom";
      p1.age = 16;
      p1.sex = 1;

      p1.study();
      p1.showAge();

      int newAge = p1.addAge(2);
      System.out.println(p1.name + "的新年龄为 " + newAge);
      System.out.println(p1.age);    // 20
            因为addAge这个方法内部修改的就是 age
    }
  }

------

  package src.com;
  public class Person {
    String name;
    int age;

    /**
    * sex: 1 表明是男性
    * sex: 0 表明是女性
    */
    int sex;

    public void study() {
      System.out.println("studying");
    }

    public void showAge() {
      System.out.println("age: " + age);
    }

    public int addAge(int i) {
      return age += i;
    }
  }


  addAge方法中的形参i是局部变量
  所以i定义在栈中 i: 2

  然后addAge方法内部在age中累加了2 那么堆空间的对象实体的age就累加了2
  我们输出 newAge 是输出的 栈中的newAge变量
  我们输出 p1.age 是输出的 堆中的age属性


  ！！！局部变量放在栈
  ！！！属性放在堆
 -->

**注意**
- 当我们没有给age重新赋值的时候 age是有默认值的 int型的age默认值为0
- 不同于我们的js 如果不赋值会值undefined 进行计算的时候会是 NaN
- 但是java中整型是的默认值为0 所以我们即使不赋值 直接进行计算 也会是正确的结果
<!-- 
  一个类调用另一个类的时候吧 要不平时会报错呀
 -->

> 解析上面的问题： 
- 我们在创建数组的时候 int[] arr = new int[6]
- 我们这样是创建了一个int型的动态的数组对象 这时候里面元素虽然没有值 但是有默认值
- 我们可以之后再给动态数组中的元素进行赋值操作

- 类的创建也是一样 都是引用类型的数据 
- class Student {
    int age;
  }

- 我们在类中定义了 非static属性 我们可以在实例化对象之后 通过实例对象给age进行赋值

- 这时候跟动态数组一样 虽然我们age是没有值的但是它有默认值 int型的默认值为0
- 所以可以直接计算 也有一个结果


> 练习2:
- 利用面向对象的编程方法 设计类Circle计算圆的面积
<!-- 
  public class Demo {
    public static void main(String[] agrs) {

      Circle c1 = new Circle();

      c1.radius = 10.0;   // 可以先赋值

      System.out.println(c1.area()); 
          // 到这步的时候直接输出 会是 0.0
          // 因为radius定义了 并没有赋值 默认值为0

    }
  }


  class Circle {
    // 属性  半径作为属性比较好 下面的方法中不要定义形参
    double radius;

    // 求圆的面积
    public double area() {
      return Math.PI * radius * radius;
    }
  }
 -->


> 练习3
- 1. 编写程序 声明一个method方法 在方法中打印一个10 * 8的*矩形 在main方法中调用该方法

- 2. 修改上一个程序 在method方法中 除打印一个10 * 8的*型矩形外 再计算该矩形的面积 并将其作为方法返回值 在main方法中调用该方法 接收返回的面积值并打印

- 3. 修改上一个程序 在method方法提供m 和n两个参数 方法中打印一个m * n的 *型矩形 并计算该矩形的面积 将其作为方法返回值 在main方法中调用该方法 接收返回的面积值并打印

<!-- 
  // 1
  public class Demo {
    public static void main(String[] agrs) {
      Demo d1 = new Demo();
      d1.method();
    }

    
    public void method() {
      for(int i=0; i<10; i++) {
        for(int j=0; j<8; j++) {
          System.out.print("*");
        }
        System.out.println();
      }
    }
  }
 -->

**要点:**
- 在上面我们写类的时候 都是一个public类和一个对象类 然后我们在public类中通过创建对象类的实例的形式 调用对象类中的方法和属性
<!-- 
  // public类
  public class Demo { ... }

  // Test对象类
  class Test { ... }

  ------

  public class Demo {
    Test t1 = new Test();
    ... 
  }
 -->

- 在上面的例子1中 我们在public类中 定义了除了main方法外的 一个method方法
- 但是在main方法中调用method方法的时候 我们在main方法中实例化了public类 创建了实例对象 通过实例对象调用的method方法
<!-- 
  public class Demo {
    public static void main(String[] args) {

      // 实例化 Demo public类对象
      Demo d1 = new Demo();
      d1.method();
    }

    // 在同一个public类中创建了另一个method方法
    public void method() { ... }
  }
 -->


- 2. 
<!-- 
  public class Demo {
    public static void main(String[] agrs) {
      Demo d1 = new Demo();
      int res = d1.method();
      System.out.println(res);
    }

    public int method() {
      for(int i=0; i<10; i++) {
        for(int j=0; j<8; j++) {
          System.out.print("* ");
        }
        System.out.println();
      }
      return 10 * 8;
    }
  }
 -->

- 3. 要点是定义属性也好 还是形参也好 我们都要先确认类型
<!-- 
  public class Demo {
    public static void main(String[] agrs) {
      Demo d1 = new Demo();
      int res = d1.method(8, 8);
      System.out.println(res);
    }

    public int method(int m, int n) {
      for(int i=0; i<m; i++) {
        for(int j=0; j<n; j++) {
          System.out.print("* ");
        }
        System.out.println();
      }
      return m * n;
    }
  }
 -->


> 练习4
- 定义类Student 包含3个属性 学号number int； 年级state int； 成绩score int； 
- 创建20个学生对象 学号1到20 年级和成绩都由随机数确定

- 问题1 打印出3年级state值为3的学生信息
- 问题2 使用冒泡排序按学生成绩排序 并遍历所有学生信息

- 提示
- 1. 生成随机数 math.random 返回值类型double
- 2. 四舍五入取整 math.round(double d) 返回值类型为long
<!-- 

  // 卡壳的地方 
  - 既然创建20个学生对象 那么肯定要用到循环 但是用js的想法 发现写不下去了

  - for(int i=0; i<20; i++) {
        Student 属性名没办法依次指定 = new Student();
    }

  - 解决方法
  - 在java中 我们可以创建 动态对象数组
  - 我们class Student这个类也是一个对象 因为数组的元素包括任何自定义类型 自然也包括我们自定义的class类

  - 上面我们创建字符串类型的数组是这样 String[] str = new String[10]
  - 现在我们创建 类对象(js中的class类在java中好像就是对象)

  - Student[] studs = new Student[20]

      // 这里我们先是创建了一个数组 是什么型的数组呢？
      也就是说数组的元素是什么类型的呢？ 是Student类的一个个对象
      数组本身是引用数据类型的 数据的元素既可以是基本数据类型 又可以是引用数据类型
      这里元素是引用类型 只不过是我们自定义的Student类
      我们的数组中每一项是一个Student类型的



  - 然后我们依然往里输入值

  public class Demo {
  
    public static void main(String[] args) {
      // 声明一个 Student类型 的数组
      Student[] studs = new Student[20];


      for(int i=0; i<studs.length; i++) {
        studs[i] = new Student();
      }
    }

  }

  class Student {
    int number;
    int state;
    int score;
  }
 -->


- 更新上面下一阶段的代码
- 上面说了 我们可以创建动态数组 然后利用循环依次向数组中的元素中追加值

- 然后我们想打印输出下 看看这个类对象数组中都有什么
- 方式1:
- 循环遍历加拼接: 
- System.out.println(studs[i].number + ", " + studs[i].state + ", " + studs[i].score);

- 方式2:
- 既然数组中每一个元素都是一个类对象 那类中就能有自己的方法 studs[i] 就是每一个对象 那么studs[i]就能调用自己的方法
- 在Student类中创建一个方法
- public String info() {
    return "学号: " + number + ", 班级: " + state + ", 成绩: " + score; 
  }
<!-- 
  package src.com;

  public class Demo {
    
    public static void main(String[] args) {
      Student[] studs = new Student[20];

      for(int i=0; i<studs.length; i++) {

        studs[i] = new Student();

        // 给stud对象的属性赋值
        studs[i].number = i + 1;
        // Math.random() * (6-1+1) + 1 是一个double类型的值 该值不能赋值给int
        studs[i].state = (int)(Math.random() * (6-1+1) + 1);
        studs[i].score = (int)(Math.random() * (100-0+1));
      }

      // 遍历学生数组
      for(int i=0; i<studs.length; i++) {
        // 这样会输出地址值
        // System.out.println(studs[i]);
        // System.out.println(studs[i].number + ", " + studs[i].state + ", " + studs[i].score);
        System.out.println(studs[i].info());
      }
    }
  }

  class Student {
    int number;
    int state;
    int score;

    // 显示学生信息的方法
    public String info() {
      return "学号: " + number + ", 班级: " + state + ", 成绩: " + score; 
    }
  }
 -->

- 更新一下最新阶段的代码
- 要点：
- 在给对象做冒泡排序的时候 我们判断的是对象中的属性 但是交换的是对象本身
- 在定义中转变量的时候 我们对象的类型就是new Student的类型
<!-- 
  package src.com;

  public class Demo {
    
    public static void main(String[] args) {
      Student[] studs = new Student[20];

      for(int i=0; i<studs.length; i++) {
        studs[i] = new Student();

        studs[i].number = i + 1;
        studs[i].state = (int)(Math.random() * (6-1+1) + 1);
        studs[i].score = (int)(Math.random() * (100-0+1));
      }

      // 遍历学生数组
      for(int i=0; i<studs.length; i++) {
        if(studs[i].state == 3) {
          System.out.println(studs[i].info());
        }
      }
      System.out.println("**********************");

      // 使用冒泡排序按学生成绩排序 并遍历出所有学生信息
      for(int i=0; i<studs.length-1; i++) {
        for(int j=0; j<studs.length - 1 - i; j++) {
          if(studs[j].score > studs[j+1].score) {

            // 我们交换的不是成绩 而是学生对象的顺序 
            注意这里我们定义变量的类型 因为我们交换的是对象 
            每一个对象都是new Student出来的 
            所以每一个对象的类型都是Student

            Student temp = studs[j];    // 注意

            studs[j] = studs[j+1];
            studs[j+1] = temp;
          }
        }
      }

      // 遍历查看下结果
      for(int i=0; i<studs.length; i++) {
        System.out.println(studs[i].info());
      }
    }
  }

  class Student {
    int number;
    int state;
    int score;

    // 显示学生信息的方法
    public String info() {
      return "学号: " + number + ", 班级: " + state + ", 成绩: " + score; 
    }
  }
 -->

> 对上优化
- 上面我们对数组的遍历 冒泡排序 以及输出指定班级学生信息 都写在了main方法中并没有封装成一个个的方法

- 接下来我们将操作数组的功能封装到一个个的方法中

- 要点：
- 我们在main方法中调用这个类的其它方法时 
- 现阶段需要先根据当前类 先new一个对象 通过实例对象调用除了main方法以外的其它方法
<!-- 
  package src.com;

  public class Demo {
    
    public static void main(String[] args) {
      // 声明一个 Student类型 的数组
      Student[] studs = new Student[20];

      for(int i=0; i<studs.length; i++) {
        studs[i] = new Student();

        // 给stud对象的属性赋值
        studs[i].number = i + 1;
        // Math.random() * (6-1+1) + 1 是一个double类型的值 该值不能赋值给int
        studs[i].state = (int)(Math.random() * (6-1+1) + 1);
        studs[i].score = (int)(Math.random() * (100-0+1));
      }

      // 我们在main方法中调用这个类的其它方法时 现阶段需要先根据当前类 先new一个对象 通过实例对象调用除了main方法以外的其它方法
      Demo d1 = new Demo();
      d1.searchState(studs, 3);
      System.out.println("****************");
      d1.sort(studs);
      d1.showInfo(studs);

    }

    // 遍历Student[]数组的方法
    // 参数： 我们要遍历哪个对象数组
    public void showInfo(Student[] studs) {
      for(int i=0; i<studs.length; i++) {
        System.out.println(studs[i].info());
      }
    }

    /**
    * @Description 查找Student数组中指定年级的学生
    * @author Sam
    * @param studs 要查找的数组
    * @param state 指定的年级
    */
    public void searchState(Student[] studs, int state) {
      for(int i=0; i<studs.length; i++) {
        if(studs[i].state == state) {
          System.out.println(studs[i].info());
        }
      }
    }

    /**
    * @Description 给指定数组进行排序
    * @param studs 给定数组
    */
    public void sort(Student[] studs) {
      for(int i=0; i<studs.length-1; i++) {
        for(int j=0; j<studs.length - 1 - i; j++) {
          if(studs[j].score > studs[j+1].score) {
            Student temp = studs[j];
            studs[j] = studs[j+1];
            studs[j+1] = temp;
          }
        }
      }
    }
  }

  class Student {
    int number;
    int state;
    int score;

    // 显示学生信息的方法
    public String info() {
      return "学号: " + number + ", 班级: " + state + ", 成绩: " + score; 
    }
  }
 -->

- 这样整个代码会看起来干净一些 因为main方法中调用的是一个个的功能



> 练习5
- 声明一个日期类型MyDate 有属性 年 月 日 创建2个日期对象 分别赋值为 你的出生日期 你对象的出生日期 并显示信息
<!-- 
  这个看看资料
 -->


> 练习6
- 面向对象的方法 -- 自定义数组的工具类
- 1. 创建一个 数组工具类的java文件
<!-- 
  package src.com;

  /**
  * 自定义数组的工具类
  */
  public class ArrayUtils {

    // 最大值
    public int getMax(int[] arr) {
      return 0;
    }


    // 最小值
    public int getMin(int[] arr) {
      return 0;
    }

    // 总和
    public int getSum(int[] arr) {
      return 0;
    }

    // 平均值
    public int getAvg(int[] arr) {
      return 0;
    }

    // 反转数组
    public void reverse(int[] arr) { }

    // 复制数组 需要返回值 返回值为新的数组 方法返回值的类型 int[]
    public int[] copy(int[] arr) {
      return null;
    }

    // 数组排序
    public void sort(int[] arr) { }

    // 遍历数组
    public void print(int[] arr) { }

    // 查找指定元素
    public int getIndex(int[] arr, int index) {
      return 0;
    }
  }
 -->

- 2. 在测试类中实例化工具类对象 通过对象调用具体的方法

**要点:**
- 返回值为数组: return null;
- 因为数组是引用类型 所以我们返回值可以设置为null

- 方法的返回值为int[]数组
- public int[] copy(int[] arr) { ... }

----------------------------

### 什么叫做万物皆对象
- 1. 在java语言范畴中 我们都将功能和结构封装到具体的类当中 同过类去实例化对象 通过实例对象去调用功能

- 2. 涉及到java语言与前端html 后端数据库交互时 前后端的结构在java层面交互时 都体现为类 和 对象
<!-- 
  java擅长做后台 后台需要跟前端进行交互 比如前端发情况 后台返数据
  前端发送的请求 后台接收的时候 都会看做一个个类的对象

  <></> 比如这一对标签 在java端进行调用的时候 就会体现为某一个类的对象

  ------

  java还会跟数据库进行交互 数据库中有一个个的表
  表在数据库中也是一个个的数据库对象
  这个表是如何跟java交互的呢？

  java中比如有一个Costom类 数据库中有一个Costom表
  java中就会用这个类去对应这个表

  我们让表中的一条记录对应java类中的一个对象
  表中纵向的一个结构对应java类中对象中的一个属性

  ------
 -->

- 也就是说不管前端还是数据库跟java进行交互的时候 在java里都会体现成一个对象


----------------------------

### 匿名对象
- 我们new类的时候没有创建变量来接收对象 也就是没有显示的赋给一个变量名 其为匿名对象
<!-- 
  Phone p = new Phone();
      // 这就是有名的实例对象 名为p

  new Phone();
      // 这就是 匿名对象
 -->

> 匿名对象的特征
- 只能调用一次(再想调用就是另外一个对象了)
<!-- 
  new Phone().price = 1999;
  new Phone().showPrice();
      // 这两个调用 调用的不是同一对象方法 因为每new一次就是造了一个对象
 -->

- 使用场景举例:
- 当参数传递到形参中

----------------------------

### 面向对象 - 方法: 
- 接下来我们再看看方法的相关知识点
- 1. 方法的重载
- 2. 可变形参的方法
- 3. 方法参数的值传递机制 (重要)
- 4. 递归方法 (理解)


> 1. 方法的重载(overload)
- 在java中同一个类中 允许存在一个以上的同名方法，这些方法之间的关系 我们称之为重载的关系
- 要求它们的*参数个数*或者*参数类型*或*参数顺序*不同即可
<!-- 
  比如Arrays工具类中 有很多同名的方法 方法名相同 参数参数不同
  binarySearch(参数种类1)
  binarySearch(参数种类2)
  binarySearch(参数种类3)
 -->


> 为什么要造这么多同名的方法?
- 我们在起方法名的时候都要求见名知意，比如排序我们会起名字为sort
- 但是我们可能对byte类型的数组排序 也可能对int类型的数组排序 对不同类型的数组排序就需要提供不同的方法 但是sort方法名更加的直观 那我们就起个一样的方法名
- 但是参数列表不一样
<!-- 
  比如我们上面创建的数组的工具类 反转数组
  public void reverse(int[] arr) { ... }
  public void reverse(String[] arr) { ... }

  上面的两个方法都是reverse但是参数列表不一样 它们之间就是方法的重载
 -->

- 那调用的时候 调用的是哪个？
- 调用的时候取决于我们参数的类型 它就会调用对应的方法


> 方法重载的特点
- 与返回值类型无关
- 只看参数列表 且参数列表必须不同(参数个数或参数类型)
- 调用时 根据方法参数列表的不同来区别


> 技巧: 两同一不同
- 满足下面条件的就叫做方法的重载
- 1. 同一个类 同一个方法名
- 2. 参数列表不同
    - 参数个数不同
    - 参数类型不同
<!-- 
  // 参数个数不同
  public void getSum(int[] i) { ... }
  public void getSum(int[] i, int[] j) { ... }

  // 参数类型不同
  public void getSum(int[] i) { ... }
  public void getSum(double[] i) { ... }

  // 参数列表的顺序不同也算方法的重载
  public void getSum(String[] i, int[] j) { ... }
  public void getSum(int[] j, String[] i) { ... }
 -->


**注意:**
- 形参名无所谓的 主要看的是参数列表的类型
<!-- 
  // 这样就不算重载 因为都是参数列表的两个参数的类型都一样 参数名其实无所谓
  public void getSum(int[] i, int[] j) { ... }
  public void getSum(int[] j, int[] i) { ... }
 -->

- 跟方法返回值的类型也没有关系
<!-- 
  // 虽然方法返回值的类型不一样 但是并不是方法的重载
  public void getSum(int[] i, int[] j) { ... }
  public int getSum(int[] i, int[] j) { ... }
 -->

- 跟方法的权限修饰符也没有关系
<!-- 
  public void getSum(int[] i, int[] j) { ... }
  private void getSum(int[] i, int[] j) { ... }
 -->

- 总结:
- 跟方法的权限修饰符 返回值类型 形参变量名 方法体都没有关系


> 调用时候的注意点
> 调用方法时传入参数的类型
- 创建重载方法1 int int
- 创建重载方法2 double double

- 当我们调用的时候 传入的实参如果是int int 那么调用的肯定是 方法1
- 当我们将方法1注释掉 会报错么？ 不会
- 我们传递的实参int会自动提升到 double double 也就是会匹配到 方法2

----------------------------

### 2. 可变个数的形参:
- javaSE5.0中提供了Varargs机制 允许直接定义能和多个实参相匹配的形参
- 从而可以用一种更简单的方式 来传递个数可变的实参
<!-- 
  jdk5.0以前:
  - 采用数组形参定义方法 传入多个同一类型变量
  public static void test(int a, String[] books) { }

  jdk5.0:
  - 采用可变个数形参来定义方法 传入多个同一类型变量
  public static void test(int a, String ... books) { }
 -->


> 可变个数形参的方法
- 它是jdk5.0以后的新特性


> 具体使用:
> 可变个数形参格式
- 数据类型... 形参变量名

- 当调用可变个数形参的方法时 传入的参数个数可以是0个 1个 n个
- 既然是可变个 那就说明我们在传递实参的时候可以是0个 1个 n个
- 跟js中的...args差不多
<!-- 
  // 我们肯定见过这么写 String[] strs 一样的 
  可变个数的形参String... strs

  public void show(String... strs) {
    System.out.println(3 + "String... strs");
  }

  调用:
  d.show("hello", "world");
 -->

- 要求:
- 我们传入的实参类型必须是 指定类型的
<!-- 
  (String... strs)  我们传递的参数类型必须都是String
 -->

- 特点:
- 可变个数形参的方法与本类中方法名相同 形参不同的方法之间构成重载


> 可变形参的2种写法(jdk5.0之前之后)
- 下面的两种写法不构成重载 它们二者不能共存
<!-- 
  // 编译器认为下面的两种方法都是在定义可变个数的形参方法
  public void show(String... strs) { }
  public void show(String[] strs) { }
 -->


> 方法1 jdk5.0之前
- 现在也可以使用 但是传入实参 和 方法内部使用数组中的参数的时候有一些麻烦
- public void show(String[] strs) { }

- 调用:
- 我们在调用方法传入实参的时候 需要传入一个数组
- test.show(new String[] {"hello", "world"})

- 方法内使用形参:
- 通过遍历的方式获取实参数组中的元素
<!-- 
  for(int i=0; i<strs.length; i++) { ... }
 -->


 > 方法2 jdk5.0之后
 - 可变个数形参 String... strs
 - public void show(String... strs) { }

- 调用:
- 跟js中的 ...args 一样 我们在传入实参的时候 直接写就可以
- test.show("hello", "world")

- 方法内使用形参:
- 通过遍历的方式获取实参数组中的元素 (String... strs) 就相当于是一个数组


> 可变个数形参 只能声明在末尾且只能写一个可变个数形参结构
- 跟js的...args一样
- public void show(int a, String... strs) { }
  
----------------------------

### 3. 方法参数的值传递机制

> 回顾: 关于变量的赋值
- 对于基本数据类型来讲 int n = m 实际上就是将m存的数据给了n 
- 这时候内存中 10 是有两份的
<!-- 
  // 基本数据类型的举例
  public static void main(String[] args) {
    
    int m = 10;
    int n = m;
    System.out.println("m = " + m + ", n: " + n);

    // 当我们把n改为20的时候 m是多少 因为是值传递 所以不会影响到 m
    n = 20;
    System.out.println("m = " + m + ", n: " + n);
  }

  栈: 因为是局部变量

  ----------
  n: 10  ->  n: 20
  m: 10
  ----------
 -->


- js中我们创建对象的方式:
- 1. let obj = new Object();
- 2. let obj = {name: "sam"}
- 有上述的两种方式创建一个普通的对象

- java中是面向对象的编程方式 在创建对象的时候就是创建一个类 添加属性 就是在类的内部添加成员属性 添加方法就是在类的内部添加成员方法
- class Order { orderId: 1001 }
- Order o = new Order();
<!-- 
  // 引用数据类型的举例
  public class Demo {

    public static void main(String[] args) {
      
      Order o1 = new Order();
      o1.orderId = 1001;

      // 引用数据类型的时候 我们传递的是地址值 这样 o1 o2 都指向了同一个对象实体
      Order o2 = o1;
      System.out.println("o1.orderId = " + o1.orderId + ", o2.orderId: " + o2.orderId);

      // 因为指向了同一个对象实体 所以通过一个对象修改属性会影响到另一个对象
      o2.orderId = 1002;
      System.out.println("o1.orderId = " + o1.orderId + ", o2.orderId: " + o2.orderId);
    }
  }

  // 创建一个对象(java中就是创建一个类)
  class Order {
    int orderId;
  }
 -->

> 变量是基本数据类型:
- 此时赋值的是变量所保存的数据值。

> 变量是引用数据类型
- 此时赋值的是变量所保存的数据的地址值。

------

> 方法形参的传递机制 -- 值传递
- 其实和上面的规律是一样 我们从形参的角度看看怎么去理解

> 形参
- 方法定义时 声明的小括号内的参数

> 实参
- 方法调用时 实际传递给形参的数据


> java的实参值如何传入方法呢？
- java里方法的参数传递方式只有一种： *值传递*
- 即将实际参数值的副本(复制品)传入方法内 而参数本身不受影响

- 形参是基本数据类型:
  实参传递给形参的就是 实参真实存储的数据值(copy)
  *可能就会导致方法内有一份 方法外有一份 两份数据互不干扰 造成方法内爱怎么玩怎么玩不会对方法外的数据造成影响*
<!-- 
  这里我们说个例子
  我们交换两个变量的位置的时候 会写这样的逻辑 

      int temp = m;
      m = n;
      n = temp;

  因为交换两个变量的位置在很多地方都会使用我们能不能将其封装成一个方法?
  然后在合适的位置进行调用
      public void swap(int m, int n) {
        int temp = m;
        m = n;
        n = temp;
      }

  
  结果发现不行 我们输出的结果还是未交换之前的
  int m = 10;
  int n = 20;
  System.out.println("m: " + m + ", n: " + n);   // m:10 n: 20

  // 调用了方法变量也没有交换
  swap(m, n);
  System.out.println("m: " + m + ", n: " + n);   // m:10 n: 20


  // 原因:
  - 当数据为普通数据类型的时候我们传递到形参中的仅是数据
  - 我们调用swap方法交换的方法内部的两个形参局部变量的值


  // 我们看看内存解析
  - 1. 所有main方法中 定义了 int m = 10， int n = 20
       那我们就在栈中创建两个变量

  栈
  ------
  m:10  main方法中定义的
  n:20  main方法中定义的

  - 2. 调用 swap(m, n)
  接下来我们调用了swap方法将上面m n的值copy给形参m n
  因为形参也是局部变量所以还要在栈中再次创建 m n

  m: 10 swap方法中形参m
  n: 20 swap方法中形参n

  temp  swap方法中的局部变量

  也就是说我们调用swap后 是将swap方法里面的形参 m n 变量交换了位置


  当swap方法执行完毕后 swap内部的形参会被销毁出栈 我们再打印m n的时候打印的是main方法放到栈中的m n
-->

- 形参是引用数据类型: 
  将实参引用数据类型变量的 "地址值"传递给形参
<!-- 
  package src.com;
  public class Demo {

    public static void main(String[] args) {

      // 3. 将Data类实例化对象
      Data data = new Data();
      data.m = 10;
      data.n = 20;
      System.out.println("data.m: " + data.m + ", data.n: " + data.n);
      
      // 4. 实例化Demo类调用swap方法
      Demo d = new Demo();
      d.swap(data);
      System.out.println("data.m: " + data.m + ", data.n: " + data.n);
    }

    // 2. 交换两个变量值的方法 参数为Data类 类型
    public void swap(Data data) {
      int temp = data.m;
      data.m = data.n;
      data.n = temp;
    }
  }

  // 1. 我们要创建一个对象
  class Data {
    int m;
    int n;
  }

  因为基本数据类型的时候 我们传递到形参的值为copy的原始值
  我们现在形参的位置是一个对象 它跟形参保存的都是地址值 都指向堆空间中的一个对象实体

  栈                   堆
  ------              ------
  data: 0x7788 形参

  data: 0x7788 main中new Data

                      0x7788

                      m: 0  - 10
                      n: 0  - 20

  然后我们调用 swap(data) 将data传递进去 data是引用数据类型
  保存的是地址值 0x7788

  现在通过地址值都指向堆空间中的数据m n 所以交换的也是堆空间中的m n
 -->


<!-- 
  // 这是一个封装好的排序方法
  public void sort(int[] arr) {
    for(int i=0; i<arr.length-1; i++) {
      for(int j=0; j<arr.length - 1 - i; j++) {
        if(arr[j] > arr[j+1]) {
          
          // 我们把这个部分逻辑也封装成一个方法
          int temp = arr[j];
          arr[j] = arr[j+1];
          arr[j+1] = temp

          // 如果这么传递值的话 还是会跟上面的情况一样 
          我们把arr[j], arr[j+1]对应的值copy给了形参 它们还是会在方法内部自己干自己的
          swap(arr[j], arr[j+1])


          // 正确的方法
          swap(arr, j, j+1)
        } 
      }
    }
  } 

  // 这里我们也是将 交换两个变量 的逻辑封装成了一个方法
  在形参为基本数据类型的时候 我们使用swap方法未成功 那在这里可以么？


  // 这样定义形参传递进来的值是基本数据类型 所以不行
  public void swap(int i, int j) {
    int temp = i;
    i = j;
    j = temp
  }

  // 我们把引用类型的数组传递进来 这里的int i j不是元素 而是索引位置
  public void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp
  }
  
 -->


> 练习： 网红题
- 定义一个int型的数组
- int[] arr = new int[]{12, 3, 3, 34, 56, 77, 432}
- 让数组的每个位置上的值去除以首位置的元素 得到的结果 作为该位置上的新值 遍历新的数组

<!-- 
  // 错误的答案
  for(int i=0; i<arr.length; i++) {
    arr[i] = arr[i] / arr[0]
  }

  当i=0的时候 12 = 12 / 12 = 1
  因为首位置已经是1了 所以

  当i=1的时候 3 = 3 / 1 = 3     因为上面arr[0]的位置已经被改成1了
  所以上面的答案不对
 -->

<!-- 
  // 正确答案
  for(int=arr.length - 1; i>=0; i--;) {
    arr[i] = arr[i] / arr[0]
  }

  // 我们倒着来 保证第一个元素的值始终为12
 -->

<!--  
  // 正确方法2
  int temp = arr[0]
  for(int i=0; i<arr.length; i++) {
    arr[i] = arr[i] / temp
  }

  // 我们将数组中第一个元素保存到外面 让它的值不变
 -->


> 练习2：
- 下面的代码分别输出什么？
<!-- 
  int[] arr = new int[] {1,2,3};
  System.out.println(arr);    // [I@626b2d4a


  char[] arr1 = new char[] {'a','b','c'};
  System.out.println(arr1);   // abc
 -->

- 第一个int型   是地址值
- 当我们传入的是int[]数组的时候 会调用重载方法 println(Object)

- 第二个char型  是abc
- 当我们传入的是char[]数组的时候 会调用重载方法 println(char[])
- 该方法体内部的逻辑是遍历 char型数组的


> 练习3：
- 1. 
- 定义一个Circle类 包含一个double型的radius属性代表圆的半径
- 一个findArea()方法返回圆的面积

- 2. 
- 定义一个类PassObject 在类中定义一个方法printAreas() 该方法的定义如下
- public void printAreas(Circle c, int time)
- 在printAreas方法中打印输出1到time之间的每个整数半径值 以及对应的面积
- 例如：
- times为5 则输出半径 1 2 3 4 5 以及对应的圆面积

- 3. 
- 在main方法中调用printAreas()方法 调用完毕后输出当前半径值
- 程序运行结果如下
<!-- 
  Radius        Area
  1.0           3.14...
  2.0           12.56...
  3.0           28.27...
  4.0           50.26...
  5.0           78.53...
 -->

<!-- 
  package src.com;
  public class Circle {
    double radius;

    // 求圆的面积 不用有形参 直接用对象中的radius
    public double findArea() {
      return radius * radius * Math.PI;
    }
  }
 -->

<!-- 
  package src.com;
  public class PassObject {

    public static void main(String[] args) {

      PassObject test = new PassObject();
      Circle c = new Circle();
      test.printAreas(c, 5);
    }

    public void printAreas(Circle c, int time) {
      System.out.println("Radius\t\tAreas");
      for(int i=1; i<=time; i++) {
        c.radius = i;
        System.out.println(c.radius + "\t\t" + c.findArea());
      }
    }
  }
 -->

----------------------------

### 4. 递归方法
- 一个方法体内调用它自身
- 方法递归包含了一个隐式的循环 它会重复执行某段代码 但这种重复执行无须循环控制
<!-- 
  方法在运行的时候调用了自己就是递归
  def f(x)
    if x > 0
      return x + f(x-1)
    else 
      return 0    // 终止条件

    参数x的值     函数的返回值
    x = 3        3 + f(2)

        参数x的值     函数的返回值
        x = 2        2 + f(1)

            参数x的值     函数的返回值
            x = 1        1 + f(0)

    其中 f(x-1) 就相当于 i-- 当x为0的时候 就终止

  结果：
    f(3) = 3 + f(2)
         = 3 + 2 + f(1)
         = 3 + 2 + 1 + f(0)
         = 3 + 2 + 1 + 0
 -->


> 技巧: x + f(x-1)
- 先记住 这种写法就是求n之前的累计数 累计数不光光是相加还有相乘


**注意：**
- 递归一定要向已知方法递归 否则这种递归就变成了无穷递归 类似于死循环
<!-- 
  在程序运行的时候是有代价的 要占用一片栈的内存空间 当调用函数时 都必须要放一些数据到栈里

  当函数运行结束时 这些数据会从栈中弹出
  可是 如果调用了很多函数但是这些函数都不返回 栈就被塞满了 数据没地方放了 就是栈溢出
 -->


> 练习：
- 计算1-100之间所有自然数的和
<!-- 
  public void sum(int num) {
    if(num == 1) {
      return 1 
    } else {
      return num + sum(num - 1);
    }
  }
 -->

- 数组中的快排 排序 内部用的就是递归方法


> 练习2
- 已知有一个数列
- f(0) = 1
- f(1) = 4
- f(n+2) = 2 * f(n+1) + f(n)
- 其中n是大于0的整数 求f(10)的值
<!-- 
  public int f(int n) {
    if(n == 0) {
      return 1;
    } else if(n == 1) {
      return 4;
    } else {
      return 2 * f(n - 1) + f(n - 2);
    }
  }
 -->

----------------------------

### 面向对象特征之一: 封装与隐藏(封装性)
- 面向对象的三大特点: 封装 继承 多态
- 为什么需要封装？ 封装的作用和含义？
<!-- 
  我要用洗衣机 只需要按一下开关和洗涤模式就可以了
  有必要了解洗衣机内部的结构么？ 有必要碰电动机么？
 -->

- 程序设计追求"高内聚 低耦合"
- 高内聚：
- 类的内部数据操作细节自己完成 不允许外部干涉
<!-- 
  简单的说就是封装起来了
 -->

- 低耦合：
- 仅对外暴露少量的方法用于使用

- 隐藏对象内部的复杂性 只对外公开简单的接口(API)
- 便于外界调用 从而提供系统的可扩展性 可维护性 
- 通俗的说 *把该隐藏的隐藏起来 该暴露的暴露出来 这就是封装性的设计思想*


> 为什么要对属性进行封装和隐藏
- 当我们创建一个类的对象以后 我们可以通过"对象.属性"的方式 对对象的属性进行赋值
- 这里赋值操作要收到属性数据类型和存储范围的制约(int型的变量不能被赋double)
- 但是除此之外没有其它制约条件 但是在实际问题中 我们往往需要给属性赋值加入额外的限制条件 这个条件就不能在属性声明体现

- 我们只能通过方法进行限制条件的添加(比如下面例子中的setLegs方法) 
- 同时我们需要避免用户再通过"对象.属性"的方式 对对象的属性进行赋值 则需要将属性声明为私有的(private)

- 此时 针对于属性就体现了封装性

> 举例
- 我们举一个简单的例子
- 我们创建一个 Animal类 然后在Demo类中 设置Animal类中的属性
- legs 一个动物 腿的数量肯定是正数 但是由于我们实例化对象后 可以通过 a.legs 的方式给legs属性 赋任意值 
- 这时候我们就需要对 legs属性进行限制 同时还需要将 a.legs 的方式进行隐藏
- 我们利用对外提供设置属性的方法的形式 和 使用 private 关键字将legs属性私有化
<!-- 
  // Demo类
  public class Demo {

    public static void main(String[] args) {

      // 实例化 Animal类 
      Animal a = new Animal();
      a.name = "花花";
      a.age = 1;

      - 腿是不能有负数的 也就是我们在给属性赋值的时候 是会有一些限制 
      - 比如输入姓名的时候 姓名的长度不能太短等

      - 那怎么才能在我们赋值的时候对我们赋值进行一些限制呢？ 
      - 比如只能赋值为正数 那我们只能通过方法了 
      - 我们可以在Animal类中创建一个专门给legs属性赋值的方法

      // 调用对外暴露的 setLegs 方法
      - 因为不满足条件 legs属性 走else逻辑 设置为0 不让它赋值负数 或者 不是偶数的情况
      a.setLegs(5);
      a.show();

      - 现在我们确实可以使用 setLegs方法去给legs属性来赋值 
      - 但是我们是不是还可以直接写 a.legs = -4; 这样的逻辑 
      - 那就还避免不了用户去写 还是避免不了出现负数的情况

      - 所以除了我们设置一个可以设置legs的方法 
      - 还需要将 a.legs = -4; 这样的逻辑禁掉 不让用户通过这样的方式去修改legs属性

      - 所以一方面我们提供一个方法 通过方法里面对legs属性进行限制条件给legs属性赋值 同时还要将直接调属性的方式禁掉 

      - 我们使用 private权限修饰符 将legs属性声明为 私有的 
      - 这样别的类中再调用legs属性就会报错了

      - 以上我们就完成了对legs属性的封装
      - Animal类中有这个属性但是外部还不能调用

      - 我们的类就像一个盒子一样 我们在内部定义属性legs 
      - 这个属性存在这个类当中 我们在legs属性前面加上private后 
      - 外部就不能调用了 你要是想修改legs属性 我给你提供了一个口(方法 or 接口) 
      - 这就是一个封装 或者说是 隐藏 使得外部不能直接看到它
    }
  }


  // Animal类
  class Animal {
    String name;
    int age;

    // 对属性进行私有化 封装
    private int legs;

    public void eat() {
      System.out.println("进食");
    }

    public void show() {
      System.out.println("name: " + name + ", age: " + age + ", legs: " + legs);
    }

    // 这个方法就是专门给legs属性赋值的方法 对外暴露修改属性的方法
    public void setLegs(int l) {
      if(l >= 0 && l % 2 == 0) {
        // 满足上述条件才允许赋值
        legs = l;
      } else {
        legs = 0;
        // 可以在这部分的逻辑里面 抛出一个异常
      }
    }
  }
 -->


> 封装性的体现
- 我们将类的属性私有化(private) 同时提供公共(public)的方法来获取和设置此属性的值
- 这只是封装性的体现 但是不等同于封装性 只是封装性中的一个点
<!-- 
  // 这个方法就是专门给legs属性赋值的方法
  public void setLegs(int l) {
    if(l >= 0 && l % 2 == 0) {
      // 满足上述条件才允许赋值
      legs = l;
    } else {
      legs = 0;
      // 可以在这部分的逻辑里面 抛出一个异常
    }
  }

  // 设置 读取legs属性的方法
  public int getLegs() {
    // return 当前实例对象的legs属性
    return legs;
  }

  // 要点:
  - getLegs方法中 我以为要 return this.legs
  - 没想到直接的 return legs 就可以 
  - 因为谁调用这个方法 就会打印对应的堆空间的对象实体中的legs属性的值
 -->

- 这就是属性的封装性的体现 我们不让用户去调私有化的属性 而是通过set 和 get方法完成这样的操作

- 封装性的体现很多
- 1. 私有化属性(上面的例子)
- 2. 不对外暴露的私有的方法
- 3. 单例模式 ...
<!-- 
  单例模式是指将构造器私有化 构造器是用来造对象的
  如果将构造器私有化了就意味着外面就不能随意调用构造器了 

  单例模式就是单独的一个实例
 -->

- 4. 如果不希望类在包外被调用 可以将类设置为缺省的
<!-- 
  只要是使用了4种权限修饰符的 都是封装性的体现
 -->


> 四种权限修饰的理解
- 封装性的体现需要权限修饰符的配合 封装性之所有能够体现出来就是因为我们设置了权限修饰符

- java规定了4中权限(从小到大排列) 属性和方法在调用的时候能不能调 完全看权限
- private < 缺省 < protected < public
<!-- 
  缺省是什么也不写也是一种权限

  String name;
    // 这时候就是缺省的权限
 -->

- java权限修饰符置于类的成员定义前 用来限定对象对该类成员的访问权限
<!-- 
    修饰符      类内部    同一个包    不同包的子类    同一个工程

    private     yes

    缺省        yes        yes

    protected  yes        yes       yes

    public     yes        yes       yes         yes


    对于class的权限修饰只可以用public和缺省
    - pubic类可以在任意地方被访问
    - 缺省类只可以被同一个包内部的类方法


    // 扩展:
    - 在同一个包下不能造相同文件名的类 但是不同包里是可以造相同文件名的类的
 -->

> private
- 在哪声明的就在哪用 类就是最小的
- 只能用于该类内部

> 缺省
- 能用于类内部 和 同一个包内(别的包就不能用)

> protected
- 能用于类内部 和 同一个包内 和 不同包的子类
<!-- 
  不同包的子类 涉及到继承 后面再说
 -->

> public
- 任何地方都能用(类内部 同一个包 不同包的子类 同一个工程)


> 4种权限可以用来修饰什么？
- 可以用来修饰类 以及 类的内部结构(属性 方法 构造器 内部类)
- 4种权限都可以用来修饰类的内部结构

**注意**
- 修饰一个类的时候只能使用 public 或者 缺省(什么也不写)

<!-- 
  package com;

  public class Order {
    private int orderPrivate;
    int orderDefault;
    public int orderPublic;

    private void methodPrivate() {
      orderPrivate = 1;
      orderDefault = 2;
      orderPublic = 3;
    }

    void methodDefault() {
      orderPrivate = 1;
      orderDefault = 2;
      orderPublic = 3;
    }

    public void methodPublic() {
      orderPrivate = 1;
      orderDefault = 2;
      orderPublic = 3;
    }
  }


  public class OrderTest {
  public static void main(String[] args) {

    // 创建 我们要使用属性的类的对象
    Order order = new Order();

    order.orderDefault = 1;
    order.orderPublic = 2;
    // order.orderPrivate = 3;    报错 .不出来这个属性

    - The field Order.orderPrivate is not visible
    - 出了Order后 私有的属性就不可以被调用 方法也一样 private的方法是调用不了的
  }
}
 -->

- 同包下:
- 出了Order类后 私有的属性就不可以被调用 方法也一样 private的方法是调用不了的

- 不同包下:
- 出了Order类所属的包之后 私有的结构 缺省声明的结构就不可以调用了


> 总结:
- java提供了4种权限修饰符来修饰类以及类的内部结构 体现类以及类的内部结构在被调用时可见性的大小


> 练习：
- 编码习惯:
- 一般情况下 都是一个源文件当中写一个类

\\ 类图
<!-- 
  Person
  ------
  -age:int        // -号就是私有化的意思
  ------
  +setAge(i:int)  // +号是public
  +getAge():int   // ():int 方法的返回值类型
 -->


- 要点:
- throw new RuntimeException("")
<!-- 
  package src.com;

  public class Person {
    private int age;

    public void setAge(int a) {

      // 方式1：
      if(a > 0 && a < 130) {
        age = a;
      } else {
        System.out.println("您输入的年龄不合法请输入0~130之间的整数");
        age = 1;
      }

      // 方式2： 抛出异常
      if(a < 0 || a > 130) {
        throw new RuntimeException("传入的数据非法！");
      } else {
        age = a;
      } 

      // 方式3： return
      if(a < 0 || a > 130) {
        System.out.println("您输入的年龄不合法请输入0~130之间的整数");
        return;
      }

      age = a;
    }

    public int getAge() {
      return age;
    }
  }

 -->

----------------------------

### 类的成员之三: 构造器(或构造方法)
- 上面我们讲了类的成员 属性和方法 这个部分我们来讲下构造器
- 任何一个类都有构造器 比较重要哦

> 构造器的作用: 创建对象
- 作用：
- 创建对象

- 说明：
- 如果没有显式的定义类的构造器的话 则系统默认提供一个空参的构造器
<!-- 
  之前我们要调用 Person类中的结构都是 Person p = new Person();
  我们用上面的命令来创建对象 

  那我们上面又说 构造器的作用是创建对象 那和 new Person() 有什么关系
  其实 new Person() == new + 构造器
 -->


> 定义构造器的格式
- 权限修饰符 类名(形参列表) { 构造器的体 }

- 功能：
- 构造器长的很想方法 但它和方法的功能不一样 一般方法都是通过对象去调用 而构造器主要的功能就是用来造对象的
<!--  
  class Person {
    // 属性
    String name;
    int age;

    // 构造器 --- 最简单的构造器
    public Person() {

    }
        - 之前没写构造器的时候 我们在new Person() 的时候 其实就是调用的这个 当没显式的写出得时候 系统会添加一个默认得


    // 方法
    public void eat() {
      System.out.println("人吃饭");
    }
  }
 -->

- 如果我们没有显式的定义构造器 那么系统会自动添加默认得构造器
- 默认得构造器的权限 和 类的权限一致 如果类的权限是public 那么构造器的权限也是public 如何类没有权限属于缺省权限 那么构造器的权限也是缺省权限


> 构造器的作用2: 创建对象的同时给对象属性做初始化
- 构造器的作用除了可以创建对象 还跟js中的constructor功能一样 可以用来在实例化对象的时候通过传递实参动态的进行初始化值

- js中: 
<!-- 
  class Person {
    constructor(name) {
      this.name = name
    }
  }

  const p = new Person("刘德华")
 -->

- java: 
- 构造器可以在类中定义多个, 构造器的名都是Person 那么区别就是形参不同
- 所以一个类中多个构造器构成重载
<!-- 
  public class Person {
    
    String name;

    // 一个类中构造器可以有多个
    public Person() { }

    // 我们可以利用构造器 初始化当前类的属性
    public Person(String n) {
      // 通过实参传递进来的数据 赋值给了类中的 name 属性
      name = n;
    }
  }

  Person p = new Person("张学友")
 -->

- 和js一样 在构造器中的逻辑会在实例化对象的时候自动执行 不仅可以在构造器中对属性进行初始化 还可以自动执行一些逻辑
<!-- 
  比如 一出生就必须先洗澡 我们就可以在 人 的构造器中加入完成 洗澡 的代码
  于是每个 人 一出生就会自动完成 洗澡

  程序就不必再在每个人刚出生的时候一个个地告诉他们要 洗澡 了

  // 构造器
  public Person(String n, int a) {
    name = n;
    age = a;
    System.out.println("我要洗澡了");
  }
 -->


**注意**
- 一旦我们显式的定义了类的构造器之后 系统就不在提供默认得空参构造器
- 一个类中至少有一个构造器（不是默认的 就是我们显式定义的）
- 构造器中没有返回值


> 练习:
- 在前面定义的Person类中添加构造器 利用构造器设置所有人的age属性 初始值都为18
<!-- 
  package src.com;
  public class PersonTest {
    public static void main(String[] args) {
      
      Person p = new Person();
      int res = p.getAge();
      System.out.println(res);
    }
  }

  class Person {
    
    String name;
    int age;

    // 构造器 权限修饰符 类型(形参列表) {方法体}
    public Person() {
      age = 18;
    }

    public int getAge() {
      return age;
    }
  }
 -->

- 修改上题中类和构造器 增加name属性 使得每次创建Person对象的同时初始化对象的age属性值 和 name属性值
<!-- 
  package src.com;
  public class PersonTest {
    public static void main(String[] args) {
      
      Person p = new Person("sam", 18);
      int age = p.getAge();
      String name = p.getName();
      System.out.println(age);
      System.out.println(name);

    }
  }

  class Person {
    
    String name; 
    int age;

    public Person(String n, int a) {
      age = a;
      name = n;
    }

    public int getAge() {
      return age;
    }

    public String getName() {
      return name;
    }
  }
 -->


> 练习2
- 编写两个类 TriAngle 和 TriAngleTest 其中TriAngle类中声明私有的底边长base和高height

- 同时声明公共方法访问私有变量 此外提供类必要的构造器 另一个类中使用这些公共方法 计算三角形的面积
<!-- 
  package src.com;

  public class PersonTest {
    public static void main(String[] args) {
      
      Person p = new Person(10, 30);
    }
  }

  class Person {
    
    // 底边长
    private int base;
    // 高
    private int height;

    // 还可以提供set方法
    public int getBase() {
      return base;
    }
    // 还可以提供set方法
    public int getHeight() {
      return height;
    }

    // 一般在真实开发中 都习惯的提供一个空参的构造器
    public Person() { }

    public Person(int b, int h) {
      base = b;
      height = h;

      // 该逻辑会在实例化对象的时候自动调用
      System.out.println("给定三角形的面积为: " + (b * h) / 2);
    }
  }
 -->


> 总结:
- 1. 在开发中习惯的把类中的属性进行私有化 体现封装性
<!--  
  一般读属性的时候的时候其实都是在掉方法
 -->

- 2. 在开发中习惯先提供一个空参的构造器
<!-- 
  为了方便以后使用 反射 来造对象 反射喜欢调用空参的构造器
 -->


> 总结属性的赋值过程(先后顺序问题)
- 现在有很多地方都可以给属性进行赋值操作
- 1. 默认初始化值 int age;      // int型的默认初始化值为0
- 2. 显示初始化值 int age = 1;  // 显式初始化值
- 3. 构造器中赋值
- 4. 通过对象.set方法 或 对象.属性

- 上面赋值操作的先后顺序是 1 - 2 - 3 - 4 (后面的会覆盖前面的)
- 1 2 3只会执行一次所以叫做初始化 4可以反复执行

----------------------------

### JavaBean(后续到web的时候可以有更好的理解)
- 我们会在javaweb中体会到JavaBean的概念

- JavaBean是一种Java语言写成的可重用组件

- 所谓JavaBean 是指符合如下标准的Java类
- 1. 类是公共的
- 2. 有一个无参的公共的构造器
- 3. 有属性(私有属性)， 且有对应的get set方法


- 用户可以使用JavaBean将功能 处理 值 数据库访问和其他任何可以用Java代码创造的对象进行打包

- 并且其他的开发者可以通过内部的JSP页面 Servlet 其他JavaBean applet程序或者应用 来使用这些对象

- 用户可以认为JavaBean提供了一种随时随地的赋值和粘贴的功能 而不用关心任何改变

----------------------------

### UML类图

<!-- 
  banking             包名
  ----------------------
         Account      类型
  ----------------------
  -balance: double    前面是属性后 后面是属性的类型
  ----------------------
  +Account(int balance: double)     
                     若方法有下划线表示为构造器

 -->


> + 表示 public 类型
> - 表示 private 类型
> # 表示 protected 类型


> 方法的写法:
- 方法的类型(+ -)
- 方法名(参数名: 参数类型): 方法返回值类型

----------------------------

### this关键字的使用
- 在Java中 this关键字比较难理解 它的作用和其词义很接近
    - 它在方法内部使用 即这个方法所属对象的引用
    - 它在构造器内部使用 表示该构造器正在初始化的对象

- this表示当前对象 可以调用类的属性 方法和构造器

- 什么时候使用this关键字呢？
- 当在方法内需要用到调用该方法的对象时 就用this

- 具体的 我们可以用this来区分局部变量和属性
- 比如 this.name = name;

- 举例:
<!-- 
  class Person {

    private String name;
    private int age;

    // 之前 A
    public void setName(String n) {
      name = n;
    }


    // 之后 B
    public void setName(String name) {
      name = name;
    }
  }

  我们简单的定义一个类 并且将属性私有化 对外提供修改和读取属性的方法
  之前我们都是像上述 A 那样定义的

  但是都说形参要见名知意 所以我们将形参定义为name 那么就会有 
    name = name
  的样子 虽然编译不报错但是系统会把这两个name都认为是形参的name
  
  这时我们在name属性的前面加上 this
    this.name = name
  
  this可以理解为当前对象 可以用. .点出来的不是属性就是方法
  所以 this.name 前面的name就是属性 后面的形参name就是局部变量
 -->

- 之后我们再方法中给属性 通过形参给属性赋值的时候 都要使用 this.name = name 的形式(之前形参名和属性名没有重名 所以没有在属性前加this)


> this的使用
- 1. this可以用来修饰属性 方法 和 构造器
<!-- 
  // 构造器
  public Person(String name) {
    this.name = name;
  }
 -->

- 2. this理解为当前对象 也可以理解为实例化后的对象
<!-- 
  public void setName(String name) {
    // 给实例对象的身上的name属性赋值为形参name
    this.name = name;
  }

  Person p = new Person();
  p.setName("sam")

  // this就是对象p
 -->

- 3. 在类的方法中 可以使用 this.属性 或 this.方法的方式 调用当前对象的属性和方法 但是通常情况下 我们都选择省略 "this."
<!-- 
  之前我们在封装性的体现中 会定义 getAge 的方法 方法内会return age
  其实我们就是省略了this.

  public void getAge() {
    return age;       // 之前都是这么直接return的
    return this.age;  // 其实相当于省略了 this.
  }
 -->
- 特殊情况下 如果方法的形参和类的属性同名时 我们必须显式的使用this.变量的方式表明此变量是属性而非形参


**思考:**
- 跟js差不太多


> this 调用构造器  -- this(形参列表)
- 要点:
- 1. 我们在类的构造器中 可以显式的使用 'this(形参列表)' 方式 调用本类中指定的其他构造器
<!-- 
  情景:
    - 很多情况下 我们在对类进行初始化的时候 我会执行一些默认得逻辑
    - 比如属性的赋值 和 初始化节点等 这时候我们就会在构造器中执行很多的逻辑

    - Java中一个类中可以声明多个构造器(构造器的重载主要以形参列表来区分)
    - 所以当对象实例化 new Person(形参列表) 指定构造器的时候 都需要初始化一段逻辑

    - 所以就会要求 类中的每一个构造器中都要有 初始化的逻辑 但相同的代码都写在多个构造器里面的话 会造成代码的冗余

    - 解决方式1：
        在类中定义方法 然后在构造器中调用方法

    - 解决方式2
        在类中调用写好逻辑的其它构造器

  // 比如我们当前有一个Person类
  class Person {

    // 属性
    private String name;
    private int age;

    // 空参构造器
    public Person() {
      String info = "Person在初始化时 需要考虑如下的 1 2 3 4 ... (共40行代码)";

      System.out.println(info);
    }
    
    public Person(int age) {

      // 调用空参构造器
      this();
      this.age = age;
    }

    // 这是有参数的构造器
    public Person(String name, int age) {

      // 根据形参类型调用指定的构造器 调用上面的构造器
      this(age);

    }
  }
 -->

- 2. 构造器中不能通过 this(形参列表) 调用自己(只能调用其它的构造器) 
<!-- 
  构造器调用的时候不管 内部连续调用了几个构造器 创建的对象只是一个
  只是借用了其它构造器内部的逻辑而已
 -->

- 3. 如果一个类中有n个构造器 则最多有n - 1个构造器可以使用 this(形参列表)
<!-- 
           →
      ↗         ↘
    构造器1    构造器2      构造器3      构造器4
      ↖         ↙
           ←

  构造器1 能调用 构造器2 但是构造器2 不能再调用构造器1 不能成为一个环
  这样就是死循环

  构造器1能调用构造器2 构造器2能调用构造器3 构造器3能够调用构造器4
  但是 构造器4不能调用其它的任何的构造器 调用谁都是死循环

  所以一个类中有n个构造器 则最多有n - 1个构造器可以使用 this(形参列表)
 -->

- 4. 规定: this(形参列表) 必须声明在当前构造器的首行
<!-- 
  类似supper的写法 先指明要调用哪个构造器 然后再写自己的逻辑 
-->

- 5. 构造器内部最多只能声明一个 this(形参列表) 这种方式 用于调用其它的构造器

- 应用场景:
- 当A构造器中已经有现成的逻辑的时候 就不要在B构造器中再次的书写 可以使用 this()的方式调用A构造器


> 练习:
- 记入要点:
- 1. 
<!-- 
  // 当前属于 Girl 类中的方法 该方法需要传入 Boy类的对象
  public void marry(Boy boy) {
    System.out.println("我想嫁给" + boy.getName());

    // 传入Boy类的实例对象后 调用Boy类的marry方法 传入girl对象
    boy.marry(this)

    - 这里我们传入 this this就是当前的对象 谁调用这个方法当前对象就是谁
    - 既然boy.marry需要传入girl对象 我们就可以传入this
  }
 -->


- 2. 比较两个对象的大小 会使用 compare方法
- public int compare(Girl girl) { }

- 注意:
- 该方法的返回值是 int型
- 如果返回值为正数 则代表 -- 当前对象大
- 如果返回值为负数 则代表 -- 当前对象小
- 如果返回值为0   则代表 -- 当前对象 和 形参对象 相等
<!-- 
  public int compare(Girl girl) {
    if(this.age > girl.age) { 
      return 1;
    } else if(this.age < girl.age) {
      return -1;
    } else {
      return 0;
    }

    // 简化
    return this.age - girl.age; 
        // 如果this.age大那么就是正数 否则就是负数 或 0
  }
 -->

----------------------------

### 实验1： Account Customer
- 写一个名为Account的类模拟账户
- 该类的属性和方法如下图 
- 该类包括的属性：
- 账号id
- 余额 balance
- 年利率 annualInterestRate

- 该类包含的方法
- 访问器方法(get set)
- 取款方法withdrawal()
- 存款方法deposit()

- 提示:
- 在提款方法 withdrawal 中 需要判断余额是否能够满足提款数额的要求如果不能，应给出提示。
<!-- 
  ------------
    Account
  ------------
  private int id
  private double balance
  private double annualInterestRate
  ------------
  public Account (int id, double bal ance, double  annualInterestRate )
  ------------
  public
  String getFir stName()
  public
  String getLastName()
  public
  Account getAccount()
  public void setAccount(Account account)
  ------------
 -->


- 创建 Customer 类
- 声明三个私有对象属性： firstName 、 lastName 和 account 。
- 声明一个公有构造器，这个构造器带有两个代表对象属性的参数（ f 和 l
- 声明两个公有存取器来访问该对象属性，方法 getFirstName 和 getLastName 返回相应的属性。
- 声明 setAccount 方法来对 account 属性赋值。
- 声明 getAccount 方法以获取 account 属性。


> 类的关联关系
- 在一个类中声明另外一个类 这种关系叫做关联关系
- Customer类中将Account类当做属性 这种就是关联关系
<!-- 
  ------------
    Customer
  ------------
  private String firstName
  private String lastName
  private Account account
  ------------
  public Customer(String f,String l)
  ------------
  public int getId()
  public double getBalance()
  public double getAnnualInterestRate()
  public void setId( int id)
  public void setBalance(double balance)
  public void setAnnualInterestRate(double annualInterestRate)
  public voi
  d with d raw (double amount) 取钱
  public void deposit (double amount) 存钱
  ------------
 -->

- 写一个测试程序。
- 创建一个 Customer ，名字叫 Jane Smith, 他有一个账号为 1000 ，余额为 2000 元， 年利率为 1.23 的账户。

- 对 Jane Smith 操作。
- 存入
- 100 元，再取出 960 元 。 再 取出 2000 元。
- 打印出Jane Smith 的基本信息
<!-- 
  成功存入 ：100.0 
  成功取出：960.0 
  
  余额不足，取款失败 
    Customer [Smith, Jane] has a account: id is 1000, annualInterestRate is 1.23 ％％, balance is 1140.0
 -->


- 这两个类的关系
- Customer类是人的信息 内部包含姓名和银行账户
- Account类是账户的信息 内部包含余额 年利率 和 账户 以及操作账户的方法

- Customer类是包含(该类里面有一个属性是Account类)Account类的

<!-- 
  // 测试类
  public class CustomerTest {
    public static void main(String[] args) {
      // 初始化指定姓名的账户信息
      Account account = new Account(1000, 2000, 0.0123);

      // account还没有初始化 为null
      Customer JS = new Customer("Jane", "Smith");


      // 该方法让账户和客户一一对应 
      说白了就是让它们两个有关系 JS客户有了账户了 
      相当于银行创建了一个账户 然后给了JS一张卡 JS就可以操作这个账户 这
      
      个账户现在有两个指针 JS 和 account对象 都可以操作账户
      JS.setAccount(account);


      // getAccount返回这个账户 就说明拿到了 account对象 该对象中有对应的存钱取钱的方法
      JS.getAccount().deposit(100);
      JS.getAccount().withdraw(960);
      JS.getAccount().withdraw(2000);
    }
  }


  // Account 类
  public class Account {
    // 账号
    private int id;
    // 余额
    private double balance;
    // 年利率
    private double annualInterestRate;


    // 构造器 对账号 余额 年利率的初始化
    public Account(int id, double balance, double annualInterestRate) {
      this.id = id;
      this.balance = balance;
      this.annualInterestRate = annualInterestRate;
    }

    public int getId() {
      return this.id;
    }

    public void setId(int id) {
      this.id = id;
    }

    public double getBalance() {
      return this.balance;
    }

    public void setId(double balance) {
      this.balance = balance;
    }

    public double getAnnualInterestRate() {
      return this.annualInterestRate;
    }

    public void setAnnualInterestRate(double annualInterestRate) {
      this.annualInterestRate = annualInterestRate;
    }

    // 取钱
    public void withdraw(double amount) {
      if(this.balance < amount) {
        System.out.println("余额不足 取款失败");
        return;
      }
      // 走到下面的逻辑说明余额够了 那就进行取款的操作
      balance -= amount;
      System.out.println("成功取出: " + amount);
    }

    // 存钱
    public void deposit(double amount) {
      if(amount > 0) {
        this.balance += amount;
        System.out.println("成功存入: " + amount);
      }
    }
  }


  // Customer类
  public class Customer {
    
    private String firstName;
    private String lastName;

    // 首次出现自定义类的变量 -- 变量可以是任何数据类型 也可以是一个Accout类的用户
    private Account account;

    // 构造器 对firstName lastName进行初始化
    public Customer(String firstName, String lastName) {
      this.firstName = firstName;
      this.lastName = lastName;
    }

    public String getFirstName() {
      return this.firstName;
    }
    public String getLastName() {
      return this.lastName;
    }
    // 得到这个account对象 可以通过该对象调用account中的方法
    public Account getAccount() {
      return this.account;
    }

    // 通过该方法让account属性也指向 new Account 创建的对象
    public void setAccount(Account account) {
      this.account = account;
    }
  }


 -->

----------------------------

### 实验2： Account Customer
- 这个比上一个实验1 更加的难一些 除了上面的Account Customer之外还有一个银行的类 银行的类可以存多个客户 这就构成了一个由客户构成的数组

<!-- 
  ----------------
    Account
  ----------------
  - balance: double
  ----------------
  +Account(init_balance: double)    -- 构造器
  +getBalance(): double
  +deposit(amt: double)
  +withdraw(amt: double)
  ----------------

  在提款方法 withdraw中 需要判断用户余额是否能够满足提款数额的要求
  如果不能应给出提示 deposit方法表示存款
 -->

<!-- 
  ----------------
    Customer
  ----------------
  -firstName: String
  -lastName: String
  -account: Account
  ----------------
  +ACustomer(f:String, l:String)    -- 构造器
  +getFirstName(): String
  +getLastName(): String
  +getAccount(): Account
  +setAccount(acct:Account)
  ----------------
 -->

<!-- 
  ----------------
    Bank
  ----------------
  -customers: Customer[]
  -numberOfCustomer:int
  ----------------
  +Bank()    -- 构造器
  +addCustomer(f:String, l:String)
  +getNumberOfCustomers(): int
  +getCustomer(index:int):Customer
  ----------------

  addCustomer方法必须依照参数(姓 名) 构造一个新的Customer对象
  然后把它放到customer数组中
  还必须把numberOfCustomer属性的值加1

  getNumberOfCustomers方法返回 numberofCustomers 属性值
  getCustomer方法返回 numberofCustomers属性值
  getCustomer方法返回与给出的index参数相关的客户
 -->

- 创建 bankTest 类 进行测试

> Account类
- 这个类为账户的类 提供了存钱 取钱 查看余额的方法 
- 构造器初始化的余额


> Customer类
- 这个类为客户信息 姓名和关联哪个账户
- 构造器初始化用户姓名 提供了获取该客户账户 和 设置该客户账户的方法


> Bank类
- 这个类为银行账户
- 属性：
- 有存放多个客户的数组 
    private Customer[] customers;

- 有实际客户数量
    private int numberOfCustomers;
<!-- 
  注意
  客户的个数和customers数组的长度不是一个东西 
  比如我们有一个客户数组能存放10个客户 但是实际上里面存了2个客户 numberOfCustomers 就是这两个客户 所以这个部分不能用数组的长度来衡量
 -->

- 方法:
- 添加客户
<!-- 
  public void addCustomer(String f, String l) {

    // 创建客户对象
    Customer cust = new Customer(f, l);

    // 将客户对象加入到 customers 数组中
    customers[numberOfCustomers] = cust;
    numberOfCustomers++;
    // customers[numberOfCustomers++] = cust; 还可以这样
  }

  我们第一次往customers数组里添加的时候 customers的下标应该为0
  这里首次调用的时候我们应用到了numberOfCustomers变量
  因为它的默认值为0 同时还可以刻画实际用户数量
 -->

- 获取指定用户的信息
<!-- 
  public Customer getCustomer(int index) {
    // return customers[index];  这样的话不严谨 可能包异常

    if(index >= 0 && index < numberOfCustomers) {
      return customers[index];
    } 
    
    return null;
  } 
-->

- 代码部分:
<!-- 

  // BankTest类
  public class BankTest {
    public static void main(String[] args) {
      // 首先造一个银行
      Bank bank = new Bank();
      // 添加用户 
      bank.addCustomer("Jane", "Smith");
      // 先得到刚才添加的用户对象调用setAccount方法 关联一个账户
      bank.getCustomer(0).setAccount(new Account(2000));

      // 取得第一个用户调用对应的方法
      bank.getCustomer(0).getAccount().withdraw(500);
      double balance = bank.getCustomer(0).getAccount().getBalance();
      System.out.println("客户: " + bank.getCustomer(0).getFirstName() + bank.getCustomer(0).getLastName() + "的账户余额为: " + balance);
    }
  }


  // Account类
  public class Account {
    // 余额
    private double balance;

    public Account(double init_balance) {
      this.balance = init_balance;
    }

    public double getBalance() {
      return balance;
    }

    // 存钱
    public void deposit(double amt) {
      if(amt > 0) {
        balance += amt;
        System.out.println("存入金额为: " + amt);
      }
    }

    // 取钱
    public void withdraw(double amt) {
      if(balance < amt) {
        System.out.println("余额不足");
        return;
      }
      balance-=amt;
      System.out.println("取出金额: " + amt);
    }
  }


  // Customer类
  public class Customer {
    private String firstName;
    private String lastName;
    private Account account;

    public Customer(String f, String l) {
      this.firstName = f;
      this.lastName = l;
    }

    public String getFirstName() {
      return this.firstName;
    }
    public String getLastName() {
      return this.lastName;
    }
    public Account getAccount() {
      return this.account;
    }
    public void setAccount(Account acct) {
      this.account = acct;
    }
  }


  // Bank类
  public class Bank {
    
    // 用来存放多个客户对象的数组
    private Customer[] customers;

    // 记录实际客户的个数
    private int numberOfCustomers;

    public Bank() {
      // private Customer[] customers; 只是创建了装数组的变量 并没有实际new一个数组 这里我们new一个
      this.customers = new Customer[10];
    }

    // 添加客户
    public void addCustomer(String f, String l) {
      // 创建客户对象
      Customer cust = new Customer(f, l);

      // 将客户对象加入到 customers 数组中
      - customers第一次是数组为0的位置 这里我们应用到了numberOfCustomers变量 
      - 首次调用的时候 它的默认值为0
      customers[numberOfCustomers] = cust;
      numberOfCustomers++;
        // customers[numberOfCustomers++] = cust; 还可以这样
    }

    // 获取实际客户的数量
    public int getNumberOfCustomers() {
      return this.numberOfCustomers;
    }

    // 获取指定用户的信息
    public Customer getCustomer(int index) {
      // return customers[index];  这样的话不严谨

      if(index >= 0 && index < numberOfCustomers) {
        return customers[index];
      } 
      
      return null;
    }

  }
 -->

----------------------------

### 关键字 package import 的使用

> package关键字的使用
- package翻译过来就是 包
- 1. 为了更好的实现项目中类的管理 提供了包的概念
- 我们可以在项目中按照功能创建多个包 我们写的类就放在包下
<!-- 
  比如一个班级就相当于一个package
 -->


- 2. 使用package声明 类或接口 所属的包 声明在源文件的首行
- package com.atguigu.exer

- 3. 包 属于标识符 需遵循标识符的命名规则 规范 "见名知意"
- 包名都是小写
- 通过包名大概也能看出下面的内容是做什么的

- 4. src.com 每.一次就代表一层文件目录

- 补充:
- 同一个包下 不能命名同名的接口 或者 类
- 不同的包下可以命名同名的接口 或者 类
<!-- 
  不能定义同名文件
 -->


> JDK中主要的包介绍
- 1. java.lang
    - 包含一些java语言的核心类 如String Math Integer System 和 Thread 提供常用的功能

- 2. java.net
    - 包含执行与网络相关的操作的类和接口

- 3. java.io
    - 包含能提供多种输入 输出功能的类

- 4. java.util
    - 包含一些使用工具类 如定义系统特性 接口的集合框架类 使用与日期日历相关的函数

- 5. java.text
    - 包含了一些java格式化相关的类

- 6. java.sql
    - 包含了java进行JDBC数据库编程的相关类 接口

- 7. java.awt
    - 包含了构成抽象窗口工具集(abstract window toolkits)的多个类
    - 这些类被用来构建和管理应用程序的图形用户界面 b/s c/s
<!-- 
  java可以写客户端的api 现在java一般都是写后台了 这部分可以不看了
 -->


> import关键字的使用
- import翻译过来的话为 导入

- 作用:
- 1. 在源文件中显式的使用 import 导入指定包下的类 或 接口
- 2. 声明在包的声明和类的声明之间
<!-- 
  import java.util.Arrays
  import src.com.Bank
 -->

- 3. 如果需要导入多个结构 顺序向下一次写出即可
- 当我们使用了一个包下的多个类时 我们可以采用这样的书写方式 
<!-- 
  // 导入指定包下的所有结构
  import src.com.*
 -->

- 4. 如果使用的类或接口是java.lang包下定义的 则可以省略import结构
<!-- 
  // 这里的 String[] 和 System 为什么就不用导包  
  public static void main(String[] args) {
    System.out.println()
  }
 -->

- 5. 如果使用的类或接口是本包下定义的 可以省略import结构
<!-- 
  如果我们调用的是其它包下的 或者 lang包下定义的 则需要显式的使用import结构导入包
 -->

- 6. 如果在源文件中 使用了不同包下的同名的类 则必须至少有一个类需要以 全类名 的方式显示(包含包在内的完整的路径名)
- 如： src.azz.Account acct = new Account();

- 当我们想要使用的类处于不同包下且该类还同名的时候 我们就要使用包名指定该类了
<!-- 
  src.com
    class Account { }

  src.azz
    class Account { }

  
  上面的同名Account类处于不同的包下 假如我们要在一个文件中同时使用Account类的话

  1. 先导入其中的一个包下的类 import src.com.Account
  2. 然后 当要想使用azz下的Account类的时候 使用包名指定类

      src.azz.Account acct = new Account();
    
     没写包名的就会使用 import 导入的
 -->

- 7. 如果使用'xxx.*'的方式表明可以调用xxx包下的所有结构 但是如果使用的是xxx子包下的结构 则仍需要显示导入
- * 不包括子包
<!-- 
    src.com
      java文件1
      java文件2

      src.azz
        java文件3

  com下有一个子包azz 假如我们再java文件1中 想使用java文件3的话 仍需要使用import 显式导入
 -->

**注意:**
- 上面说过当使用的是 java.lang 包下的结构的时候 我们不用使用import显示导入

- 但是如果我们使用的是 java.lang.子包 的时候 仍需要显式导入

- 总结:
- 遇到子包的时候 就显式导入吧

- 8. import static 导入指定类或接口中的静态结构(属性或者方法)
<!-- 
  比如我们可以这样 表示使用System下的静态结构
  import static java.lang.System.*

  这么写后就可以直接写
  out.println()

  import static java.lang.Math.*
 -->

**注意:**
- import 的落脚点是一个类
- import static 的落脚点必须是类中的一个结构
<!-- 
  import static java.lang.Math.*

  不能是
  import static java.lang.Math 落脚点不能试Math类 必须是里面的一个结构
 -->

----------------------------

### MVC的设计模式
<!-- 
  我们创建一个工程的时候会有很多的类 这些类我们通过包的方式来进行管理 
  对于管理的话 我们有一种设计模式
 -->

- mvc是常用的设计模式之一 将整个程序分为3个层次
- 视图模型层 V
- 控制器层 C
- 数据模型层 M

- 这种将程序输入输出 数据处理 以及数据的展示分离开来的设计模式
- 使用程序结构变的灵活而且清晰 同时也描述了程序各个对象间的通信方式
- 降低了程序的耦合性


> 模型层 model 主要处理数据 - 数据保存
- 数据对象封装 model.bean / domain
- 数据库操作类 model.dao
- 数据库      model.db


> 视图层 view 显示数据 - 用户界面
- 相关工具类  view.utils
- 自定义view view.ui


> 控制层 controller 处理业务逻辑
- 应用界面相关      controller.activity
- 存放fragment     controller.fragment
- 显示列表的适配     controller.adapter
- 服务相关的        controller.service
- 抽取的基类        controller.base


> 各个部分之间的通信
- 1. view传送指令到controller
- 2. controller完成业务逻辑后 要求 model 改变状态
- 3. model将新的数据发送到view 用户得到反馈

- 所有的通信都是单向的
<!-- 
                View

            ↙         ↖

    Controller    →     Model
 -->


> MVP模式
- 模式将 Controller 改名为 Presenter，同时改变了通信方向。
- 1. 各部分之间的通信，都是双向的。
- 2. View 与 Model 不发生联系，都通过 Presenter 传递。
- 3. View 非常薄，不部署任何业务逻辑，称为"被动视图"（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。
<!-- 
              View

          ↗↙         

    Presenter    → ←    Model
 -->


> MVVM
- MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。
- 唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然
<!-- 
              View

          ↗↙          

       VM    → ←    Model
 -->

----------------------------

### 项目2 客户信息管理软件
- 模拟实现一个基于文本界面的 <客户信息管理软件>
- 进一步掌握编程技巧 和 调试技巧 熟悉面向对象编程
- 主要涉及以下知识点
- 1. 类结构的使用 属性 方法以及构造器
- 2. 对象的创建与使用
- 3. 类的封装性
- 4. 声明和使用数组
- 5. 数组的插入 删除 和 替换
- 6. 关键字的使用 this

- 该软件由以下三个模块组成
- 1. CustomerView
- 2. CustomerList
- 3. Customer

- CustomerView为主模块 负责菜单的显示和处理用户操作
- CustomerList为Customer对象的管理模块 内部用数组管理一组Customer对象 并提供相应添加 修改 删除 和 遍历方法 供CustomerView调用
- Customer为实体对象 用来封装客户信息

- 我们可以把 Customer类 放在 bean包下
<!-- 
  | - src
    | - cmu
      | - bean
        - Customer类

      | - service
        - CustomerList类    controller层

      | - ui
        - CustomerView类    view层

      | - util
        - 老师提供的类

  这里我们按照业务不一样 将不同的类放入不同的包下
 -->

> Customer类
- 初始化客户的信息 内部根据属性分别提供了get set方法
<!-- 
  package src.cmu.bean;
  public class Customer {
    private String name;

    // 性别的变量类型为什么用char
    private char gender;
    private int age;
    private String phone;
    private String email;

    public String getName() {
      return this.name;
    }

    public void setName(String name) {
      this.name = name;
    }

    public char getGender() {
      return this.gender;
    }

    public void setGender(char gender) {
      this.gender = gender;
    }

    public int getAge() {
      return this.age;
    }

    public void setAge(int age) {
      this.age = age;
    }

    public String getPhone() {
      return this.phone;
    }

    public void setPhone(String phone) {
      this.phone = phone;
    }

    public String getEmail() {
      return this.email;
    }

    public void setEmail(String email) {
      this.email = email;
    }

    // 提供一个空参的构造器
    public Customer() {}

    // 提供一个给所有属性赋值的构造器
    public Customer(String name, int age, char gender, String phone, String email) {
      this.name = name;
      this.age = age;
      this.gender = gender;
      this.phone = phone;
      this.email = email;
    }
  }

 -->


























----------------------------

### 创建工程的流程
> 1. 先创建 package
<!-- 
  包名: 小写
  作用: 包相当于一个班级 每一个java文件相当于一个同学

  包名规范:
    公司域名倒叙.项目功能名
    com.atguigu.contact

  网上说创建一个包 就是创建一个文件夹 但是文件夹中不能出现.
  所以创建包的时候 com/demo
 -->


> vs code中的包
- vscode中是根据打开的文件夹来选定包名 也就是说 文件夹就是包
- 1. 如果 .java 文件处于打开的文件夹的根目录下 就不会被要求输入包名
- 2. 如果 .java 文件处于打开文件夹的子文件夹中 .java文件会全部被要求在文件头处输入 package 语句

> package 文件夹名;
- 上面就是如果 .java 文件处于子文件夹中 就要求该文件在开头出 写上这样的语句
  

> 2. 在创建好的包下 右键创建class 就会生成一个java文件
<!-- 这是在老师讲的es编辑器中是这么操作的 -->

- https://blog.csdn.net/weixin_39777637/article/details/110474775



> 有 包 的情况下的 命令行 方式
- package src.com;
- java_exer
  - com
    Demo.java

- 1. 注意包名结构 返回 最开的src的上一层目录
- 执行命令: javac -d . src/包名(文件夹名)/文件名.java
- 执行命令: java src.包名.类名 (执行这个包下的指定类)
<!-- 
  javac -d . src/com/Demo.java
  java src.com.Demo

  注意:
  - 1. 返回src的上一层执行命令
  - 2. 路径都是从src开始的
 -->

> 命令解析:
- 指定编译生成的class文件存放路径 javac -d
- -d 指明 类层次的根目录
- . 就是当前目录


> 包名的命名规范
- https://www.cnblogs.com/luckforefforts/p/13642694.html


### Java基础教程所需软件下载地址：
- 链接: 
- https://pan.baidu.com/s/10P6JbKN6TG7wW-QXV8ANdQ 提取码: nkbv


### 基础扩展部分

### 命令
- java
  执行java文件时 使用的命令

- javac
  编译的时候 使用的命令
  编译成面都是些语法层面的问题

- javadoc
  生成一个以网页形式的文档


> Java当中的多环境切换
<!-- 
  "java.configuration.runtimes": [
      {
          "name": "JavaSE-1.8",
          "path": "D:\\soft\\Java\\jdk1.8.0_231",
          "default": true
      },
      {
          "name": "JavaSE-11",
          "path": "D:\\soft\\Java\\jdk-11.0.2",
      },
  ],
 -->


### Oracle密码
- Xl5467426/
https://login.oracle.com/mysso/signon.jsp


/Library/Java/JavaVirtualMachines/jdk-11.0.13.jdk/Contents/Home/
/Library/Java/JavaVirtualMachines/jdk1.8.0_311.jdk/Contents/Home/


/Library/Java/JavaVirtualMachines/jdk-11.0.13.jdk/Contents/Home


> 环境变量
JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_311.jdk/Contents/Home/
PATH=$JAVA_HOME/bin:$PATH:
CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.
export JAVA_HOME
export PATH
export CLASSPATH


- 多版本jdk切换
<!-- 
  export JAVA_8_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_311.jdk/Contents/Home
  export JAVA_11_HOME=/Library/Java/JavaVirtualMachines/jdk-11.0.13.jdk/Contents/Home

  export JAVA_HOME=$JAVA_8_HOME

  alias jdk8="export JAVA_HOME=$JAVA_8_HOME"
  alias jdk11="export JAVA_HOME=$JAVA_11_HOME"

  export PATH=$PATH:$JAVA_HOME/bin:$GRADLE_HOME/bin
 -->

- sudo -i vi /etc/.bash_profile
- source /etc/.bash_profile

- source ~/.bash_profile



### 环境搭建

> JDK
- 它是提供给java开发人员使用的 其中包含了java的开发工具 也包括了JRE
- 安装了JDK 就不用单独安装JRE了
- JDK里面包含了两个部分

- JRE java运行环境
- 开发工具： 编译工具 javac.exe  打包工具 jar.exe等


> JRE java运行环境
- 包括java虚拟机和java程序所需的核心类库(java se)等
- 如果想要运行一个开发好的java程序 计算机中只需要安装JRE即可

- 简单而言 使用 JDK 的开发工具完成的java程序 交给JRE去运行


> JRD
- JRD = JVM + Java核心类库


> 环境变量中的 JAVA_HOME
- 它里面存的是bin的上一层目录
<!-- path = %JAVA_HOME%\bin   //这是window里面的 -->


> JDK的安装地址
- www.oracle.com
- java.sun.com


### Java
- java基础是学习javaEE 大数据 android开发的基石

- 常用语法
- C C++ Java PHP Kotlin Python Scala等
<!-- 
  Kotlin 谷歌出的语言 用来开发安卓的
  python 快速开发效率高 适合处理数据 跟java比起来小巫见大巫
  Oc 苹果的开发语言
  Go 具有java的开发效率 和 C的执行效率
 -->

- Java语言的应用可以应用在3个不同的领域当中

>  Java SE 标准版
- 支持面向桌面级应用的Java平台 提供了完整的Java核心API 此版本以前成为J2EE
<!-- QQ 360 -->

>  Java EE 企业版
- 为企业环境下的应用程序提供的一套解决方案 该技术体系中包含的技术如 Servlet Jsp等 主要针对Web应用程序开发 版本以前成为 J2EE
<!-- Web后台 -->

>  Java ME 小型版
- 支持Java程勋运行在移动端上的平台 对Java API有所精简 并加入了针对移动端的支持 此版本以前成J2ME

>  现在 Java 应用的领域
- 1. 企业级应用
  后台开发
  主要指复杂的大企业的软件系统 各种类型的网站 java的安全机制以及它的跨平台的优势 使它在分布式系统领域开发中有广泛应用 应用领域包括金融 电信 电子商务

- 2. Android平台应用
  安卓应用程序使用java语言编写 安卓开发水平的高低很大程度上取决于java语言核心能力是否扎实

- 3. 大数据平台开发
  大数据都提供给java接口


>  java语言的特点
- 跨平台性
- 我们java的应用程序实际上是跑在JVM上面的 JVM装在了不同的操作系统上 因为有了JVM 同一个Java程序在三个不同的操作系统中都可以执行 这样实现的java程序的跨平台性

- 不同操作系统的jvm不同
<!-- 
  window linux mac
 -->


> JVM 虚拟机
- jvm是一个虚拟的计算机 具有指令集并使用不同的存储区域 负责执行指令 管理数据 内存 寄存器

- 对于不同的平台 有不同的虚拟机
- 只有某平台踢动了对应的java虚拟机 java程序才可以在此平台运行
- java虚拟机机制屏蔽了底层运行平台的差别 实现了 一次编译 到处运行

- 我们写的源代码进经过编译后形成字节码文件
- 我们在画内存图的时候说变量放在栈还是堆 指的是运行的时候
- 编译源代码后还是一个硬盘上的文件 在运行这个文件的时候 才会执行里面的代码创建类 属性 变量 对象等 这时候我们才会根据代码里面的内容 分配内存空间


### 人机交互方式
- 图形化界面 GUI
- 命令行方式 CLI
- 需要有一个控制台 输入特定的指令 让计算机完成一些操作


### 中央处理器
- CPU是计算机的大脑，它从内存中获取指令 然后执行这些指令

- 包括：
- 控制单元 和 算术/逻辑单元

- 控制单元：
- 用于控制和协调其他组件的动作

- 算术/逻辑单元：
- 用于完成数值运算 + - * / 和逻辑运算比较

- 每台计算机中都有一个内部时钟 该时钟以固定速度发射电子脉冲 时钟速度越快 在给定的时间段内执行的指令就越多
- 速度的计量单位是Hz 1Hz相当于每秒一个脉冲 随着cpu速度不断的提供 目前以千兆赫GHz来表述
<!-- 
  买电脑看GHz

  1khz = 1024hz
  1mhz = 1024khz
  1ghz = 1024mhz
 -->

- 最初一个cpu只有一个核core， 核是处理器中实现指令读取和执行的部分
- 一个多核cpu是一个具有两个或者更多独立核的组件 可提高cpu的处理能力

--------------------------------

### 计算机的硬件介绍
<!-- 
  输入设备 -- > 存   储   器 -- > 输出设备

             ↑ ↓       影↓ ↑虚

      -------------------------------
            运算器      控制器
      -------------CPU---------------


            实体箭头 - 数据流
            影体箭头 - 指令流
            虚线箭头 - 控制流
 -->

--------------------------------

### IT定律之计算机行业发展规律
- 摩尔定律
- 安迪-比尔定律
- 反摩尔定律

--------------------------------

### 计算机硬件介绍
- 内存中的信息在断电的时候会丢失 那么我们可以考虑将程序和数据永久的保存在存储设备上
- 当计算机确定需要这些数据的时候 再移入内存 因为从内存中读取比从存储设备读取要快得多

- 存储设备主要有以下三种

> 磁盘驱动器
- 每台计算机至少有一个硬盘驱动器 硬盘用于永久的保存数据和程序

> 光盘驱动器 CD DVD
- CD的容量可达700mb
- DVD的容量可达4.7gb

> USB闪存驱动器
- 通用串行总线 可以使用usb打印机 数码相机 鼠标 外部硬盘驱动器连接到计算机上
- usb闪存驱动器很小 可用于存储和传输数据的设备


> 比特bit 和 字节byte
- 在讨论内存前 先清除数据是如何存储在计算机中的

- 计算机就是一系列的电路开关 每个开关存在两种状态：
- 关 和 开
- 如果电路是开的 它的值就是1
- 如果电路是关的 它的值就是0

- 一个0 或者 一个1存储为一个比特bit 是计算机中最小的存储单位
- 计算机中最基本的存储单元是字节 byte 每个字节由8个比特构成 从存储数据的角度来看字节才是最小的单位

- 计算机的存储能力是以字节和多字节来衡量的如下

  千字节    kb = 1024b
  兆字节    mb = 1024kb
  千兆字节  gb = 1024mb
  万亿字节  tb = 1024gb

- 后面还有pb eb zb yb等单位


> 内存 RAM
- 由一个有序的字节序列组成 用于存储程序以及程序需要的数据
- 一个程序和他的数据在被cpu执行前必须移动计算机的内存中

- 每个字节都有一个唯一的地址 使用这个地址确定字节的位置 以便于存储和获取数据
<!-- 
  2000    01000011
  2001    01110010
 -->

- 一个计算机具有的ram越多 它的运行速度就越快 但是此规律是有限制的
- 内存与cpu一样 也构建在表面嵌有数百万晶体管的硅半导体芯片上 但内存芯片更简单 更低速 更便宜

<!-- 
      CPU         内存         硬盘

                              美女.jpg    二进制文件

  怎么将图片显示在屏幕上是要做运算的 并不是从硬盘直接到cpu 
  要想要cpu使用硬盘的数据 必须要将数据加载到 内存中

  cpu 只跟内存 进行交互 cpu的数据都是从内存中来来回回的读 再写到内存当中

  硬盘中的数据必须也要先加载到内存里面 
 -->

- 实测发现：
- 内存的读取数据的速度是硬盘读取速度的10倍 在某些环境里 硬盘和内存之间的速度差距可能会更大 而cpu的速度比内存不知道还要快多少倍

- 当我们把程序从硬盘放到内存以后 cpu就直接在内存运行程序 这样比cpu直接在硬盘运行程序要快很多

- 内存解决了一部分cpu运行过快 而硬盘数据存取太慢的问题 提供了我们电脑的运行速度 内存就如同一条高速车道 数据由传输速度较慢的硬盘通过这高速车道传送至cpu进行处理

- 但内存是带电存储的一旦断电数据就会消失 而且容量有限 所以要长时间存储程序或数据就需要使用硬盘

- 内存在这里起了两个作用
- 1. 保存硬盘读取的数据 提供给cpu使用
- 2. 保存cpu的一些临时执行结果 以便cpu下次使用或保存到硬盘

--------------------------------

### 输入与输出设备
- 常见的输入设备
  键盘 和 鼠标

- 常见的输出设备
  显示器 和 打印机

- 显示器屏幕分辨率：
  是指显示设备水平和垂直方向上显示的像素 px 
  分辨率可以手工设置
  分辨率越高 图像越锐化 越清晰

--------------------------------

### 万维网 因特网 互联网
- 关系
- 互联网 > 因特网 > 万维网
<!-- 
  万维网是无数个网络站点和网页的集合 他们在一起构成了因特网最主要的部分
  它实际上是多媒体的集合 是由超级链接连接而成的 我们通常通过网络浏览器上网观看的 就是万维网的内容

  万维网只是因特网最主要的一个部分 这里只说了 web客户端和web服务端
  因特网实际上还包含了 电子邮件 usenet以及新闻组

  互联网是最大的一个概念
 -->

--------------------------------

### 字符集
- 在计算机的底层都是2进制的 所有的汉字代码在底层存的时候 都是010101
- 比如
  一个 a 它是97
  一个 b 它是98
  一个 c 它是99

  我们将 97 98 99 用二进制去表示 传递给计算机底层
  当我们打开某个文件的时候 再通过某种字符集的方式再还原回去a b c

  我们如何将 a 对应成 2进制 再还原回来 中间的对应关系 就叫做字符集
  <!-- 
    Unicode 编码

    - 乱码
    - 世界上存在着多种编码方式 同一个二进制数字可以被解释成不同的符号 因此 要想打开一个文本文件 就必须知道它的编码方式 否则用错误的编码方式解读 就会出现乱码


    - unicode
    - 一种编码 将世界上所有的符号都纳入其中 每一个符号都给予一个独一无二的编码 使用 unicode没有乱码的问题


    - unicode的缺点
    - unicode只规定了符号的二进制代码 却没有规定这个二进制代码应该如何存储 无法区别unicode和asc2 

    - 计算机无法区分三个字节表示一个符号还是分别表示三个符号 另外我们知道 英文字母只用一个字节表示就够了 如果unicode统一规定 每个符号用三个或者四个字节表示 那么每个英文字母前必然有2到3个字节是0 这对存储空间来说是极大的浪费



    真正落地实施的是 utf-8
    它是unicode是一种实现方式 也是更大的一种字符集 它是一种边长的编码方式 它可以使用1-6个字节表示一个符号 根据不同的符号而变化字节的长度

    - utf-8的编码规则
    - 对于单字节的utf-8编码 该字节的最高位为0 其余7位用来对字符进行编码
    - 对于多字节的utf-8编码 如果编码包含n个字节 那么第一个字节的前n位为1
    - 第一个字节的n + 1位为0 该字节的剩余各位用来对字符进行编码 在第一个字节之后的所有字节 都是最高两位为 10 其余6位用来对字符进行编码
   -->


### 数据结构
- 1. 数据 与 数据 之间的逻辑关系: 比如
- 集合 一对一 一对多 多对多
- 一对一 - 类似链表
- 一对多 - 树形结构(DOM树 顶层为html)
<!-- 
    一对2 就是 2叉树
    一对3 就是 3叉树

      a
    ↙   ↘
  □      □
-->

- 多对多
- 典型的就是社交网络 每一个人都是一个节点 这个节点可以延伸出很多别的好友 别的好友也有可能是你 也就是说 你可以发散出去 别人也可以发散到你这里来
<!-- 
    □     □
      ↖ ↗
       □
      ↙ ↘
    □     □
-->

- 2. 数据的存储结构
- 数据之间的关系我们知道了后 我们需要将数据在内存层面 或者 硬盘层面存储起来 我们怎么通过实际的存储结构去刻画 上面说的关系呢？

- 线性表: 主要刻画的是 一对第一 的关系
    - 1. 顺序表（典型的实现就是数组）
    - 2. 链表（它就不是连续的了 依靠的是指针）
    - 3. 栈结构（先进后出 从顶层弹出）
    - 4. 队列（队列是有两个口的 左进右出 谁先进来 谁先出去）


- 树形结构: 主要刻画的是 一对多 的关系
    - 1. 二叉树


- 图形结构: 主要刻画的是 多对多


> 算法
- 排序算法
- 搜索算法