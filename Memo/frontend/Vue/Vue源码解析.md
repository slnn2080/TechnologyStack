### rollup
- 我们使用rollup来搭建环境 它是一个打包工具 是一个js模块打包器 它只负责打包js

- 它比webpack的好处是更加的专注一些 它只打包一些js库 比如react vue都采用的rollup 而且打包出来的代码会非常的简洁 

- 如果我们开发的是一个完整的项目的话 我们可以会采用webpack

- 如果开发的是一个js库那么首选的还是rollup

> 安装
- npm i rollup rollup-plugin-babel @babel/core @babel/preset-env rollup-plugin-serve -D
<!-- 
  rollup-plugin-babel
  将babel和rollup连接成一个桥梁 在rollup打包的过程中直接用babel编译es6
 -->


> 我们看看项目根目录下的各种配置文件

> "dev": "rollup -c -w"
- 使用 rollup打包文件 并实时监测


### 正题:
- 我们在写Vue的时候 形式都是如下:
```js
// options API 通过一个选项进行配置 
new Vue({
  el: "#app"
})
```

- 我们会在里面传递一个对象 在对象中填写很多的配置 我们要根据对象中的属性来实现不同的功能

- 这种方式叫做 options API

- 既然是new的方式 那我们就要导出一个类 我们可以采取下面的方式
```js
class Vue {
  a() {}
}
```

- es6中的写法一般都是一个整体 也就是我们写的方法和原型的方法都是放在上面的 { } 中

- 那我们就会很少采用如下的方式去写代码了
```js
Vue.prototype
```

- 我们希望将原型扩展的方法分散到不同的文件里 我们就不用class的方式了 也就是我们采用构造函数的写法
```js
function Vue() { }

// 这就是给构造函数的原型上扩展方法 我们可以把扩展的方法分散到不同的文件里面
Vue.prototype
```

- options就是new Vue的时候我们传递进来的选项
```js
function Vue(options) {
  console.log(options)
}

export default Vue


// 控制台上输出
{el: '#app'}
```

- 我们拿到new Vue传递进来的参数后我们就要做初始化的逻辑 比如我们调用this._init(options)方法
- 它也叫入口方法
```js
function Vue(options) {
  
  // 我们要做一个初始化的操作
  this._init(options) // 入口方法 做初始化操作
}

export default Vue
```

- 如果我们这么写的话 this._init(options)
- 肯定是类的实例身上的方法 我们后面会说组件 组件它可以能也会用到这个方法 所以我应该把这个方法做成一个公共方法 这样的话大家都可以使用这个方法

- 所以我们可以将这个_init的方法挂载到原型上 这样大家都能够使用 但是又会有新的一个问题 就是以后我们的公共方法会非常的多 然后要列100个方法么
```js
// 初始化方法
Vue.prototype._init = function(options) {

}
```

- 为了方便管理 我们的目的是 希望把我们的代码进行一个划分 比如我们有专门初始化的 我们专门写一个文件去管理初始化的逻辑 后面我们还有专门管理这个Vue的生命周期 还有管理它的渲染函数的

- 所以我们就想我们能不能把 初始化方法解耦出去呢？
- 做成一个个的插件 作为插件来使用
```js
Vue.prototype._init = function(options) {

}
```

- 我们写成一个个的插件进行对原型的扩展 接下来我们就将初始化的逻辑单独的搞个文件来管理 我们在src下创建一个init.js文件 

- 记住只要是一个插件就是一个函数
```js
// 这里我希望接收到Vue构造函数 我们拿到Vue后在这个js文件里面做初始化的事情
export function initMiXin() {
  
  Vue.prototype._init = function(options) {

  }
}
```

- 那整个逻辑就变成了 我们上面定义好插件 然后在index.js文件中调用initMiXin() 将Vue构造函数传递进去
```js
import { initMiXin } from "./init"

function Vue(options) {
  
  this._init(options)
}

initMiXin(Vue)

export default Vue
```

- Vue里面会把用户填的所有属性都放在当前的实例上 
```js
// Vue会返回实例
let vm = new Vue({

})
```

- 这个实例vm身上会有一个 $options 这个里面就会包含着 我们new Vue的时候传入的配置对象
```js
export function initMiXin(Vue) {

  Vue.prototype._init = function(options) {
    
    // 拿到当前的实例 this就是new出来的实例
    const vm = this 
    vm.$options = options
  }
}
```


- Vue里面核心的特性就是响应式数据原理
- Vue是一个什么样的框架 MVVM? 文档里面都说了Vue不是一个MVVM框架 它也有VM但是不完全是

- 数据变化视图会更新 视图变化数据会被影响
<!-- 
  比如表单中输入内容会自动跑到数据里
 -->

- MVVM正常是不能跳过数据去更新视图 就是我只能去改数据取更新视图 但是Vue里面就不遵循这个方法 比如说Vue里面有ref 它就可以直接去操作DOM 想改啥改啥 所以这是不符合MVVM的设计思想 所以官方文档中说 我内部只是参考mvvm 但并不是完全一样 所以它并不是一个MVVM框架

- 上面扩展了下知识点 下面我们回顾整体来初始化状态
- 我们要在初始化状态中 将数据进行一个所谓的劫持 因为 让数据一变视图去更新

- 所以呢我们要先做一个状态初始化 但是一个Vue组件里面它有很多个状态

- 比如我们 new Vue({}) 它就是一个组件 我们的 data props watch computed 它们都是和数据相关

- 我们要先完成一个状态初始化 然后对data props watch computed不同的属性做不同的处理

- 我们创建一个state.js文件 它是一个状态的文件
- 逻辑变成了 _initMinXin() 是init.js文件 用来初始化Vue的

- 我们定义了state.js文件 用来初始化状态的 我们在init.js文件中调用state.js中的函数
```js
// state.js
// 做一个状态的初始化 这里传入一个当前的实例 因为vm上有一个$options属性 它里面就使用户传入的所有选项
export function initState(vm) {

}



// init.js
import { initState } from "./state"
export function initMiXin(Vue) {

  Vue.prototype._init = function(options) {
    
    const vm = this 
    vm.$options = options


    // 初始化状态(将数据做一个初始化的劫持 当我修改数据的时候 应该更新视图) 
    // 当我们初始化(Vue)的时候 就要初始化状态
    initState(vm)
  }
}
```



















### .gitignore 忽略git文件
- 里面直接写 node_modules 就可以了

- Kinoto的忽略文件
```
#custom
.DS_Store
Thumbs.db

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock
# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage

# nyc test coverage
.nyc_output

# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/
node_modules/
linter/

# TypeScript v1 declaration files
typings/

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env

# next.js build output
.next

# JetBrains IDE
.idea/
*.iml
# Visual Studio Code
.vscode/
dist/
_preview/assets/style/
_preview/assets/javascripts/
_preview/assets/json/
```


